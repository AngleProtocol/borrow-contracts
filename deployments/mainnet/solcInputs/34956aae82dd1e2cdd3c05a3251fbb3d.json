{
  "language": "Solidity",
  "sources": {
    "contracts/agToken/AgToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/coreModule/IStableMaster.sol\";\nimport \"../interfaces/ITreasury.sol\";\n// OpenZeppelin may update its version of the ERC20PermitUpgradeable token\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\n/// @title AgToken\n/// @author Angle Core Team\n/// @notice Base contract for agToken, that is to say Angle's stablecoins\n/// @dev This contract is used to create and handle the stablecoins of Angle protocol\n/// @dev It is still possible for any address to burn its agTokens without redeeming collateral in exchange\n/// @dev This contract is the upgraded version of the AgToken that was first deployed on Ethereum mainnet\ncontract AgToken is IAgToken, ERC20PermitUpgradeable {\n    // ========================= References to other contracts =====================\n\n    /// @notice Reference to the `StableMaster` contract associated to this `AgToken`\n    address public stableMaster;\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializes the `AgToken` contract\n    /// @param name_ Name of the token\n    /// @param symbol_ Symbol of the token\n    /// @param stableMaster_ Reference to the `StableMaster` contract associated to this agToken\n    /// @dev By default, agTokens are ERC-20 tokens with 18 decimals\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address stableMaster_\n    ) external initializer {\n        __ERC20Permit_init(name_);\n        __ERC20_init(name_, symbol_);\n        require(stableMaster_ != address(0), \"0\");\n        stableMaster = stableMaster_;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ======= Added Parameters and Variables from the first implementation ========\n\n    /// @inheritdoc IAgToken\n    mapping(address => bool) public isMinter;\n    /// @notice Reference to the treasury contract which can grant minting rights\n    address public treasury;\n    /// @notice Boolean to check whether the contract has been reinitialized after its upgrade\n    bool public treasuryInitialized;\n\n    // =============================== Added Events ================================\n\n    event TreasuryUpdated(address indexed _treasury);\n    event MinterToggled(address indexed minter);\n\n    // =============================== Added Errors ================================\n\n    error BurnAmountExceedsAllowance();\n    error InvalidSender();\n    error InvalidTreasury();\n    error NotGovernor();\n    error NotMinter();\n    error NotTreasury();\n    error TreasuryAlreadyInitialized();\n\n    // =============================== Setup Function ==============================\n\n    /// @notice Sets up the treasury contract in this AgToken contract\n    /// @param _treasury Treasury contract to add\n    /// @dev The address calling this function has to be hard-coded in the contract\n    /// @dev Can be called only once\n    function setUpTreasury(address _treasury) external {\n        // Only governor\n        if (msg.sender != 0xdC4e6DFe07EFCa50a197DF15D9200883eF4Eb1c8) revert NotGovernor();\n        if (address(ITreasury(_treasury).stablecoin()) != address(this)) revert InvalidTreasury();\n        if (treasuryInitialized) revert TreasuryAlreadyInitialized();\n        treasury = _treasury;\n        treasuryInitialized = true;\n        isMinter[stableMaster] = true;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // =============================== Modifiers ===================================\n\n    /// @notice Checks to see if it is the `Treasury` calling this contract\n    /// @dev There is no Access Control here, because it can be handled cheaply through this modifier\n    modifier onlyTreasury() {\n        if (msg.sender != treasury) revert NotTreasury();\n        _;\n    }\n\n    /// @notice Checks whether the sender has the minting right\n    modifier onlyMinter() {\n        if (!isMinter[msg.sender]) revert NotMinter();\n        _;\n    }\n\n    // ========================= External Functions ================================\n    // The following functions allow anyone to burn stablecoins without redeeming collateral\n    // in exchange for that\n\n    /// @notice Destroys `amount` token from the caller without giving collateral back\n    /// @param amount Amount to burn\n    /// @param poolManager Reference to the `PoolManager` contract for which the `stocksUsers` will\n    /// need to be updated\n    /// @dev When calling this function, people should specify the `poolManager` for which they want to decrease\n    /// the `stocksUsers`: this is a way for the protocol to maintain healthy accounting variables\n    function burnNoRedeem(uint256 amount, address poolManager) external {\n        _burn(msg.sender, amount);\n        IStableMaster(stableMaster).updateStocksUsers(amount, poolManager);\n    }\n\n    /// @notice Burns `amount` of agToken on behalf of another account without redeeming collateral back\n    /// @param account Account to burn on behalf of\n    /// @param amount Amount to burn\n    /// @param poolManager Reference to the `PoolManager` contract for which the `stocksUsers` will need to be updated\n    function burnFromNoRedeem(\n        address account,\n        uint256 amount,\n        address poolManager\n    ) external {\n        _burnFromNoRedeem(amount, account, msg.sender);\n        IStableMaster(stableMaster).updateStocksUsers(amount, poolManager);\n    }\n\n    /// @notice Allows anyone to burn agToken without redeeming collateral back\n    /// @param amount Amount of stablecoins to burn\n    /// @dev This function can typically be called if there is a settlement mechanism to burn stablecoins\n    function burnStablecoin(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    // ======================= Minter Role Only Functions ==========================\n\n    /// @inheritdoc IAgToken\n    function burnSelf(uint256 amount, address burner) external onlyMinter {\n        _burn(burner, amount);\n    }\n\n    /// @inheritdoc IAgToken\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external onlyMinter {\n        _burnFromNoRedeem(amount, burner, sender);\n    }\n\n    /// @inheritdoc IAgToken\n    function mint(address account, uint256 amount) external onlyMinter {\n        _mint(account, amount);\n    }\n\n    // ======================= Treasury Only Functions =============================\n\n    /// @inheritdoc IAgToken\n    function addMinter(address minter) external onlyTreasury {\n        isMinter[minter] = true;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function removeMinter(address minter) external {\n        // The `treasury` contract cannot remove the `stableMaster`\n        if (msg.sender != minter && (msg.sender != address(treasury) || minter == stableMaster)) revert InvalidSender();\n        isMinter[minter] = false;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function setTreasury(address _treasury) external onlyTreasury {\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // ============================ Internal Function ==============================\n\n    /// @notice Internal version of the function `burnFromNoRedeem`\n    /// @param amount Amount to burn\n    /// @dev It is at the level of this function that allowance checks are performed\n    function _burnFromNoRedeem(\n        uint256 amount,\n        address burner,\n        address sender\n    ) internal {\n        if (burner != sender) {\n            uint256 currentAllowance = allowance(burner, sender);\n            if (currentAllowance < amount) revert BurnAmountExceedsAllowance();\n            _approve(burner, sender, currentAllowance - amount);\n        }\n        _burn(burner, amount);\n    }\n}\n"
    },
    "contracts/interfaces/IAgToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @title IAgToken\n/// @author Angle Core Team\n/// @notice Interface for the stablecoins `AgToken` contracts\n/// @dev This interface only contains functions of the `AgToken` contract which are called by other contracts\n/// of this module or of the first module of the Angle Protocol\ninterface IAgToken is IERC20Upgradeable {\n    // ======================= Minter Role Only Functions ===========================\n\n    /// @notice Lets the `StableMaster` contract or another whitelisted contract mint agTokens\n    /// @param account Address to mint to\n    /// @param amount Amount to mint\n    /// @dev The contracts allowed to issue agTokens are the `StableMaster` contract, `VaultManager` contracts\n    /// associated to this stablecoin as well as the flash loan module (if activated) and potentially contracts\n    /// whitelisted by governance\n    function mint(address account, uint256 amount) external;\n\n    /// @notice Burns `amount` tokens from a `burner` address after being asked to by `sender`\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @param sender Address which requested the burn from `burner`\n    /// @dev This method is to be called by a contract with the minter right after being requested\n    /// to do so by a `sender` address willing to burn tokens from another `burner` address\n    /// @dev The method checks the allowance between the `sender` and the `burner`\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external;\n\n    /// @notice Burns `amount` tokens from a `burner` address\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @dev This method is to be called by a contract with a minter right on the AgToken after being\n    /// requested to do so by an address willing to burn tokens from its address\n    function burnSelf(uint256 amount, address burner) external;\n\n    // ========================= Treasury Only Functions ===========================\n\n    /// @notice Adds a minter in the contract\n    /// @param minter Minter address to add\n    /// @dev Zero address checks are performed directly in the `Treasury` contract\n    function addMinter(address minter) external;\n\n    /// @notice Removes a minter from the contract\n    /// @param minter Minter address to remove\n    /// @dev This function can also be called by a minter wishing to revoke itself\n    function removeMinter(address minter) external;\n\n    /// @notice Sets a new treasury contract\n    /// @param _treasury New treasury address\n    function setTreasury(address _treasury) external;\n\n    // ========================= External functions ================================\n\n    /// @notice Checks whether an address has the right to mint agTokens\n    /// @param minter Address for which the minting right should be checked\n    /// @return Whether the address has the right to mint agTokens or not\n    function isMinter(address minter) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/coreModule/IStableMaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title IStableMaster\n/// @author Angle Core Team\n/// @notice Previous interface with additionnal getters for public variables and mappings\ninterface IStableMaster {\n    function agToken() external returns (address);\n\n    function updateStocksUsers(uint256 amount, address poolManager) external;\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./IAgToken.sol\";\nimport \"./ICoreBorrow.sol\";\nimport \"./IFlashAngle.sol\";\n\n/// @title ITreasury\n/// @author Angle Core Team\n/// @notice Interface for the `Treasury` contract\n/// @dev This interface only contains functions of the `Treasury` which are called by other contracts\n/// of this module\ninterface ITreasury {\n    /// @notice Stablecoin handled by this `treasury` contract\n    function stablecoin() external view returns (IAgToken);\n\n    /// @notice Checks whether a given address has the  governor role\n    /// @param admin Address to check\n    /// @return Whether the address has the governor role\n    /// @dev Access control is only kept in the `CoreBorrow` contract\n    function isGovernor(address admin) external view returns (bool);\n\n    /// @notice Checks whether a given address has the guardian or the governor role\n    /// @param admin Address to check\n    /// @return Whether the address has the guardian or the governor role\n    /// @dev Access control is only kept in the `CoreBorrow` contract which means that this function\n    /// queries the `CoreBorrow` contract\n    function isGovernorOrGuardian(address admin) external view returns (bool);\n\n    /// @notice Checks whether a given address has well been initialized in this contract\n    /// as a `VaultManager``\n    /// @param _vaultManager Address to check\n    /// @return Whether the address has been initialized or not\n    function isVaultManager(address _vaultManager) external view returns (bool);\n\n    /// @notice Sets a new flash loan module for this stablecoin\n    /// @param _flashLoanModule Reference to the new flash loan module\n    /// @dev This function removes the minting right to the old flash loan module and grants\n    /// it to the new module\n    function setFlashLoanModule(address _flashLoanModule) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal onlyInitializing {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/ICoreBorrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title ICoreBorrow\n/// @author Angle Core Team\n/// @notice Interface for the `CoreBorrow` contract\n/// @dev This interface only contains functions of the `CoreBorrow` contract which are called by other contracts\n/// of this module\ninterface ICoreBorrow {\n    /// @notice Checks if an address corresponds to a treasury of a stablecoin with a flash loan\n    /// module initialized on it\n    /// @param treasury Address to check\n    /// @return Whether the address has the `FLASHLOANER_TREASURY_ROLE` or not\n    function isFlashLoanerTreasury(address treasury) external view returns (bool);\n\n    /// @notice Checks whether an address is governor of the Angle Protocol or not\n    /// @param admin Address to check\n    /// @return Whether the address has the `GOVERNOR_ROLE` or not\n    function isGovernor(address admin) external view returns (bool);\n\n    /// @notice Checks whether an address is governor or a guardian of the Angle Protocol or not\n    /// @param admin Address to check\n    /// @return Whether the address has the `GUARDIAN_ROLE` or not\n    /// @dev Governance should make sure when adding a governor to also give this governor the guardian\n    /// role by calling the `addGovernor` function\n    function isGovernorOrGuardian(address admin) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IFlashAngle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./IAgToken.sol\";\nimport \"./ICoreBorrow.sol\";\n\n/// @title IFlashAngle\n/// @author Angle Core Team\n/// @notice Interface for the `FlashAngle` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module\ninterface IFlashAngle {\n    /// @notice Reference to the `CoreBorrow` contract managing the FlashLoan module\n    function core() external view returns (ICoreBorrow);\n\n    /// @notice Sends the fees taken from flash loans to the treasury contract associated to the stablecoin\n    /// @param stablecoin Stablecoin from which profits should be sent\n    /// @return balance Amount of profits sent\n    /// @dev This function can only be called by the treasury contract\n    function accrueInterestToTreasury(IAgToken stablecoin) external returns (uint256 balance);\n\n    /// @notice Adds support for a stablecoin\n    /// @param _treasury Treasury associated to the stablecoin to add support for\n    /// @dev This function can only be called by the `CoreBorrow` contract\n    function addStablecoinSupport(address _treasury) external;\n\n    /// @notice Removes support for a stablecoin\n    /// @param _treasury Treasury associated to the stablecoin to remove support for\n    /// @dev This function can only be called by the `CoreBorrow` contract\n    function removeStablecoinSupport(address _treasury) external;\n\n    /// @notice Sets a new core contract\n    /// @param _core Core contract address to set\n    /// @dev This function can only be called by the `CoreBorrow` contract\n    function setCore(address _core) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/agToken/BaseAgTokenSideChain.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\n/// @title BaseAgTokenSideChain\n/// @author Angle Core Team\n/// @notice Base Contract for Angle agTokens on other chains than Ethereum mainnet\n/// @dev This type of contract can be used to create and handle the stablecoins of Angle protocol in different chains than Ethereum\ncontract BaseAgTokenSideChain is IAgToken, ERC20PermitUpgradeable {\n    // ======================= Parameters and Variables ============================\n\n    /// @inheritdoc IAgToken\n    mapping(address => bool) public isMinter;\n    /// @notice Reference to the treasury contract which can grant minting rights\n    address public treasury;\n\n    // ================================== Events ===================================\n\n    event TreasuryUpdated(address indexed _treasury);\n    event MinterToggled(address indexed minter);\n\n    // =============================== Errors ================================\n\n    error BurnAmountExceedsAllowance();\n    error InvalidSender();\n    error InvalidTreasury();\n    error NotMinter();\n    error NotTreasury();\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializes the contract\n    /// @param name_ Name of the token\n    /// @param symbol_ Symbol of the token\n    /// @param _treasury Reference to the `Treasury` contract associated to this agToken implementation\n    /// @dev By default, agTokens are ERC-20 tokens with 18 decimals\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        address _treasury\n    ) internal initializer {\n        __ERC20Permit_init(name_);\n        __ERC20_init(name_, symbol_);\n        if (address(ITreasury(_treasury).stablecoin()) != address(this)) revert InvalidTreasury();\n        treasury = _treasury;\n        emit TreasuryUpdated(address(_treasury));\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // =============================== Modifiers ===================================\n\n    /// @notice Checks to see if it is the `Treasury` calling this contract\n    /// @dev There is no Access Control here, because it can be handled cheaply through this modifier\n    modifier onlyTreasury() {\n        if (msg.sender != address(treasury)) revert NotTreasury();\n        _;\n    }\n\n    /// @notice Checks whether the sender has the minting right\n    modifier onlyMinter() {\n        if (!isMinter[msg.sender]) revert NotMinter();\n        _;\n    }\n\n    // =========================== External Function ===============================\n\n    /// @notice Allows anyone to burn agToken without redeeming collateral back\n    /// @param amount Amount of stablecoins to burn\n    /// @dev This function can typically be called if there is a settlement mechanism to burn stablecoins\n    function burnStablecoin(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    // ======================= Minter Role Only Functions ==========================\n\n    /// @inheritdoc IAgToken\n    function burnSelf(uint256 amount, address burner) external onlyMinter {\n        _burn(burner, amount);\n    }\n\n    /// @inheritdoc IAgToken\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external onlyMinter {\n        _burnFromNoRedeem(amount, burner, sender);\n    }\n\n    /// @inheritdoc IAgToken\n    function mint(address account, uint256 amount) external onlyMinter {\n        _mint(account, amount);\n    }\n\n    // ======================= Treasury Only Functions =============================\n\n    /// @inheritdoc IAgToken\n    function addMinter(address minter) external onlyTreasury {\n        isMinter[minter] = true;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function removeMinter(address minter) external {\n        if (msg.sender != address(treasury) && msg.sender != minter) revert InvalidSender();\n        isMinter[minter] = false;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function setTreasury(address _treasury) external onlyTreasury {\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // ============================ Internal Function ==============================\n\n    /// @notice Internal version of the function `burnFromNoRedeem`\n    /// @param amount Amount to burn\n    /// @dev It is at the level of this function that allowance checks are performed\n    function _burnFromNoRedeem(\n        uint256 amount,\n        address burner,\n        address sender\n    ) internal {\n        if (burner != sender) {\n            uint256 currentAllowance = allowance(burner, sender);\n            if (currentAllowance < amount) revert BurnAmountExceedsAllowance();\n            _approve(burner, sender, currentAllowance - amount);\n        }\n        _burn(burner, amount);\n    }\n}\n"
    },
    "contracts/mock/MockSidechainAgEUR.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../agToken/BaseAgTokenSideChain.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title AgTokenSideChainMultiBridge\n/// @author Angle Core Team\n/// @notice Contract for Angle agTokens on other chains than Ethereum mainnet\n/// @dev This contract supports bridge tokens having a minting right on the stablecoin (also referred to as the canonical\n/// or the native token)\n/// @dev References:\n///      - FRAX implementation: https://polygonscan.com/address/0x45c32fA6DF82ead1e2EF74d17b76547EDdFaFF89#code\n///      - QiDAO implementation: https://snowtrace.io/address/0x5c49b268c9841AFF1Cc3B0a418ff5c3442eE3F3b#code\ncontract MockSidechainAgEUR is BaseAgTokenSideChain {\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for fee computation\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    // =============================== Bridging Data ===============================\n\n    /// @notice Struct with some data about a specific bridge token\n    struct BridgeDetails {\n        // Limit on the balance of bridge token held by the contract: it is designed\n        // to reduce the exposure of the system to hacks\n        uint256 limit;\n        // Limit on the hourly volume of token minted through this bridge\n        // Technically the limit over a rolling hour is hourlyLimit x2 as hourly limit\n        // is enforced only between x:00 and x+1:00\n        uint256 hourlyLimit;\n        // Fee taken for swapping in and out the token\n        uint64 fee;\n        // Whether the associated token is allowed or not\n        bool allowed;\n        // Whether swapping in and out from the associated token is paused or not\n        bool paused;\n    }\n\n    /// @notice Maps a bridge token to data\n    mapping(address => BridgeDetails) public bridges;\n    /// @notice List of all bridge tokens\n    address[] public bridgeTokensList;\n    /// @notice Maps a bridge token to the associated hourly volume\n    mapping(address => mapping(uint256 => uint256)) public usage;\n    /// @notice Maps an address to whether it is exempt of fees for when it comes to swapping in and out\n    mapping(address => uint256) public isFeeExempt;\n\n    // ================================== Events ===================================\n\n    event BridgeTokenAdded(address indexed bridgeToken, uint256 limit, uint256 hourlyLimit, uint64 fee, bool paused);\n    event BridgeTokenToggled(address indexed bridgeToken, bool toggleStatus);\n    event BridgeTokenRemoved(address indexed bridgeToken);\n    event BridgeTokenFeeUpdated(address indexed bridgeToken, uint64 fee);\n    event BridgeTokenLimitUpdated(address indexed bridgeToken, uint256 limit);\n    event BridgeTokenHourlyLimitUpdated(address indexed bridgeToken, uint256 hourlyLimit);\n    event HourlyLimitUpdated(uint256 hourlyLimit);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event FeeToggled(address indexed theAddress, uint256 toggleStatus);\n\n    // =============================== Errors ================================\n\n    error AssetStillControlledInReserves();\n    error HourlyLimitExceeded();\n    error InvalidToken();\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error TooBigAmount();\n    error TooHighParameterValue();\n    error ZeroAddress();\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializes the `AgToken` contract\n    /// @param name_ Name of the token\n    /// @param symbol_ Symbol of the token\n    /// @param _treasury Reference to the `Treasury` contract associated to this agToken\n    /// @dev By default, agTokens are ERC-20 tokens with 18 decimals\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address _treasury\n    ) external {\n        _initialize(name_, symbol_, _treasury);\n    }\n\n    // =============================== Modifiers ===================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!ITreasury(treasury).isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!ITreasury(treasury).isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    // ==================== External Permissionless Functions ======================\n\n    /// @notice Returns the list of all supported bridge tokens\n    /// @dev Helpful for UIs\n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridgeTokensList;\n    }\n\n    /// @notice Returns the current volume for a bridge, for the current hour\n    /// @param bridgeToken Bridge used to mint\n    /// @dev Helpful for UIs\n    function currentUsage(address bridgeToken) external view returns (uint256) {\n        return usage[bridgeToken][block.timestamp / 3600];\n    }\n\n    /// @notice Mints the canonical token from a supported bridge token\n    /// @param bridgeToken Bridge token to use to mint\n    /// @param amount Amount of bridge tokens to send\n    /// @param to Address to which the stablecoin should be sent\n    /// @return Amount of the canonical stablecoin actually minted\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapIn(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n        uint256 balance = IERC20(bridgeToken).balanceOf(address(this));\n        if (balance + amount > bridgeDetails.limit) {\n            // In case someone maliciously sends tokens to this contract\n            // Or the limit changes\n            if (bridgeDetails.limit > balance) amount = bridgeDetails.limit - balance;\n            else {\n                amount = 0;\n            }\n        }\n\n        // Checking requirement on the hourly volume\n        uint256 hour = block.timestamp / 3600;\n        uint256 hourlyUsage = usage[bridgeToken][hour] + amount;\n        if (hourlyUsage > bridgeDetails.hourlyLimit) {\n            // Edge case when the hourly limit changes\n            if (bridgeDetails.hourlyLimit > usage[bridgeToken][hour])\n                amount = bridgeDetails.hourlyLimit - usage[bridgeToken][hour];\n            else {\n                amount = 0;\n            }\n        }\n        usage[bridgeToken][hour] = usage[bridgeToken][hour] + amount;\n\n        IERC20(bridgeToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 canonicalOut = amount;\n        // Computing fees\n        if (isFeeExempt[msg.sender] == 0) {\n            canonicalOut -= (canonicalOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        _mint(to, canonicalOut);\n        return canonicalOut;\n    }\n\n    /// @notice Burns the canonical token in exchange for a bridge token\n    /// @param bridgeToken Bridge token required\n    /// @param amount Amount of canonical tokens to burn\n    /// @param to Address to which the bridge token should be sent\n    /// @return Amount of bridge tokens actually sent back\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapOut(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n\n        _burn(msg.sender, amount);\n        uint256 bridgeOut = amount;\n        if (isFeeExempt[msg.sender] == 0) {\n            bridgeOut -= (bridgeOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        IERC20(bridgeToken).safeTransfer(to, bridgeOut);\n        return bridgeOut;\n    }\n\n    // ======================= Governance Functions ================================\n\n    /// @notice Adds support for a bridge token\n    /// @param bridgeToken Bridge token to add: it should be a version of the stablecoin from another bridge\n    /// @param limit Limit on the balance of bridge token this contract could hold\n    /// @param hourlyLimit Limit on the hourly volume for this bridge\n    /// @param paused Whether swapping for this token should be paused or not\n    /// @param fee Fee taken upon swapping for or against this token\n    function addBridgeToken(\n        address bridgeToken,\n        uint256 limit,\n        uint256 hourlyLimit,\n        uint64 fee,\n        bool paused\n    ) external onlyGovernor {\n        if (bridges[bridgeToken].allowed || bridgeToken == address(0)) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        BridgeDetails memory _bridge;\n        _bridge.limit = limit;\n        _bridge.hourlyLimit = hourlyLimit;\n        _bridge.paused = paused;\n        _bridge.fee = fee;\n        _bridge.allowed = true;\n        bridges[bridgeToken] = _bridge;\n        bridgeTokensList.push(bridgeToken);\n        emit BridgeTokenAdded(bridgeToken, limit, hourlyLimit, fee, paused);\n    }\n\n    /// @notice Removes support for a token\n    /// @param bridgeToken Address of the bridge token to remove support for\n    function removeBridgeToken(address bridgeToken) external onlyGovernor {\n        if (IERC20(bridgeToken).balanceOf(address(this)) != 0) revert AssetStillControlledInReserves();\n        delete bridges[bridgeToken];\n        // Deletion from `bridgeTokensList` loop\n        uint256 bridgeTokensListLength = bridgeTokensList.length;\n        for (uint256 i = 0; i < bridgeTokensListLength - 1; i++) {\n            if (bridgeTokensList[i] == bridgeToken) {\n                // Replace the `bridgeToken` to remove with the last of the list\n                bridgeTokensList[i] = bridgeTokensList[bridgeTokensListLength - 1];\n                break;\n            }\n        }\n        // Remove last element in array\n        bridgeTokensList.pop();\n        emit BridgeTokenRemoved(bridgeToken);\n    }\n\n    /// @notice Recovers any ERC20 token\n    /// @dev Can be used to withdraw bridge tokens for them to be de-bridged on mainnet\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyGovernor {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Updates the `limit` amount for `bridgeToken`\n    function setLimit(address bridgeToken, uint256 limit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].limit = limit;\n        emit BridgeTokenLimitUpdated(bridgeToken, limit);\n    }\n\n    /// @notice Updates the `hourlyLimit` amount for `bridgeToken`\n    function setHourlyLimit(address bridgeToken, uint256 hourlyLimit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].hourlyLimit = hourlyLimit;\n        emit BridgeTokenHourlyLimitUpdated(bridgeToken, hourlyLimit);\n    }\n\n    /// @notice Updates the `fee` value for `bridgeToken`\n    function setSwapFee(address bridgeToken, uint64 fee) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        bridges[bridgeToken].fee = fee;\n        emit BridgeTokenFeeUpdated(bridgeToken, fee);\n    }\n\n    /// @notice Pauses or unpauses swapping in and out for a token\n    function toggleBridge(address bridgeToken) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bool pausedStatus = bridges[bridgeToken].paused;\n        bridges[bridgeToken].paused = !pausedStatus;\n        emit BridgeTokenToggled(bridgeToken, !pausedStatus);\n    }\n\n    /// @notice Toggles fees for the address `theAddress`\n    function toggleFeesForAddress(address theAddress) external onlyGovernorOrGuardian {\n        uint256 feeExemptStatus = 1 - isFeeExempt[theAddress];\n        isFeeExempt[theAddress] = feeExemptStatus;\n        emit FeeToggled(theAddress, feeExemptStatus);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/vaultManager/VaultManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/ISwapper.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IVaultManager.sol\";\nimport \"../interfaces/governance/IVeBoostProxy.sol\";\n\n/// @title VaultManagerStorage\n/// @author Angle Core Team\n/// @dev Variables, references, parameters and events needed in the `VaultManager` contract\n// solhint-disable-next-line max-states-count\ncontract VaultManagerStorage is IVaultManagerStorage, Initializable, ReentrancyGuardUpgradeable {\n    /// @notice Base used for parameter computation: almost all the parameters of this contract are set in `BASE_PARAMS`\n    uint256 public constant BASE_PARAMS = 10**9;\n    /// @notice Base used for interest rate computation\n    uint256 public constant BASE_INTEREST = 10**27;\n    /// @notice Used for interest rate computation\n    uint256 public constant HALF_BASE_INTEREST = 10**27 / 2;\n\n    // =============================== References ==================================\n\n    /// @inheritdoc IVaultManagerStorage\n    ITreasury public treasury;\n    /// @inheritdoc IVaultManagerStorage\n    IERC20 public collateral;\n    /// @inheritdoc IVaultManagerStorage\n    IAgToken public stablecoin;\n    /// @inheritdoc IVaultManagerStorage\n    IOracle public oracle;\n    /// @notice Reference to the contract which computes adjusted veANGLE balances for liquidators boosts\n    IVeBoostProxy public veBoostProxy;\n    /// @notice Base of the collateral\n    uint256 internal _collatBase;\n\n    // =============================== Parameters ==================================\n    // Unless specified otherwise, parameters of this contract are expressed in `BASE_PARAMS`\n\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public immutable dust;\n    /// @notice Minimum amount of collateral (in stablecoin value, e.g in `BASE_TOKENS = 10**18`) that can be left\n    ///  in a vault during a liquidation where the health factor function is decreasing\n    uint256 internal immutable _dustCollateral;\n    /// @notice Maximum amount of stablecoins that can be issued with this contract (in `BASE_TOKENS`). This parameter should\n    /// not be bigger than `type(uint256).max / BASE_INTEREST` otherwise there may be some overflows in the `increaseDebt` function\n    uint256 public debtCeiling;\n    /// @notice Threshold veANGLE balance values for the computation of the boost for liquidators: the length of this array\n    /// should normally be 2. The base of the x-values in this array should be `BASE_TOKENS`\n    uint256[] public xLiquidationBoost;\n    /// @notice Values of the liquidation boost at the threshold values of x\n    uint256[] public yLiquidationBoost;\n    /// @inheritdoc IVaultManagerStorage\n    uint64 public collateralFactor;\n    /// @notice Maximum Health factor at which a vault can end up after a liquidation (unless it's fully liquidated)\n    uint64 public targetHealthFactor;\n    /// @notice Upfront fee taken when borrowing stablecoins: this fee is optional and should in practice not be used\n    uint64 public borrowFee;\n    /// @notice Upfront fee taken when repaying stablecoins: this fee is optional as well. It should be smaller\n    /// than the liquidation surcharge (cf below) to avoid exploits where people voluntarily get liquidated at a 0\n    /// discount to pay smaller repaying fees\n    uint64 public repayFee;\n    /// @notice Per second interest taken to borrowers taking agToken loans. Contrarily to other parameters, it is set in `BASE_INTEREST`\n    /// that is to say in base 10**27\n    uint64 public interestRate;\n    /// @notice Fee taken by the protocol during a liquidation. Technically, this value is not the fee per se, it's 1 - fee.\n    /// For instance for a 2% fee, `liquidationSurcharge` should be 98%\n    uint64 public liquidationSurcharge;\n    /// @notice Maximum discount given to liquidators\n    uint64 public maxLiquidationDiscount;\n    /// @notice Whether whitelisting is required to own a vault or not\n    bool public whitelistingActivated;\n    /// @notice Whether the contract is paused or not\n    bool public paused;\n\n    // =============================== Variables ===================================\n\n    /// @notice Timestamp at which the `interestAccumulator` was updated\n    uint256 public lastInterestAccumulatorUpdated;\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public interestAccumulator;\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public totalNormalizedDebt;\n    /// @notice Surplus accumulated by the contract: surplus is always in stablecoins, and is then reset\n    /// when the value is communicated to the treasury contract\n    uint256 public surplus;\n    /// @notice Bad debt made from liquidated vaults which ended up having no collateral and a positive amount\n    /// of stablecoins\n    uint256 public badDebt;\n\n    // ================================ Mappings ===================================\n\n    /// @inheritdoc IVaultManagerStorage\n    mapping(uint256 => Vault) public vaultData;\n    /// @notice Maps an address to 1 if it's whitelisted and can open or own a vault\n    mapping(address => uint256) public isWhitelisted;\n\n    // ================================ ERC721 Data ================================\n\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public vaultIDCount;\n\n    /// @notice URI\n    string internal _baseURI;\n\n    // Mapping from `vaultID` to owner address\n    mapping(uint256 => address) internal _owners;\n\n    // Mapping from owner address to vault owned count\n    mapping(address => uint256) internal _balances;\n\n    // Mapping from `vaultID` to approved address\n    mapping(uint256 => address) internal _vaultApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => uint256)) internal _operatorApprovals;\n\n    uint256[50] private __gap;\n\n    // =============================== Events ======================================\n\n    event AccruedToTreasury(uint256 surplusEndValue, uint256 badDebtEndValue);\n    event CollateralAmountUpdated(uint256 vaultID, uint256 collateralAmount, uint8 isIncrease);\n    event InterestAccumulatorUpdated(uint256 value, uint256 timestamp);\n    event InternalDebtUpdated(uint256 vaultID, uint256 internalAmount, uint8 isIncrease);\n    event FiledUint64(uint64 param, bytes32 what);\n    event DebtCeilingUpdated(uint256 debtCeiling);\n    event LiquidationBoostParametersUpdated(address indexed _veBoostProxy, uint256[] xBoost, uint256[] yBoost);\n    event LiquidatedVaults(uint256[] vaultIDs);\n    event DebtTransferred(uint256 srcVaultID, uint256 dstVaultID, address dstVaultManager, uint256 amount);\n\n    // =============================== Errors ======================================\n\n    error ApprovalToOwner();\n    error ApprovalToCaller();\n    error DustyLeftoverAmount();\n    error DebtCeilingExceeded();\n    error HealthyVault();\n    error IncompatibleLengths();\n    error InsolventVault();\n    error InvalidParameterValue();\n    error InvalidParameterType();\n    error InvalidSetOfParameters();\n    error InvalidTreasury();\n    error NonERC721Receiver();\n    error NonexistentVault();\n    error NotApproved();\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error NotTreasury();\n    error NotWhitelisted();\n    error NotVaultManager();\n    error Paused();\n    error TooHighParameterValue();\n    error TooSmallParameterValue();\n    error ZeroAddress();\n\n    /// @param _dust Minimum amount of debt a vault from this implementation can have\n    /// @param dustCollateral_ Minimum amount of collateral (in stablecoin value) that can be left in a vault during a liquidation\n    /// where the health factor function is decreasing\n    /// @dev Run only at the implementation level\n    constructor(uint256 _dust, uint256 dustCollateral_) initializer {\n        dust = _dust;\n        _dustCollateral = dustCollateral_;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./ITreasury.sol\";\n\n/// @title IOracle\n/// @author Angle Core Team\n/// @notice Interface for the `Oracle` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module\ninterface IOracle {\n    /// @notice Reads the rate from the Chainlink circuit and other data provided\n    /// @return quoteAmount The current rate between the in-currency and out-currency in the base\n    /// of the out currency\n    /// @dev For instance if the out currency is EUR (and hence agEUR), then the base of the returned\n    /// value is 10**18\n    function read() external view returns (uint256);\n\n    /// @notice Changes the treasury contract\n    /// @param _treasury Address of the new treasury contract\n    /// @dev This function can be called by an approved `VaultManager` contract which can call\n    /// this function after being requested to do so by a `treasury` contract\n    /// @dev In some situations (like reactor contracts), the `VaultManager` may not directly be linked\n    /// to the `oracle` contract and as such we may need governors to be able to call this function as well\n    function setTreasury(address _treasury) external;\n\n    /// @notice Reference to the `treasury` contract handling this `VaultManager`\n    function treasury() external view returns (ITreasury treasury);\n}\n"
    },
    "contracts/interfaces/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title ISwapper\n/// @author Angle Core Team\n/// @notice Interface for Swapper contracts\n/// @dev This interface defines the key functions `Swapper` contracts should have when interacting with\n/// Angle\ninterface ISwapper {\n    /// @notice Notifies a contract that an address should be given `outToken` from `inToken`\n    /// @param inToken Address of the token received\n    /// @param outToken Address of the token to obtain\n    /// @param outTokenRecipient Address to which the outToken should be sent\n    /// @param outTokenOwed Minimum amount of outToken the `outTokenRecipient` address should have at the end of the call\n    /// @param inTokenObtained Amount of collateral obtained by a related address prior\n    /// to the call to this function\n    /// @param data Extra data needed (to encode Uniswap swaps for instance)\n    function swap(\n        IERC20 inToken,\n        IERC20 outToken,\n        address outTokenRecipient,\n        uint256 outTokenOwed,\n        uint256 inTokenObtained,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/IVaultManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ITreasury.sol\";\nimport \"./IOracle.sol\";\n\n// ========================= Key Structs and Enums =============================\n\n/// @notice Parameters associated to a given `VaultManager` contract: these all correspond\n/// to parameters which signification is detailed in the `VaultManagerStorage` file\nstruct VaultParameters {\n    uint256 debtCeiling;\n    uint64 collateralFactor;\n    uint64 targetHealthFactor;\n    uint64 interestRate;\n    uint64 liquidationSurcharge;\n    uint64 maxLiquidationDiscount;\n    bool whitelistingActivated;\n    uint256 baseBoost;\n}\n\n/// @notice Data stored to track someone's loan (or equivalently called position)\nstruct Vault {\n    // Amount of collateral deposited in the vault, in collateral decimals. For example, if the collateral\n    // is USDC with 6 decimals, then `collateralAmount` will be in base 10**6\n    uint256 collateralAmount;\n    // Normalized value of the debt (that is to say of the stablecoins borrowed). It is expressed\n    // in the base of Angle stablecoins (i.e. `BASE_TOKENS = 10**18`)\n    uint256 normalizedDebt;\n}\n\n/// @notice For a given `vaultID`, this encodes a liquidation opportunity that is to say details about the maximum\n/// amount that could be repaid by liquidating the position\n/// @dev All the values are null in the case of a vault which cannot be liquidated under these conditions\nstruct LiquidationOpportunity {\n    // Maximum stablecoin amount that can be repaid upon liquidating the vault\n    uint256 maxStablecoinAmountToRepay;\n    // Collateral amount given to the person in the case where the maximum amount to repay is given\n    uint256 maxCollateralAmountGiven;\n    // Threshold value of stablecoin amount to repay: it is ok for a liquidator to repay below threshold,\n    // but if this threshold is non null and the liquidator wants to repay more than threshold, it should repay\n    // the max stablecoin amount given in this vault\n    uint256 thresholdRepayAmount;\n    // Discount proposed to the liquidator on the collateral\n    uint256 discount;\n    // Amount of debt in the vault\n    uint256 currentDebt;\n}\n\n/// @notice Data stored during a liquidation process to keep in memory what's due to a liquidator and some\n/// essential data for vaults being liquidated\nstruct LiquidatorData {\n    // Current amount of stablecoins the liquidator should give to the contract\n    uint256 stablecoinAmountToReceive;\n    // Current amount of collateral the contract should give to the liquidator\n    uint256 collateralAmountToGive;\n    // Bad debt accrued across the liquidation process\n    uint256 badDebtFromLiquidation;\n    // Oracle value (in stablecoin base) at the time of the liquidation\n    uint256 oracleValue;\n    // Value of the `interestAccumulator` at the time of the call\n    uint256 newInterestAccumulator;\n}\n\n/// @notice Data to track during a series of action the amount to give or receive in stablecoins and collateral\n/// to the caller or associated addresses\nstruct PaymentData {\n    // Stablecoin amount the contract should give\n    uint256 stablecoinAmountToGive;\n    // Stablecoin amount owed to the contract\n    uint256 stablecoinAmountToReceive;\n    // Collateral amount the contract should give\n    uint256 collateralAmountToGive;\n    // Collateral amount owed to the contract\n    uint256 collateralAmountToReceive;\n}\n\n/// @notice Actions possible when composing calls to the different entry functions proposed\nenum ActionType {\n    createVault,\n    closeVault,\n    addCollateral,\n    removeCollateral,\n    repayDebt,\n    borrow,\n    getDebtIn,\n    permit\n}\n\n// ========================= Interfaces =============================\n\n/// @title IVaultManagerFunctions\n/// @author Angle Core Team\n/// @notice Interface for the `VaultManager` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module (without getters)\ninterface IVaultManagerFunctions {\n    /// @notice Accrues interest accumulated across all vaults to the surplus and sends the surplus to the treasury\n    /// @return surplusValue Value of the surplus communicated to the `Treasury`\n    /// @return badDebtValue Value of the bad debt communicated to the `Treasury`\n    /// @dev `surplus` and `badDebt` should be reset to 0 once their current value have been given to the `treasury` contract\n    function accrueInterestToTreasury() external returns (uint256 surplusValue, uint256 badDebtValue);\n\n    /// @notice Removes debt from a vault after being requested to do so by another `VaultManager` contract\n    /// @param vaultID ID of the vault to remove debt from\n    /// @param amountStablecoins Amount of stablecoins to remove from the debt: this amount is to be converted to an\n    /// internal debt amount\n    /// @param senderBorrowFee Borrowing fees from the contract which requested this: this is to make sure that people are not\n    /// arbitraging difference in minting fees\n    /// @param senderRepayFee Repay fees from the contract which requested this: this is to make sure that people are not arbitraging\n    /// differences in repay fees\n    /// @dev This function can only be called from a vaultManager registered in the same Treasury\n    function getDebtOut(\n        uint256 vaultID,\n        uint256 amountStablecoins,\n        uint256 senderBorrowFee,\n        uint256 senderRepayFee\n    ) external;\n\n    /// @notice Gets the current debt of a vault\n    /// @param vaultID ID of the vault to check\n    /// @return Debt of the vault\n    function getVaultDebt(uint256 vaultID) external view returns (uint256);\n\n    /// @notice Gets the total debt across all vaults\n    /// @return Total debt across all vaults, taking into account the interest accumulated\n    /// over time\n    function getTotalDebt() external view returns (uint256);\n\n    /// @notice Sets the treasury contract\n    /// @param _treasury New treasury contract\n    /// @dev All required checks when setting up a treasury contract are performed in the contract\n    /// calling this function\n    function setTreasury(address _treasury) external;\n\n    /// @notice Creates a vault\n    /// @param toVault Address for which the va\n    /// @return vaultID ID of the vault created\n    /// @dev This function just creates the vault without doing any collateral or\n    function createVault(address toVault) external returns (uint256);\n\n    /// @notice Allows composability between calls to the different entry points of this module. Any user calling\n    /// this function can perform any of the allowed actions in the order of their choice\n    /// @param actions Set of actions to perform\n    /// @param datas Data to be decoded for each action: it can include like the `vaultID` or the `stablecoinAmount` to borrow\n    /// @param from Address from which stablecoins will be taken if one action includes burning stablecoins. This address\n    /// should either be the `msg.sender` or be approved by the latter\n    /// @param to Address to which stablecoins and/or collateral will be sent in case of\n    /// @param who Address of the contract to handle in case of repayment of stablecoins from received collateral\n    /// @param repayData Data to pass to the repayment contract in case of\n    /// @return paymentData Struct containing the accounting changes from the protocol's perspective (like how much of collateral\n    /// or how much has been received). Note that the values in the struct are not aggregated and you could have in the output\n    /// a positive amount of stablecoins to receive as well as a positive amount of stablecoins to give\n    /// @dev This function is optimized to reduce gas cost due to payment from or to the user and that expensive calls\n    /// or computations (like `oracleValue`) are done only once\n    /// @dev When specifying `vaultID` in `data`, it is important to know that if you specify `vaultID = 0`, it will simply\n    /// use the latest `vaultID`. This is the default behavior, and unless you're engaging into some complex protocol actions\n    /// it is encouraged to use `vaultID = 0` only when the first action of the batch is `createVault`\n    function angle(\n        ActionType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to,\n        address who,\n        bytes memory repayData\n    ) external returns (PaymentData memory paymentData);\n\n    /// @notice This function is a wrapper built on top of the function above. It enables users to interact with the contract\n    /// without having to provide `who` and `repayData` parameters\n    function angle(\n        ActionType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to\n    ) external returns (PaymentData memory paymentData);\n\n    /// @notice Initializes the `VaultManager` contract\n    /// @param _treasury Treasury address handling the contract\n    /// @param _collateral Collateral supported by this contract\n    /// @param _oracle Oracle contract used\n    /// @param _symbol Symbol used to define the `VaultManager` name and symbol\n    /// @dev The parameters and the oracle are the only elements which could be modified once the\n    /// contract has been initialized\n    /// @dev For the contract to be fully initialized, governance needs to set the parameters for the liquidation\n    /// boost\n    function initialize(\n        ITreasury _treasury,\n        IERC20 _collateral,\n        IOracle _oracle,\n        VaultParameters calldata params,\n        string memory _symbol\n    ) external;\n}\n\n/// @title IVaultManagerStorage\n/// @author Angle Core Team\n/// @notice Interface for the `VaultManager` contract\n/// @dev This interface contains getters of the contract's public variables used by other contracts\n/// of this module\ninterface IVaultManagerStorage {\n    /// @notice Minimum amount of debt a vault can have, expressed in `BASE_TOKENS` that is to say the base of the agTokens\n    function dust() external view returns (uint256);\n\n    /// @notice Encodes the maximum ratio stablecoin/collateral a vault can have before being liquidated. It's what\n    /// determines the minimum collateral ratio of a position\n    function collateralFactor() external view returns (uint64);\n\n    /// @notice Stablecoin handled by this contract. Another `VaultManager` contract could have\n    /// the same rights as this `VaultManager` on the stablecoin contract\n    function stablecoin() external view returns (IAgToken);\n\n    /// @notice Reference to the `treasury` contract handling this `VaultManager`\n    function treasury() external view returns (ITreasury);\n\n    /// @notice Oracle contract to get access to the price of the collateral with respect to the stablecoin\n    function oracle() external view returns (IOracle);\n\n    /// @notice The `interestAccumulator` variable keeps track of the interest that should accrue to the protocol.\n    /// The stored value is not necessarily the true value: this one is recomputed every time an action takes place\n    /// within the protocol. It is in base `BASE_INTEREST`\n    function interestAccumulator() external view returns (uint256);\n\n    /// @notice Reference to the collateral handled by this `VaultManager`\n    function collateral() external view returns (IERC20);\n\n    /// @notice Total normalized amount of stablecoins borrowed, not taking into account the potential bad debt accumulated\n    /// This value is expressed in the base of Angle stablecoins (`BASE_TOKENS = 10**18`)\n    function totalNormalizedDebt() external view returns (uint256);\n\n    /// @notice Maximum amount of stablecoins that can be issued with this contract. It is expressed in `BASE_TOKENS`\n    function debtCeiling() external view returns (uint256);\n\n    /// @notice Maps a `vaultID` to its data (namely collateral amount and normalized debt)\n    function vaultData(uint256 vaultID) external view returns (uint256 collateralAmount, uint256 normalizedDebt);\n\n    /// @notice ID of the last vault created. The `vaultIDCount` variables serves as a counter to generate a unique\n    /// `vaultID` for each vault: it is like `tokenID` in basic ERC721 contracts\n    function vaultIDCount() external view returns (uint256);\n}\n\n/// @title IVaultManager\n/// @author Angle Core Team\n/// @notice Interface for the `VaultManager` contract\ninterface IVaultManager is IVaultManagerFunctions, IVaultManagerStorage, IERC721Metadata {\n\n}\n"
    },
    "contracts/interfaces/governance/IVeBoostProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title IVeBoostProxy\n/// @author Angle Core Team\n/// @notice Interface for the `VeBoostProxy` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module\n/// @dev The `veBoostProxy` contract used by Angle is a full fork of Curve Finance implementation\ninterface IVeBoostProxy {\n    /// @notice Reads the adjusted veANGLE balance of an address (adjusted by delegation)\n    //solhint-disable-next-line\n    function adjusted_balance_of(address) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721Metadata.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/mock/MockVeBoostProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/governance/IVeBoostProxy.sol\";\n\ncontract MockVeBoostProxy is IVeBoostProxy {\n    //solhint-disable-next-line\n    mapping(address => uint256) public adjusted_balance_of;\n\n    constructor() {}\n\n    function setBalance(address concerned, uint256 balance) external {\n        adjusted_balance_of[concerned] = balance;\n    }\n}\n"
    },
    "contracts/treasury/Treasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IVaultManager.sol\";\n\n/// @title Treasury\n/// @author Angle Core Team\n/// @notice Treasury of Angle Borrowing Module doing the accounting across all VaultManagers for\n/// a given stablecoin\ncontract Treasury is ITreasury, Initializable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    // =============================== References ==================================\n\n    /// @notice Reference to the `CoreBorrow` contract of the module which handles all AccessControl logic\n    ICoreBorrow public core;\n    /// @notice Flash Loan Module with a minter right on the stablecoin\n    IFlashAngle public flashLoanModule;\n    /// @inheritdoc ITreasury\n    IAgToken public stablecoin;\n    /// @notice Address responsible for handling the surplus made by the treasury\n    address public surplusManager;\n    /// @notice List of the accepted `VaultManager` of the protocol\n    address[] public vaultManagerList;\n    /// @notice Maps an address to 1 if it was initialized as a `VaultManager` contract\n    mapping(address => uint256) public vaultManagerMap;\n\n    // =============================== Variables ===================================\n\n    /// @notice Amount of bad debt (unbacked stablecoin) accumulated across all `VaultManager` contracts\n    /// linked to this stablecoin\n    uint256 public badDebt;\n    /// @notice Surplus amount accumulated by the contract waiting to be distributed to governance. Technically\n    /// only a share of this `surplusBuffer` will go to governance. Once a share of the surplus buffer has been\n    /// given to governance, then this surplus is reset\n    uint256 public surplusBuffer;\n\n    // =============================== Parameter ===================================\n\n    /// @notice Share of the `surplusBuffer` distributed to governance (in `BASE_PARAMS`)\n    uint64 public surplusForGovernance;\n\n    // =============================== Events ======================================\n\n    event BadDebtUpdated(uint256 badDebtValue);\n    event CoreUpdated(address indexed _core);\n    event NewTreasurySet(address indexed _treasury);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event SurplusBufferUpdated(uint256 surplusBufferValue);\n    event SurplusForGovernanceUpdated(uint64 _surplusForGovernance);\n    event SurplusManagerUpdated(address indexed _surplusManager);\n    event VaultManagerToggled(address indexed vaultManager);\n\n    // =============================== Errors ======================================\n\n    error AlreadyVaultManager();\n    error InvalidAddress();\n    error InvalidTreasury();\n    error NotCore();\n    error NotGovernor();\n    error NotVaultManager();\n    error RightsNotRemoved();\n    error TooBigAmount();\n    error TooHighParameterValue();\n    error ZeroAddress();\n\n    // =============================== Modifier ====================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!core.isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Initializes the treasury contract\n    /// @param _core Address of the `CoreBorrow` contract of the module\n    /// @param _stablecoin Address of the stablecoin\n    function initialize(ICoreBorrow _core, IAgToken _stablecoin) public initializer {\n        if (address(_stablecoin) == address(0) || address(_core) == address(0)) revert ZeroAddress();\n        core = _core;\n        stablecoin = _stablecoin;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ========================= View Functions ====================================\n\n    /// @inheritdoc ITreasury\n    function isGovernor(address admin) external view returns (bool) {\n        return core.isGovernor(admin);\n    }\n\n    /// @inheritdoc ITreasury\n    function isGovernorOrGuardian(address admin) external view returns (bool) {\n        return core.isGovernorOrGuardian(admin);\n    }\n\n    /// @inheritdoc ITreasury\n    function isVaultManager(address _vaultManager) external view returns (bool) {\n        return vaultManagerMap[_vaultManager] == 1;\n    }\n\n    // ============= External Permissionless Functions =============================\n\n    /// @notice Fetches the surplus accrued across all the `VaultManager` contracts controlled by this\n    /// `Treasury` contract as well as from the fees of the `FlashLoan` module\n    /// @return Surplus buffer value at the end of the call\n    /// @return Bad debt value at the end of the call\n    /// @dev This function pools surplus and bad debt across all contracts and then updates the `surplusBuffer`\n    /// (or the `badDebt` if more losses were made than profits)\n    function fetchSurplusFromAll() external returns (uint256, uint256) {\n        return _fetchSurplusFromAll();\n    }\n\n    /// @notice Fetches the surplus accrued in the flash loan module and updates the `surplusBuffer`\n    /// @return Surplus buffer value at the end of the call\n    /// @return Bad debt value at the end of the call\n    /// @dev This function fails if the `flashLoanModule` has not been initialized yet\n    function fetchSurplusFromFlashLoan() external returns (uint256, uint256) {\n        uint256 surplusBufferValue = surplusBuffer + flashLoanModule.accrueInterestToTreasury(stablecoin);\n        return _updateSurplusAndBadDebt(surplusBufferValue, badDebt);\n    }\n\n    /// @notice Pushes the surplus buffer to the `surplusManager` contract\n    /// @return governanceAllocation Amount transferred to governance\n    /// @dev It makes sure to fetch the surplus from all the contracts handled by this treasury to avoid\n    /// the situation where rewards are still distributed to governance even though a `VaultManager` has made\n    /// a big loss\n    /// @dev Typically this function is to be called once every week by a keeper to distribute rewards to veANGLE\n    /// holders\n    /// @dev `stablecoin` must be an AgToken and hence `transfer` reverts if the call is not successful\n    function pushSurplus() external returns (uint256 governanceAllocation) {\n        address _surplusManager = surplusManager;\n        if (_surplusManager == address(0)) {\n            revert ZeroAddress();\n        }\n        (uint256 surplusBufferValue, ) = _fetchSurplusFromAll();\n        surplusBuffer = 0;\n        emit SurplusBufferUpdated(0);\n        governanceAllocation = (surplusForGovernance * surplusBufferValue) / BASE_PARAMS;\n        stablecoin.transfer(_surplusManager, governanceAllocation);\n    }\n\n    /// @notice Updates the bad debt of the protocol in case where the protocol has accumulated some revenue\n    /// from an external source\n    /// @param amount Amount to reduce the bad debt of\n    /// @return badDebtValue Value of the bad debt at the end of the call\n    /// @dev If the protocol has made a loss and managed to make some profits to recover for this loss (through\n    /// a program like Olympus Pro), then this function needs to be called\n    /// @dev `badDebt` is simply reduced here by burning stablecoins\n    /// @dev It is impossible to burn more than the `badDebt` otherwise this function could be used to manipulate\n    /// the `surplusBuffer` and hence the amount going to governance\n    function updateBadDebt(uint256 amount) external returns (uint256 badDebtValue) {\n        stablecoin.burnSelf(amount, address(this));\n        badDebtValue = badDebt - amount;\n        badDebt = badDebtValue;\n        emit BadDebtUpdated(badDebtValue);\n    }\n\n    // ==================== Internal Utility Functions =============================\n\n    /// @notice Internal version of the `fetchSurplusFromAll` function\n    function _fetchSurplusFromAll() internal returns (uint256 surplusBufferValue, uint256 badDebtValue) {\n        (surplusBufferValue, badDebtValue) = _fetchSurplusFromList(vaultManagerList);\n        // It will fail anyway if the `flashLoanModule` is the zero address\n        if (address(flashLoanModule) != address(0))\n            surplusBufferValue += flashLoanModule.accrueInterestToTreasury(stablecoin);\n        (surplusBufferValue, badDebtValue) = _updateSurplusAndBadDebt(surplusBufferValue, badDebtValue);\n    }\n\n    /// @notice Fetches the surplus from a list of `VaultManager` addresses without modifying the\n    /// `surplusBuffer` and `badDebtValue`\n    /// @return surplusBufferValue Value the `surplusBuffer` should have after the call if it was updated\n    /// @return badDebtValue Value the `badDebt` should have after the call if it was updated\n    /// @dev This internal function is never to be called alone, and should always be called in conjunction\n    /// with the `_updateSurplusAndBadDebt` function\n    function _fetchSurplusFromList(address[] memory vaultManagers)\n        internal\n        returns (uint256 surplusBufferValue, uint256 badDebtValue)\n    {\n        badDebtValue = badDebt;\n        surplusBufferValue = surplusBuffer;\n        uint256 newSurplus;\n        uint256 newBadDebt;\n        for (uint256 i = 0; i < vaultManagers.length; i++) {\n            (newSurplus, newBadDebt) = IVaultManager(vaultManagers[i]).accrueInterestToTreasury();\n            surplusBufferValue += newSurplus;\n            badDebtValue += newBadDebt;\n        }\n    }\n\n    /// @notice Updates the `surplusBuffer` and the `badDebt` from updated values after calling the flash loan module\n    /// and/or a list of `VaultManager` contracts\n    /// @param surplusBufferValue Value of the surplus buffer after the calls to the different modules\n    /// @param badDebtValue Value of the bad debt after the calls to the different modules\n    /// @return Value of the `surplusBuffer` corrected from the `badDebt``\n    /// @return Value of the `badDebt` corrected from the `surplusBuffer` and from the surplus the treasury had accumulated\n    /// previously\n    /// @dev When calling this function, it is possible that there is a positive `surplusBufferValue` and `badDebtValue`,\n    /// this function tries to reconcile both values and makes sure that we either have surplus or bad debt but not both\n    /// at the same time\n    function _updateSurplusAndBadDebt(uint256 surplusBufferValue, uint256 badDebtValue)\n        internal\n        returns (uint256, uint256)\n    {\n        if (badDebtValue > 0) {\n            // If we have bad debt we need to burn stablecoins that accrued to the protocol\n            // We still need to make sure that we're not burning too much or as much as we can if the debt is big\n            uint256 balance = stablecoin.balanceOf(address(this));\n            // We are going to burn `min(balance, badDebtValue)`\n            uint256 toBurn = balance <= badDebtValue ? balance : badDebtValue;\n            stablecoin.burnSelf(toBurn, address(this));\n            // If we burned more than `surplusBuffer`, we set surplus to 0. It means we had to tap into Treasury reserve\n            surplusBufferValue = toBurn >= surplusBufferValue ? 0 : surplusBufferValue - toBurn;\n            badDebtValue -= toBurn;\n            // Note here that the stablecoin balance is necessarily greater than the surplus buffer, and so if\n            // `surplusBuffer >= toBurn`, then `badDebtValue = toBurn`\n        }\n        surplusBuffer = surplusBufferValue;\n        badDebt = badDebtValue;\n        emit SurplusBufferUpdated(surplusBufferValue);\n        emit BadDebtUpdated(badDebtValue);\n        return (surplusBufferValue, badDebtValue);\n    }\n\n    // ============================ Governor Functions =============================\n\n    /// @notice Adds a new minter for the stablecoin\n    /// @param minter Minter address to add\n    function addMinter(address minter) external onlyGovernor {\n        if (minter == address(0)) revert ZeroAddress();\n        stablecoin.addMinter(minter);\n    }\n\n    /// @notice Adds a new `VaultManager`\n    /// @param vaultManager `VaultManager` contract to add\n    /// @dev This contract should have already been initialized with a correct treasury address\n    /// @dev It's this function that gives the minter right to the `VaultManager`\n    function addVaultManager(address vaultManager) external onlyGovernor {\n        if (vaultManagerMap[vaultManager] == 1) revert AlreadyVaultManager();\n        if (address(IVaultManager(vaultManager).treasury()) != address(this)) revert InvalidTreasury();\n        vaultManagerMap[vaultManager] = 1;\n        vaultManagerList.push(vaultManager);\n        emit VaultManagerToggled(vaultManager);\n        stablecoin.addMinter(vaultManager);\n    }\n\n    /// @notice Removes a minter from the stablecoin contract\n    /// @param minter Minter address to remove\n    function removeMinter(address minter) external onlyGovernor {\n        // To remove the minter role to a `VaultManager` you have to go through the `removeVaultManager` function\n        if (vaultManagerMap[minter] == 1) revert InvalidAddress();\n        stablecoin.removeMinter(minter);\n    }\n\n    /// @notice Removes a `VaultManager`\n    /// @param vaultManager `VaultManager` contract to remove\n    /// @dev A removed `VaultManager` loses its minter right on the stablecoin\n    function removeVaultManager(address vaultManager) external onlyGovernor {\n        if (vaultManagerMap[vaultManager] != 1) revert NotVaultManager();\n        delete vaultManagerMap[vaultManager];\n        // deletion from `vaultManagerList` loop\n        uint256 vaultManagerListLength = vaultManagerList.length;\n        for (uint256 i = 0; i < vaultManagerListLength - 1; i++) {\n            if (vaultManagerList[i] == vaultManager) {\n                // replace the `VaultManager` to remove with the last of the list\n                vaultManagerList[i] = vaultManagerList[vaultManagerListLength - 1];\n                break;\n            }\n        }\n        // remove last element in array\n        vaultManagerList.pop();\n        emit VaultManagerToggled(vaultManager);\n        stablecoin.removeMinter(vaultManager);\n    }\n\n    /// @notice Allows to recover any ERC20 token, including the stablecoin handled by this contract, and to send it\n    /// to a contract\n    /// @param tokenAddress Address of the token to recover\n    /// @param to Address of the contract to send collateral to\n    /// @param amountToRecover Amount of collateral to transfer\n    /// @dev It is impossible to recover the stablecoin of the protocol if there is some bad debt for it\n    /// @dev In this case, the function makes sure to fetch the surplus/bad debt from all the `VaultManager` contracts\n    /// and from the flash loan module\n    /// @dev If the token to recover is the stablecoin, tokens recovered are fetched\n    /// from the surplus and not from the `surplusBuffer`\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyGovernor {\n        // Cannot recover stablecoin if badDebt or tap into the surplus buffer\n        if (tokenAddress == address(stablecoin)) {\n            _fetchSurplusFromAll();\n            // If balance is non zero then this means, after the call to `fetchSurplusFromAll` that\n            // bad debt is necessarily null\n            uint256 balance = stablecoin.balanceOf(address(this));\n            if (amountToRecover + surplusBuffer > balance) revert TooBigAmount();\n            stablecoin.transfer(to, amountToRecover);\n        } else {\n            IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        }\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Changes the treasury contract and communicates this change to all `VaultManager` contract\n    /// @param _treasury New treasury address for this stablecoin\n    /// @dev This function is basically a way to remove rights to this contract and grant them to a new one\n    /// @dev It could be used to set a new core contract\n    function setTreasury(address _treasury) external onlyGovernor {\n        if (ITreasury(_treasury).stablecoin() != stablecoin) revert InvalidTreasury();\n        // Flash loan role should be removed before calling this function\n        if (core.isFlashLoanerTreasury(address(this))) revert RightsNotRemoved();\n        emit NewTreasurySet(_treasury);\n        for (uint256 i = 0; i < vaultManagerList.length; i++) {\n            IVaultManager(vaultManagerList[i]).setTreasury(_treasury);\n        }\n        // A `TreasuryUpdated` event is triggered in the stablecoin\n        stablecoin.setTreasury(_treasury);\n    }\n\n    /// @notice Sets the `surplusForGovernance` parameter\n    /// @param _surplusForGovernance New value of the parameter\n    /// @dev To pause surplus distribution, governance needs to set a zero value for `surplusForGovernance`\n    /// which means\n    function setSurplusForGovernance(uint64 _surplusForGovernance) external onlyGovernor {\n        if (_surplusForGovernance > BASE_PARAMS) revert TooHighParameterValue();\n        surplusForGovernance = _surplusForGovernance;\n        emit SurplusForGovernanceUpdated(_surplusForGovernance);\n    }\n\n    /// @notice Sets the `surplusManager` contract responsible for handling the surplus of the\n    /// protocol\n    /// @param _surplusManager New address responsible for handling the surplus\n    function setSurplusManager(address _surplusManager) external onlyGovernor {\n        if (_surplusManager == address(0)) revert ZeroAddress();\n        surplusManager = _surplusManager;\n        emit SurplusManagerUpdated(_surplusManager);\n    }\n\n    /// @notice Sets a new `core` contract\n    /// @dev This function should typically be called on all treasury contracts after the `setCore`\n    /// function has been called on the `CoreBorrow` contract\n    /// @dev One sanity check that can be performed here is to verify whether at least the governor\n    /// calling the contract is still a governor in the new core\n    function setCore(ICoreBorrow _core) external onlyGovernor {\n        if (!_core.isGovernor(msg.sender)) revert NotGovernor();\n        core = ICoreBorrow(_core);\n        emit CoreUpdated(address(_core));\n    }\n\n    /// @inheritdoc ITreasury\n    function setFlashLoanModule(address _flashLoanModule) external {\n        if (msg.sender != address(core)) revert NotCore();\n        address oldFlashLoanModule = address(flashLoanModule);\n        flashLoanModule = IFlashAngle(_flashLoanModule);\n        if (oldFlashLoanModule != address(0)) {\n            stablecoin.removeMinter(oldFlashLoanModule);\n        }\n        // We may want to cancel the module\n        if (_flashLoanModule != address(0)) {\n            stablecoin.addMinter(_flashLoanModule);\n        }\n    }\n}\n"
    },
    "contracts/oracle/BaseOracleChainlinkMulti.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\n/// @title BaseOracleChainlinkMulti\n/// @author Angle Core Team\n/// @notice Base Contract to be overriden by all contracts of the protocol\n/// @dev This base contract concerns an oracle that uses Chainlink with multiple pools to read from\n/// @dev All gas-efficient implementation of the `OracleChainlinkMulti` contract should inherit from this\nabstract contract BaseOracleChainlinkMulti is IOracle {\n    // ========================= Parameters and References =========================\n\n    /// @inheritdoc IOracle\n    ITreasury public override treasury;\n    /// @notice Represent the maximum amount of time (in seconds) between each Chainlink update\n    /// before the price feed is considered stale\n    uint32 public stalePeriod;\n\n    // =================================== Event ===================================\n\n    event StalePeriodUpdated(uint32 _stalePeriod);\n\n    // =================================== Errors ===================================\n\n    error InvalidChainlinkRate();\n    error NotGovernorOrGuardian();\n    error NotVaultManagerOrGovernor();\n\n    /// @notice Constructor for an oracle using Chainlink with multiple pools to read from\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the VaultManager which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) {\n        stalePeriod = _stalePeriod;\n        treasury = ITreasury(_treasury);\n    }\n\n    // ============================= Reading Oracles ===============================\n\n    /// @inheritdoc IOracle\n    function read() external view virtual override returns (uint256 quoteAmount);\n\n    /// @notice Reads a Chainlink feed using a quote amount and converts the quote amount to\n    /// the out-currency\n    /// @param quoteAmount The amount for which to compute the price expressed with base decimal\n    /// @param feed Chainlink feed to query\n    /// @param multiplied Whether the ratio outputted by Chainlink should be multiplied or divided\n    /// to the `quoteAmount`\n    /// @param decimals Number of decimals of the corresponding Chainlink pair\n    /// @return The `quoteAmount` converted in out-currency\n    function _readChainlinkFeed(\n        uint256 quoteAmount,\n        AggregatorV3Interface feed,\n        uint8 multiplied,\n        uint256 decimals\n    ) internal view returns (uint256) {\n        (uint80 roundId, int256 ratio, , uint256 updatedAt, uint80 answeredInRound) = feed.latestRoundData();\n        if (ratio <= 0 || roundId > answeredInRound || block.timestamp - updatedAt > stalePeriod)\n            revert InvalidChainlinkRate();\n        uint256 castedRatio = uint256(ratio);\n        // Checking whether we should multiply or divide by the ratio computed\n        if (multiplied == 1) return (quoteAmount * castedRatio) / (10**decimals);\n        else return (quoteAmount * (10**decimals)) / castedRatio;\n    }\n\n    // ======================= Governance Related Functions ========================\n\n    /// @notice Changes the stale period\n    /// @param _stalePeriod New stale period (in seconds)\n    function changeStalePeriod(uint32 _stalePeriod) external {\n        if (!treasury.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        stalePeriod = _stalePeriod;\n        emit StalePeriodUpdated(_stalePeriod);\n    }\n\n    /// @inheritdoc IOracle\n    function setTreasury(address _treasury) external override {\n        if (!treasury.isVaultManager(msg.sender) && !treasury.isGovernor(msg.sender))\n            revert NotVaultManagerOrGovernor();\n        treasury = ITreasury(_treasury);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/oracle/OracleChainlinkMultiTemplate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"./BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleChainlinkMultiTemplate\n/// @author Angle Core Team\n/// @notice Oracle contract, one contract is deployed per collateral/stablecoin pair\n/// @dev This contract concerns an oracle that uses Chainlink with multiple pools to read from\n/// @dev This is a template and a more gas-efficient implementation of the `OracleChainlinkMulti` contract\ncontract OracleChainlinkMultiTemplate is BaseOracleChainlinkMulti {\n    // ===================== To be modified before deployment ======================\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"ETH/EUR Oracle\";\n\n    // =============================================================================\n\n    /// @notice Constructor for an oracle using Chainlink with multiple pools to read from\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the VaultManager which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    // ============================= Reading Oracles ===============================\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        // ===================== To be modified before deployment ==================\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            AggregatorV3Interface(address(0)),\n            AggregatorV3Interface(address(0))\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [0, 0];\n        uint8[2] memory chainlinkDecimals = [0, 0];\n        // =========================================================================\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/OracleChainlinkMulti.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"./BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleChainlinkMulti\n/// @author Angle Core Team\n/// @notice Oracle contract, one contract is deployed per collateral/stablecoin pair\n/// @dev This contract concerns an oracle that uses Chainlink with multiple pools to read from\n/// @dev Typically we expect to use this contract to read like the ETH/USD and then USD/EUR feed\ncontract OracleChainlinkMulti is BaseOracleChainlinkMulti {\n    // ========================= Parameters and References =========================\n\n    /// @notice Chainlink pools, the order of the pools has to be the order in which they are read for the computation\n    /// of the price\n    AggregatorV3Interface[] public circuitChainlink;\n    /// @notice Whether each rate for the pairs in `circuitChainlink` should be multiplied or divided\n    uint8[] public circuitChainIsMultiplied;\n    /// @notice Decimals for each Chainlink pairs\n    uint8[] public chainlinkDecimals;\n    /// @notice Unit of the stablecoin\n    uint256 public immutable outBase;\n    /// @notice Description of the assets concerned by the oracle and the price outputted\n    string public description;\n\n    // ===================================== Error =================================\n\n    error IncompatibleLengths();\n\n    /// @notice Constructor for an oracle using Chainlink with multiple pools to read from\n    /// @param _circuitChainlink Chainlink pool addresses (in order)\n    /// @param _circuitChainIsMultiplied Whether we should multiply or divide by this rate\n    /// @param _outBase Unit of the stablecoin (or the out asset) associated to the oracle\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the VaultManager which reads from this feed\n    /// @param _description Description of the assets concerned by the oracle\n    /// @dev For instance, if this oracle is supposed to give the price of ETH in EUR, and if the agEUR\n    /// stablecoin associated to EUR has 18 decimals, then `outBase` should be 10**18\n    constructor(\n        address[] memory _circuitChainlink,\n        uint8[] memory _circuitChainIsMultiplied,\n        uint256 _outBase,\n        uint32 _stalePeriod,\n        address _treasury,\n        string memory _description\n    ) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {\n        outBase = _outBase;\n        description = _description;\n        uint256 circuitLength = _circuitChainlink.length;\n        if (circuitLength == 0 || circuitLength != _circuitChainIsMultiplied.length) revert IncompatibleLengths();\n        for (uint256 i = 0; i < circuitLength; i++) {\n            AggregatorV3Interface _pool = AggregatorV3Interface(_circuitChainlink[i]);\n            circuitChainlink.push(_pool);\n            chainlinkDecimals.push(_pool.decimals());\n        }\n        circuitChainIsMultiplied = _circuitChainIsMultiplied;\n    }\n\n    // ============================= Reading Oracles ===============================\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = outBase;\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/polygon/OracleUSDCEURChainlinkPolygon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleUSDCEURChainlinkPolygon\n/// @author Angle Core Team\n/// @notice Gives the price of USDC in Euro in base 18\n/// @dev This contract is built to be deployed on Polygon\ncontract OracleUSDCEURChainlinkPolygon is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"USDC/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle USDC/USD\n            AggregatorV3Interface(0xfE4A8cc5b5B2366C1B58Bea3858e81843581b2F7),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0x73366Fe0AA0Ded304479862808e02506FE556a98)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/polygon/OracleMATICEURChainlinkPolygon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleMATICEURChainlinkPolygon\n/// @author Angle Core Team\n/// @notice Gives the price of MATIC in Euro in base 18\n/// @dev This contract is built to be deployed on Polygon\ncontract OracleMATICEURChainlinkPolygon is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"MATIC/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle MATIC/USD\n            AggregatorV3Interface(0xAB594600376Ec9fD91F8e885dADF0CE036862dE0),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0x73366Fe0AA0Ded304479862808e02506FE556a98)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/polygon/OracleETHEURChainlinkPolygon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleETHEURChainlinkPolygon\n/// @author Angle Core Team\n/// @notice Gives the price of ETH in Euro in base 18\n/// @dev This contract is built to be deployed on Polygon\ncontract OracleETHEURChainlinkPolygon is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"ETH/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle ETH/USD\n            AggregatorV3Interface(0xF9680D99D6C9589e2a93a78A04A279e509205945),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0x73366Fe0AA0Ded304479862808e02506FE556a98)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/polygon/OracleBTCEURChainlinkPolygon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleBTCEURChainlinkPolygon\n/// @author Angle Core Team\n/// @notice Gives the price of BTC in Euro in base 18\n/// @dev This contract is built to be deployed on Polygon\ncontract OracleBTCEURChainlinkPolygon is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"BTC/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle BTC/USD\n            AggregatorV3Interface(0xc907E116054Ad103354f2D350FD2514433D57F6f),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0x73366Fe0AA0Ded304479862808e02506FE556a98)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/optimism/OracleUSDCEURChainlinkOptimism.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleUSDCEURChainlinkOptimism\n/// @author Angle Core Team\n/// @notice Gives the price of USDC in Euro in base 18\n/// @dev This contract is built to be deployed on Optimism\ncontract OracleUSDCEURChainlinkOptimism is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"USDC/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle USDC/USD\n            AggregatorV3Interface(0x16a9FA2FDa030272Ce99B29CF780dFA30361E0f3),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0x3626369857A10CcC6cc3A6e4f5C2f5984a519F20)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/optimism/OracleOPEURChainlinkOptimism.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleOPEURChainlinkOptimism\n/// @author Angle Core Team\n/// @notice Gives the price of OP in Euro in base 18\n/// @dev This contract is built to be deployed on Optimism\ncontract OracleOPEURChainlinkOptimism is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"OP/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle OP/USD\n            AggregatorV3Interface(0x0D276FC14719f9292D5C1eA2198673d1f4269246),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0x3626369857A10CcC6cc3A6e4f5C2f5984a519F20)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/optimism/OracleETHEURChainlinkOptimism.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleETHEURChainlinkOptimism\n/// @author Angle Core Team\n/// @notice Gives the price of ETH in Euro in base 18\n/// @dev This contract is built to be deployed on Optimism\ncontract OracleETHEURChainlinkOptimism is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"ETH/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle ETH/USD\n            AggregatorV3Interface(0x13e3Ee699D1909E989722E753853AE30b17e08c5),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0x3626369857A10CcC6cc3A6e4f5C2f5984a519F20)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/OracleWSTETHEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\nimport \"../../../interfaces/external/lido/IStETH.sol\";\n\n/// @title OracleWSTETHEURChainlink\n/// @author Angle Core Team\n/// @notice Gives the price of wSTETH in Euro in base 18\ncontract OracleWSTETHEURChainlink is BaseOracleChainlinkMulti {\n    string public constant DESCRIPTION = \"wSTETH/EUR Oracle\";\n    IStETH public constant STETH = IStETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = STETH.getPooledEthByShares(1 ether);\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Chainlink stETH/USD address\n            AggregatorV3Interface(0xCfE54B5cD566aB89272946F602D76Ea879CAb4a8),\n            // Chainlink EUR/USD address\n            AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/interfaces/external/lido/IStETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title IStETH\n/// @author Angle Core Team\n/// @notice Interface for the `StETH` contract\n/// @dev This interface only contains functions of the `StETH` which are called by other contracts\n/// of this module\ninterface IStETH {\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\n\n    event Submitted(address sender, uint256 amount, address referral);\n\n    function submit(address) external payable returns (uint256);\n\n    function getSharesByPooledEth(uint256 _ethAmount) external view returns (uint256);\n}\n"
    },
    "contracts/oracle/implementations/mainnet/OracleLUSDEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleLUSDEURChainlink\n/// @author Angle Core Team\n/// @notice Gives the price of LUSD in Euro in base 18\ncontract OracleLUSDEURChainlink is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"LUSD/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle LUSD/USD\n            AggregatorV3Interface(0x3D7aE7E594f2f2091Ad8798313450130d0Aba3a0),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/OracleETHEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleETHEURChainlink\n/// @author Angle Core Team\n/// @notice Gives the price of ETH in Euro in base 18\ncontract OracleETHEURChainlink is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"ETH/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle ETH/USD\n            AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/OracleBTCEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleBTCEURChainlink\n/// @author Angle Core Team\n/// @notice Gives the price of BTC in Euro in base 18\ncontract OracleBTCEURChainlink is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"BTC/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle BTC/USD\n            AggregatorV3Interface(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/avalanche/OracleETHEURChainlinkAvalanche.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleETHEURChainlinkAvalanche\n/// @author Angle Core Team\n/// @notice Gives the price of ETH in Euro in base 18\n/// @dev This contract is built to be deployed on Avalanche\ncontract OracleETHEURChainlinkAvalanche is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"ETH/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle ETH/USD\n            AggregatorV3Interface(0x976B3D034E162d8bD72D6b9C989d545b839003b0),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0x192f2DBA961Bb0277520C082d6bfa87D5961333E)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/avalanche/OracleAVAXEURChainlinkAvalanche.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleAVAXEURChainlinkAvalanche\n/// @author Angle Core Team\n/// @notice Gives the price of AVAX in Euro in base 18\n/// @dev This contract is built to be deployed on Avalanche\ncontract OracleAVAXEURChainlinkAvalanche is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"AVAX/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle AVAX/USD\n            AggregatorV3Interface(0x0A77230d17318075983913bC2145DB16C7366156),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0x192f2DBA961Bb0277520C082d6bfa87D5961333E)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/arbitrum/OracleUSDCEURChainlinkArbitrum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleUSDCEURChainlinkArbitrum\n/// @author Angle Core Team\n/// @notice Gives the price of USDC in Euro in base 18\n/// @dev This contract is built to be deployed on Arbitrum\ncontract OracleUSDCEURChainlinkArbitrum is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"USDC/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle USDC/USD\n            AggregatorV3Interface(0x50834F3163758fcC1Df9973b6e91f0F0F0434aD3),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0xA14d53bC1F1c0F31B4aA3BD109344E5009051a84)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/arbitrum/OracleETHEURChainlinkArbitrum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleETHEURChainlinkArbitrum\n/// @author Angle Core Team\n/// @notice Gives the price of ETH in Euro in base 18\n/// @dev This contract is built to be deployed on Arbitrum\ncontract OracleETHEURChainlinkArbitrum is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"ETH/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle ETH/USD\n            AggregatorV3Interface(0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0xA14d53bC1F1c0F31B4aA3BD109344E5009051a84)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/arbitrum/OracleBTCEURChainlinkArbitrum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleBTCEURChainlinkArbitrum\n/// @author Angle Core Team\n/// @notice Gives the price of BTC in Euro in base 18\n/// @dev This contract is built to be deployed on Arbitrum\ncontract OracleBTCEURChainlinkArbitrum is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    string public constant DESCRIPTION = \"BTC/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle BTC/USD\n            AggregatorV3Interface(0x6ce185860a4963106506C203335A2910413708e9),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0xA14d53bC1F1c0F31B4aA3BD109344E5009051a84)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/mock/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IOracle.sol\";\n\ncontract MockOracle is IOracle {\n    event Update(uint256 _peg);\n\n    ITreasury public treasury;\n\n    uint256 public base = 1 ether;\n    uint256 public precision = 1 ether;\n    uint256 public rate;\n    bool public outdated;\n\n    /// @notice Initiate with a fixe change rate\n    constructor(uint256 rate_, ITreasury _treasury) {\n        rate = rate_;\n        treasury = _treasury;\n    }\n\n    /// @notice Mock read\n    function read() external view override returns (uint256) {\n        return rate;\n    }\n\n    /// @notice change oracle rate\n    function update(uint256 newRate) external {\n        rate = newRate;\n    }\n\n    function setTreasury(address _treasury) external override {\n        treasury = ITreasury(_treasury);\n    }\n}\n"
    },
    "contracts/mock/MockVaultManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IVaultManager.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockVaultManager {\n    ITreasury public treasury;\n    mapping(uint256 => Vault) public vaultData;\n    mapping(uint256 => address) public ownerOf;\n    uint256 public surplus;\n    uint256 public badDebt;\n    IAgToken public token;\n    address public oracle = address(this);\n\n    address public governor;\n    address public collateral;\n    address public stablecoin;\n    uint256 public oracleValue;\n    uint256 public interestAccumulator;\n    uint256 public collateralFactor;\n    uint256 public totalNormalizedDebt;\n\n    constructor(address _treasury) {\n        treasury = ITreasury(_treasury);\n    }\n\n    function accrueInterestToTreasury() external returns (uint256, uint256) {\n        // Avoid the function to be view\n        if (surplus >= badDebt) {\n            token.mint(msg.sender, surplus - badDebt);\n        }\n        return (surplus, badDebt);\n    }\n\n    function read() external view returns (uint256) {\n        return oracleValue;\n    }\n\n    function setParams(\n        address _governor,\n        address _collateral,\n        address _stablecoin,\n        uint256 _oracleValue,\n        uint256 _interestAccumulator,\n        uint256 _collateralFactor,\n        uint256 _totalNormalizedDebt\n    ) external {\n        governor = _governor;\n        collateral = _collateral;\n        stablecoin = _stablecoin;\n        interestAccumulator = _interestAccumulator;\n        collateralFactor = _collateralFactor;\n        totalNormalizedDebt = _totalNormalizedDebt;\n        oracleValue = _oracleValue;\n    }\n\n    function setOwner(uint256 vaultID, address owner) external {\n        ownerOf[vaultID] = owner;\n    }\n\n    function setVaultData(\n        uint256 normalizedDebt,\n        uint256 collateralAmount,\n        uint256 vaultID\n    ) external {\n        vaultData[vaultID].normalizedDebt = normalizedDebt;\n        vaultData[vaultID].collateralAmount = collateralAmount;\n    }\n\n    function isGovernor(address admin) external view returns (bool) {\n        return admin == governor;\n    }\n\n    function setSurplusBadDebt(\n        uint256 _surplus,\n        uint256 _badDebt,\n        IAgToken _token\n    ) external {\n        surplus = _surplus;\n        badDebt = _badDebt;\n        token = _token;\n    }\n\n    function getDebtOut(\n        uint256 vaultID,\n        uint256 amountStablecoins,\n        uint256 senderBorrowFee\n    ) external {}\n\n    function setTreasury(address _treasury) external {\n        treasury = ITreasury(_treasury);\n    }\n\n    function getVaultDebt(uint256 vaultID) external view returns (uint256) {\n        vaultID;\n        token;\n        return 0;\n    }\n\n    function createVault(address toVault) external view returns (uint256) {\n        toVault;\n        token;\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/agToken/layerZero/LayerZeroBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"./utils/OFTCore.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\n/// @title LayerZeroBridge\n/// @author Angle Core Team, forked from https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/token/oft/OFT.sol\n/// @notice Contract to be deployed on Ethereum for bridging an AgToken using a bridge intermediate token and LayerZero\ncontract LayerZeroBridge is OFTCore, PausableUpgradeable {\n    /// @notice Name of the contract for indexing purposes\n    string public name;\n\n    /// @notice Address of the bridgeable token\n    /// @dev Immutable\n    IERC20 public canonicalToken;\n\n    /// @notice Maps an address to the amount of token bridged but not received\n    mapping(address => uint256) public balanceOf;\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializes the contract\n    /// @param _name Name of the token corresponding to this contract\n    /// @param _lzEndpoint Layer zero endpoint to pass messages\n    /// @param _treasury Address of the treasury contract used for access control\n    function initialize(\n        string memory _name,\n        address _lzEndpoint,\n        address _treasury\n    ) external initializer {\n        __LzAppUpgradeable_init(_lzEndpoint, _treasury);\n        name = _name;\n        canonicalToken = IERC20(address(ITreasury(_treasury).stablecoin()));\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ==================== External Permissionless Functions ======================\n\n    /// @inheritdoc OFTCore\n    function sendWithPermit(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable override {\n        IERC20Permit(address(canonicalToken)).permit(msg.sender, address(this), _amount, deadline, v, r, s);\n        send(_dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    /// @inheritdoc OFTCore\n    function withdraw(uint256 amount, address recipient) external override returns (uint256) {\n        return _withdraw(amount, msg.sender, recipient);\n    }\n\n    /// @notice Withdraws amount of `token` from the contract and sends it to the recipient\n    /// @param amount Amount to withdraw\n    /// @param recipient Address to withdraw for\n    /// @return The amount of canonical token sent\n    function withdrawFor(uint256 amount, address recipient) external returns (uint256) {\n        return _withdraw(amount, recipient, recipient);\n    }\n\n    // ========================== Internal Functions ===============================\n\n    /// @notice Withdraws `amount` from the balance of the `from` address and sends these tokens to the `to` address\n    /// @dev It's important to make sure that `from` is either the `msg.sender` or that `from` and `to` are the same\n    /// addresses\n    function _withdraw(\n        uint256 amount,\n        address from,\n        address to\n    ) internal whenNotPaused returns (uint256) {\n        balanceOf[from] = balanceOf[from] - amount; // Will overflow if the amount is too big\n        canonicalToken.transfer(to, amount);\n        return amount;\n    }\n\n    /// @inheritdoc OFTCore\n    function _debitFrom(\n        uint16,\n        bytes memory,\n        uint256 _amount\n    ) internal override whenNotPaused returns (uint256) {\n        // No need to use safeTransferFrom as we know this implementation reverts on failure\n        canonicalToken.transferFrom(msg.sender, address(this), _amount);\n        return _amount;\n    }\n\n    /// @inheritdoc OFTCore\n    function _debitCreditFrom(\n        uint16,\n        bytes memory,\n        uint256 _amount\n    ) internal override whenNotPaused returns (uint256) {\n        balanceOf[msg.sender] -= _amount;\n        return _amount;\n    }\n\n    /// @inheritdoc OFTCore\n    function _creditTo(\n        uint16,\n        address _toAddress,\n        uint256 _amount\n    ) internal override whenNotPaused returns (uint256) {\n        // Should never revert as all the LayerZero bridge tokens come from\n        // this contract\n        uint256 balance = canonicalToken.balanceOf(address(this));\n        if (balance < _amount) {\n            balanceOf[_toAddress] = _amount - balance;\n            if (balance > 0) canonicalToken.transfer(_toAddress, balance);\n        } else {\n            canonicalToken.transfer(_toAddress, _amount);\n        }\n        return _amount;\n    }\n\n    // ========================= View Functions ====================================\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // ======================= Governance Functions ================================\n\n    /// @notice Pauses bridging through the contract\n    /// @param pause Future pause status\n    function pauseSendTokens(bool pause) external onlyGovernorOrGuardian {\n        pause ? _pause() : _unpause();\n    }\n\n    /// @notice Decreases the balance of an address\n    /// @param amount Amount to withdraw from balance\n    /// @param recipient Address to withdraw from\n    function sweep(uint256 amount, address recipient) external onlyGovernorOrGuardian {\n        balanceOf[recipient] = balanceOf[recipient] - amount; // Will overflow if the amount is too big\n    }\n\n    uint256[47] private __gap;\n}\n"
    },
    "contracts/agToken/layerZero/utils/OFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"./NonblockingLzApp.sol\";\nimport \"./IOFTCore.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\n/// @title OFTCore\n/// @author Forked from https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/token/oft/OFTCore.sol\n/// but with slight modifications from the Angle Core Team which added return values to the `_creditTo` and `_debitFrom` functions\n/// @notice Base contract for bridging using LayerZero\nabstract contract OFTCore is NonblockingLzApp, ERC165Upgradeable, IOFTCore {\n    // ==================== External Permissionless Functions ======================\n\n    /// @inheritdoc IOFTCore\n    function sendWithPermit(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable virtual;\n\n    /// @inheritdoc IOFTCore\n    function send(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) public payable virtual {\n        _amount = _debitFrom(_dstChainId, _toAddress, _amount);\n\n        bytes memory payload = abi.encode(_toAddress, _amount);\n        _lzSend(_dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n\n        uint64 nonce = lzEndpoint.getOutboundNonce(_dstChainId, address(this));\n        emit SendToChain(msg.sender, _dstChainId, _toAddress, _amount, nonce);\n    }\n\n    /// @inheritdoc IOFTCore\n    function sendCredit(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) public payable virtual {\n        _amount = _debitCreditFrom(_dstChainId, _toAddress, _amount);\n\n        _send(_dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    /// @inheritdoc IOFTCore\n    function withdraw(uint256 amount, address recipient) external virtual returns (uint256);\n\n    // =========================== Internal Functions ==============================\n\n    /// @notice Internal function to send `_amount` amount of token to (`_dstChainId`, `_toAddress`)\n    /// @param _dstChainId the destination chain identifier\n    /// @param _toAddress can be any size depending on the `dstChainId`.\n    /// @param _amount the quantity of tokens in wei\n    /// @param _refundAddress the address LayerZero refunds if too much message fee is sent\n    /// @param _zroPaymentAddress set to address(0x0) if not paying in ZRO (LayerZero Token)\n    /// @param _adapterParams is a flexible bytes array to indicate messaging adapter services\n    /// @dev Accounting and checks should be performed beforehand\n    function _send(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) internal {\n        bytes memory payload = abi.encode(_toAddress, _amount);\n        _lzSend(_dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n\n        uint64 nonce = lzEndpoint.getOutboundNonce(_dstChainId, address(this));\n        emit SendToChain(msg.sender, _dstChainId, _toAddress, _amount, nonce);\n    }\n\n    /// @inheritdoc NonblockingLzApp\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        // decode and load the toAddress\n        (bytes memory toAddressBytes, uint256 amount) = abi.decode(_payload, (bytes, uint256));\n        address toAddress;\n        //solhint-disable-next-line\n        assembly {\n            toAddress := mload(add(toAddressBytes, 20))\n        }\n        amount = _creditTo(_srcChainId, toAddress, amount);\n\n        emit ReceiveFromChain(_srcChainId, _srcAddress, toAddress, amount, _nonce);\n    }\n\n    /// @notice Makes accountability when bridging from this contract using canonical token\n    /// @param _dstChainId ChainId of the destination chain - LayerZero standard\n    /// @param _toAddress Recipient on the destination chain\n    /// @param _amount Amount to bridge\n    function _debitFrom(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount\n    ) internal virtual returns (uint256);\n\n    /// @notice Makes accountability when bridging from this contract's credit\n    /// @param _dstChainId ChainId of the destination chain - LayerZero standard\n    /// @param _toAddress Recipient on the destination chain\n    /// @param _amount Amount to bridge\n    function _debitCreditFrom(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount\n    ) internal virtual returns (uint256);\n\n    /// @notice Makes accountability when bridging to this contract\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _toAddress Recipient on this chain\n    /// @param _amount Amount to bridge\n    function _creditTo(\n        uint16 _srcChainId,\n        address _toAddress,\n        uint256 _amount\n    ) internal virtual returns (uint256);\n\n    // ========================== View Functions ===================================\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IOFTCore\n    function estimateSendFee(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        bool _useZro,\n        bytes memory _adapterParams\n    ) public view virtual override returns (uint256 nativeFee, uint256 zroFee) {\n        // mock the payload for send()\n        bytes memory payload = abi.encode(_toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/agToken/layerZero/utils/NonblockingLzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../interfaces/external/layerZero/ILayerZeroReceiver.sol\";\nimport \"../../../interfaces/external/layerZero/ILayerZeroUserApplicationConfig.sol\";\nimport \"../../../interfaces/external/layerZero/ILayerZeroEndpoint.sol\";\nimport \"../../../interfaces/ITreasury.sol\";\n\n/// @title NonblockingLzApp\n/// @author Angle Core Team, forked from https://github.com/LayerZero-Labs/solidity-examples/\n/// @notice Base contract for bridging using LayerZero\nabstract contract NonblockingLzApp is Initializable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    /// @notice Layer Zero endpoint\n    ILayerZeroEndpoint public lzEndpoint;\n\n    /// @notice Maps chainIds to failed messages to retry them\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    /// @notice Maps chainIds to their OFT address\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n\n    /// @notice Reference to the treasury contract to fetch access control\n    address public treasury;\n\n    // ================================== Events ===================================\n\n    event SetTrustedRemote(uint16 _srcChainId, bytes _srcAddress);\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload);\n\n    // =============================== Errors ================================\n\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error InvalidEndpoint();\n    error InvalidSource();\n    error InvalidCaller();\n    error InvalidPayload();\n    error ZeroAddress();\n\n    // ============================= Constructor ===================================\n\n    //solhint-disable-next-line\n    function __LzAppUpgradeable_init(address _endpoint, address _treasury) internal {\n        if (_endpoint == address(0) || _treasury == address(0)) revert ZeroAddress();\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        treasury = _treasury;\n    }\n\n    // =============================== Modifiers ===================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!ITreasury(treasury).isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    // ==================== External Permissionless Functions ======================\n\n    /// @notice Receives a message from the LZ endpoint and process it\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        if (msg.sender != address(lzEndpoint)) revert InvalidEndpoint();\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        if (_srcAddress.length != trustedRemote.length || keccak256(_srcAddress) != keccak256(trustedRemote))\n            revert InvalidSource();\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    /// @notice Retries a message that previously failed and was stored\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    function retryMessage(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        if (payloadHash == bytes32(0) || keccak256(_payload) != payloadHash) revert InvalidPayload();\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // ============================= Internal Functions ===================================\n\n    /// @notice Handles message receptions in a non blocking way\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    /// @dev public for the needs of try / catch but effectively internal\n    function nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public virtual {\n        // only internal transaction\n        if (msg.sender != address(this)) revert InvalidCaller();\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    /// @notice Handles message receptions in a non blocking way\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual;\n\n    /// @notice Handles message receptions in a blocking way\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    function _blockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal {\n        // try-catch all errors/exceptions\n        try this.nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload) {\n            // do nothing\n        } catch {\n            // error / exception\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload);\n        }\n    }\n\n    /// @notice Sends a message to the LZ endpoint and process it\n    /// @param _dstChainId L0 defined chain id to send tokens too\n    /// @param _payload Data: recipient address and amount\n    /// @param _refundAddress Address LayerZero refunds if too much message fee is sent\n    /// @param _zroPaymentAddress Set to address(0x0) if not paying in ZRO (LayerZero Token)\n    /// @param _adapterParams Flexible bytes array to indicate messaging adapter services in L0\n    function _lzSend(\n        uint16 _dstChainId,\n        bytes memory _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        if (trustedRemote.length == 0) revert InvalidSource();\n        //solhint-disable-next-line\n        lzEndpoint.send{ value: msg.value }(\n            _dstChainId,\n            trustedRemote,\n            _payload,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    // ======================= Governance Functions ================================\n\n    /// @notice Sets the corresponding address on an other chain.\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Address on the source chain\n    /// @dev Used for both receiving and sending message\n    /// @dev There can only be one trusted source per chain\n    /// @dev Allows owner to set it multiple times.\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external onlyGovernorOrGuardian {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    /// @notice Fetches the default LZ config\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address,\n        uint256 _configType\n    ) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    /// @notice Overrides the default LZ config\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint256 _configType,\n        bytes calldata _config\n    ) external override onlyGovernorOrGuardian {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    /// @notice Overrides the default LZ config\n    function setSendVersion(uint16 _version) external override onlyGovernorOrGuardian {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    /// @notice Overrides the default LZ config\n    function setReceiveVersion(uint16 _version) external override onlyGovernorOrGuardian {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    /// @notice Unpauses the receive functionalities\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress)\n        external\n        override\n        onlyGovernorOrGuardian\n    {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // ======================= View Functions ================================\n\n    /// @notice Checks if the `_srcAddress` corresponds to the trusted source\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/agToken/layerZero/utils/IOFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface of the IOFT core standard\n * @dev Forked from https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/token/oft/IOFTCore.sol\n */\ninterface IOFTCore is IERC165 {\n    /// @notice Estimates send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n    /// @param _dstChainId L0 defined chain id to send tokens too\n    /// @param _toAddress dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n    /// @param _amount amount of the tokens to transfer\n    /// @param _useZro indicates to use zro to pay L0 fees\n    /// @param _adapterParams flexible bytes array to indicate messaging adapter services in L0\n    function estimateSendFee(\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint256 _amount,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\n\n    /// @notice Sends `_amount` amount of token to (`_dstChainId`, `_toAddress`)\n    /// @param _dstChainId the destination chain identifier\n    /// @param _toAddress can be any size depending on the `dstChainId`.\n    /// @param _amount the quantity of tokens in wei\n    /// @param _refundAddress the address LayerZero refunds if too much message fee is sent\n    /// @param _zroPaymentAddress set to address(0x0) if not paying in ZRO (LayerZero Token)\n    /// @param _adapterParams is a flexible bytes array to indicate messaging adapter services\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    /// @notice Sends `_amount` amount of credit to (`_dstChainId`, `_toAddress`)\n    /// @param _dstChainId the destination chain identifier\n    /// @param _toAddress can be any size depending on the `dstChainId`.\n    /// @param _amount the quantity of credit to send in wei\n    /// @param _refundAddress the address LayerZero refunds if too much message fee is sent\n    /// @param _zroPaymentAddress set to address(0x0) if not paying in ZRO (LayerZero Token)\n    /// @param _adapterParams is a flexible bytes array to indicate messaging adapter services\n    function sendCredit(\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    /// @notice Sends `_amount` amount of token to (`_dstChainId`, `_toAddress`)\n    /// @param _dstChainId The destination chain identifier\n    /// @param _toAddress Can be any size depending on the `dstChainId`.\n    /// @param _amount Quantity of tokens in wei\n    /// @param _refundAddress Address LayerZero refunds if too much message fee is sent\n    /// @param _zroPaymentAddress Set to address(0x0) if not paying in ZRO (LayerZero Token)\n    /// @param _adapterParams Flexible bytes array to indicate messaging adapter services\n    /// @param deadline Deadline parameter for the signature to be valid\n    /// @dev The `v`, `r`, and `s` parameters are used as signature data\n    function sendWithPermit(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Withdraws amount of canonical token from the `msg.sender` balance and sends it to the recipient\n    /// @param amount Amount to withdraw\n    /// @param recipient Address to send the canonical token to\n    /// @return The amount of canonical token sent\n    function withdraw(uint256 amount, address recipient) external returns (uint256);\n\n    /// @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n    /// `_nonce` is the outbound nonce\n    event SendToChain(\n        address indexed _sender,\n        uint16 indexed _dstChainId,\n        bytes indexed _toAddress,\n        uint256 _amount,\n        uint64 _nonce\n    );\n\n    /// @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\n    /// `_nonce` is the inbound nonce.\n    event ReceiveFromChain(\n        uint16 indexed _srcChainId,\n        bytes indexed _srcAddress,\n        address indexed _toAddress,\n        uint256 _amount,\n        uint64 _nonce\n    );\n}\n\n/// @dev Interface of the OFT standard\ninterface IOFT is IOFTCore, IERC20 {\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/interfaces/external/layerZero/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external;\n}\n"
    },
    "contracts/interfaces/external/layerZero/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint256 _configType,\n        bytes calldata _config\n    ) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "contracts/interfaces/external/layerZero/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint256 _gasLimit,\n        bytes calldata _payload\n    ) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint256 _configType\n    ) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "contracts/agToken/layerZero/LayerZeroBridgeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"./utils/OFTCore.sol\";\nimport \"../../interfaces/IAgTokenSideChainMultiBridge.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title LayerZeroBridgeToken\n/// @author Angle Core Team, forked from https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/token/oft/OFT.sol\n/// @notice Contract to be deployed on a L2/sidechain for bridging an AgToken using a bridge intermediate token and LayerZero\ncontract LayerZeroBridgeToken is OFTCore, ERC20Upgradeable, PausableUpgradeable {\n    /// @notice Address of the bridgeable token\n    /// @dev Immutable\n    IAgTokenSideChainMultiBridge public canonicalToken;\n\n    // =============================== Errors ================================\n\n    error InvalidAllowance();\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializes the contract\n    /// @param _name Name of the token corresponding to this contract\n    /// @param _symbol Symbol of the token corresponding to this contract\n    /// @param _lzEndpoint Layer zero endpoint to pass messages\n    /// @param _treasury Address of the treasury contract used for access control\n    /// @param initialSupply Initial supply to mint to the canonical token address\n    /// @dev The initial supply corresponds to the initial amount that could be bridged using this OFT\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _lzEndpoint,\n        address _treasury,\n        uint256 initialSupply\n    ) external initializer {\n        __ERC20_init_unchained(_name, _symbol);\n        __LzAppUpgradeable_init(_lzEndpoint, _treasury);\n\n        canonicalToken = IAgTokenSideChainMultiBridge(address(ITreasury(_treasury).stablecoin()));\n        _approve(address(this), address(canonicalToken), type(uint256).max);\n        _mint(address(canonicalToken), initialSupply);\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ==================== External Permissionless Functions ======================\n\n    /// @inheritdoc OFTCore\n    function sendWithPermit(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable override {\n        canonicalToken.permit(msg.sender, address(this), _amount, deadline, v, r, s);\n        send(_dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    /// @inheritdoc OFTCore\n    function withdraw(uint256 amount, address recipient) external override returns (uint256 amountMinted) {\n        // Does not check allowances as transfers from `msg.sender`\n        _transfer(msg.sender, address(this), amount);\n        amountMinted = canonicalToken.swapIn(address(this), amount, recipient);\n        uint256 leftover = balanceOf(address(this));\n        if (leftover > 0) {\n            _transfer(address(this), msg.sender, leftover);\n        }\n    }\n\n    // ============================= Internal Functions ===================================\n\n    /// @inheritdoc OFTCore\n    function _debitFrom(\n        uint16,\n        bytes memory,\n        uint256 _amount\n    ) internal override whenNotPaused returns (uint256 amountSwapped) {\n        // No need to use safeTransferFrom as we know this implementation reverts on failure\n        canonicalToken.transferFrom(msg.sender, address(this), _amount);\n\n        // Swap canonical for this bridge token. There may be some fees\n        amountSwapped = canonicalToken.swapOut(address(this), _amount, address(this));\n        _burn(address(this), amountSwapped);\n    }\n\n    /// @inheritdoc OFTCore\n    function _debitCreditFrom(\n        uint16,\n        bytes memory,\n        uint256 _amount\n    ) internal override whenNotPaused returns (uint256) {\n        _burn(msg.sender, _amount);\n        return _amount;\n    }\n\n    /// @inheritdoc OFTCore\n    function _creditTo(\n        uint16,\n        address _toAddress,\n        uint256 _amount\n    ) internal override whenNotPaused returns (uint256 amountMinted) {\n        _mint(address(this), _amount);\n        amountMinted = canonicalToken.swapIn(address(this), _amount, _toAddress);\n        uint256 leftover = balanceOf(address(this));\n        if (leftover > 0) {\n            _transfer(address(this), _toAddress, leftover);\n        }\n    }\n\n    // ======================= View Functions ================================\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IOFT).interfaceId ||\n            interfaceId == type(IERC20).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    // ======================= Governance Functions ================================\n\n    /// @notice Mints the intermediate contract to the `canonicalToken`\n    /// @dev Used to increase the bridging capacity\n    function mint(uint256 amount) external onlyGovernorOrGuardian {\n        _mint(address(canonicalToken), amount);\n    }\n\n    /// @notice Burns the intermediate contract from the `canonicalToken`\n    /// @dev Used to decrease the bridging capacity\n    function burn(uint256 amount) external onlyGovernorOrGuardian {\n        _burn(address(canonicalToken), amount);\n    }\n\n    /// @notice Increases allowance of the `canonicalToken`\n    function setupAllowance() public onlyGovernorOrGuardian {\n        _approve(address(this), address(canonicalToken), type(uint256).max);\n    }\n\n    /// @notice Pauses bridging through the contract\n    /// @param pause Future pause status\n    function pauseSendTokens(bool pause) external onlyGovernorOrGuardian {\n        pause ? _pause() : _unpause();\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/interfaces/IAgTokenSideChainMultiBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @title IAgTokenSideChainMultiBridge\n/// @author Angle Core Team\n/// @notice Interface for the canonical `AgToken` contracts\n/// @dev This interface only contains functions useful for bridge tokens to interact with the canonical token\ninterface IAgTokenSideChainMultiBridge is IERC20PermitUpgradeable, IERC20Upgradeable {\n    /// @notice Mints the canonical token from a supported bridge token\n    /// @param bridgeToken Bridge token to use to mint\n    /// @param amount Amount of bridge tokens to send\n    /// @param to Address to which the stablecoin should be sent\n    /// @return Amount of the canonical stablecoin actually minted\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapIn(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /// @notice Burns the canonical token in exchange for a bridge token\n    /// @param bridgeToken Bridge token required\n    /// @param amount Amount of canonical tokens to burn\n    /// @param to Address to which the bridge token should be sent\n    /// @return Amount of bridge tokens actually sent back\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapOut(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n}\n"
    },
    "contracts/reactor/BaseReactorStorage.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../interfaces/external/IERC4626.sol\";\nimport \"../interfaces/IVaultManager.sol\";\n\n/// @title BaseReactorStorage\n/// @author Angle Core Team\n/// @dev Variables, references, parameters and events needed in the `BaseReactor` contract\n// solhint-disable-next-line max-states-count\ncontract BaseReactorStorage is Initializable, ReentrancyGuardUpgradeable {\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    // =============================== References ==================================\n\n    /// @notice Reference to the asset controlled by this reactor\n    IERC20 public asset;\n    /// @notice Reference to the stablecoin this reactor handles\n    IAgToken public stablecoin;\n    /// @notice Oracle giving the price of the asset with respect to the stablecoin\n    IOracle public oracle;\n    /// @notice Treasury contract handling access control\n    ITreasury public treasury;\n    /// @notice VaultManager contract on which this contract has a vault. All references should\n    /// be fetched from here\n    IVaultManager public vaultManager;\n    /// @notice ID of the vault handled by this contract\n    uint256 public vaultID;\n    /// @notice Dust parameter for the stablecoins in a vault in `VaultManager`\n    uint256 public vaultManagerDust;\n    /// @notice Base of the `asset`. While it is assumed in this contract that the base of the stablecoin is 18,\n    /// the base of the `asset` may not be 18\n    uint256 internal _assetBase;\n\n    // =============================== Parameters ==================================\n\n    /// @notice Lower value of the collateral factor: below this the reactor can borrow stablecoins\n    uint64 public lowerCF;\n    /// @notice Value of the collateral factor targeted by this vault\n    uint64 public targetCF;\n    /// @notice Value of the collateral factor above which stablecoins should be repaid to avoid liquidations\n    uint64 public upperCF;\n    /// @notice Value of the fees going to the protocol at each yield gain from the strategy\n    uint64 public protocolInterestShare;\n    /// @notice Address responsible for handling the surplus of the protocol\n    address public surplusManager;\n\n    // =============================== Variables ===================================\n\n    /// @notice Protocol fee surplus: the protocol should only accumulate yield from the strategies and not make a gain\n    /// in situations where there are liquidations or so.\n    uint256 public protocolInterestAccumulated;\n    /// @notice Loss accumulated to be taken from the protocol\n    uint256 public protocolDebt;\n    /// @notice Rewards (in stablecoin) claimable by depositors of the reactor\n    uint256 public claimableRewards;\n    /// @notice Loss (in stablecoin) accumulated by the reactor: it's going to prevent the reactor from\n    /// repaying its debt\n    uint256 public currentLoss;\n    /// @notice Used to track rewards accumulated by all depositors of the reactor\n    uint256 public rewardsAccumulator;\n    /// @notice Tracks rewards already claimed by all depositors\n    uint256 public claimedRewardsAccumulator;\n    /// @notice Last time rewards were claimed in the reactor\n    uint256 public lastTime;\n    /// @notice Last known stable debt to the `VaultManager`\n    uint256 public lastDebt;\n\n    /// @notice Maps an address to the last time it claimed its rewards\n    mapping(address => uint256) public lastTimeOf;\n    /// @notice Maps an address to a quantity depending on time and shares of the reactors used\n    /// to compute the rewards an address can claim\n    mapping(address => uint256) public rewardsAccumulatorOf;\n\n    uint256[50] private __gap;\n\n    // =============================== Events ======================================\n\n    event FiledUint64(uint64 param, bytes32 what);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n\n    // =============================== Errors ======================================\n\n    error InvalidParameterValue();\n    error InvalidParameterType();\n    error InvalidSetOfParameters();\n    error InvalidToken();\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error NotVaultManager();\n    error TooHighParameterValue();\n    error TransferAmountExceedsAllowance();\n    error ZeroAddress();\n    error ZeroAssets();\n    error ZeroShares();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/interfaces/external/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice Minimal IERC4646 tokenized Vault interface.\n/// @author Forked from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @dev Do not use in production! ERC-4626 is still in the review stage and is subject to change.\ninterface IERC4626 {\n    event Deposit(address indexed from, address indexed to, uint256 amount, uint256 shares);\n    event Withdraw(address indexed from, address indexed to, uint256 amount, uint256 shares);\n\n    /// @notice Transfers a given amount of asset to the reactor and mint shares accordingly\n    /// @param amount Given amount of asset\n    /// @param to Address to mint shares to\n    /// @return shares Amount of shares minted to `to`\n    function deposit(uint256 amount, address to) external returns (uint256 shares);\n\n    /// @notice Mints a given amount of shares to the reactor and transfer assets accordingly\n    /// @param shares Given amount of shares\n    /// @param to Address to mint shares to\n    /// @return amount Amount of `asset` taken to the `msg.sender` to mint `shares`\n    function mint(uint256 shares, address to) external returns (uint256 amount);\n\n    /// @notice Transfers a given amount of asset from the reactor and burn shares accordingly\n    /// @param amount Given amount of asset\n    /// @param to Address to transfer assets to\n    /// @param from Address to burn shares from\n    /// @return shares Amount of shares burnt in the operation\n    function withdraw(\n        uint256 amount,\n        address to,\n        address from\n    ) external returns (uint256 shares);\n\n    /// @notice Burns a given amount of shares to the reactor and transfer assets accordingly\n    /// @param shares Given amount of shares\n    /// @param to Address to transfer assets to\n    /// @param from Address to burn shares from\n    /// @return amount Amount of assets redeemed in the operation\n    function redeem(\n        uint256 shares,\n        address to,\n        address from\n    ) external returns (uint256 amount);\n\n    /// @notice Returns the total assets managed by this reactor\n    function totalAssets() external view returns (uint256);\n\n    /// @notice Converts an amount of assets to the corresponding amount of reactor shares\n    /// @param assets Amount of asset to convert\n    /// @return Shares corresponding to the amount of assets obtained\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    /// @notice Converts an amount of shares to its current value in asset\n    /// @param shares Amount of shares to convert\n    /// @return Amount of assets corresponding to the amount of assets given\n    function convertToAssets(uint256 shares) external view returns (uint256);\n\n    /// @notice Computes how many shares one would get by depositing `assets`\n    /// @param assets Amount of asset to convert\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    /// @notice Computes how many assets one would need to mint `shares`\n    /// @param shares Amount of shares required\n    function previewMint(uint256 shares) external view returns (uint256);\n\n    /// @notice Computes how many shares one would need to withdraw assets\n    /// @param assets Amount of asset to withdraw\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    /// @notice Computes how many assets one would get by burning shares\n    /// @param shares Amount of shares to burn\n    function previewRedeem(uint256 shares) external view returns (uint256);\n\n    /// @notice Max deposit allowed for a user\n    /// @param user Address of the user to check\n    function maxDeposit(address user) external returns (uint256);\n\n    /// @notice Max mint allowed for a user\n    /// @param user Address of the user to check\n    function maxMint(address user) external returns (uint256);\n\n    /// @notice Max withdraw allowed for a user\n    /// @param user Address of the user to check\n    function maxWithdraw(address user) external returns (uint256);\n\n    /// @notice Max redeem allowed for a user\n    /// @param user Address of the user to check\n    function maxRedeem(address user) external returns (uint256);\n}\n"
    },
    "contracts/mock/MockPolygonAgEUR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"../agToken/polygon/utils/ERC20UpgradeableCustom.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\ninterface IChildToken {\n    function deposit(address user, bytes calldata depositData) external;\n\n    function withdraw(uint256 amount) external;\n}\n\ncontract MockPolygonAgEUR is\n    Initializable,\n    ERC20UpgradeableCustom,\n    AccessControlUpgradeable,\n    EIP712Upgradeable,\n    IChildToken\n{\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    /// @dev Emitted when the child chain manager changes\n    event ChildChainManagerAdded(address newAddress);\n    event ChildChainManagerRevoked(address oldAddress);\n\n    constructor() initializer {}\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address childChainManager,\n        address guardian\n    ) public initializer {\n        __ERC20_init(_name, _symbol);\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, guardian);\n        _setupRole(DEPOSITOR_ROLE, childChainManager);\n        __EIP712_init(_name, \"1\");\n    }\n\n    /**\n     * @notice Called when the bridge has tokens to mint\n     * @param user Address to mint the token to\n     * @param depositData Encoded amount to mint\n     */\n    function deposit(address user, bytes calldata depositData) external override {\n        require(hasRole(DEPOSITOR_ROLE, msg.sender));\n        uint256 amount = abi.decode(depositData, (uint256));\n        _mint(user, amount);\n    }\n\n    /**\n     * @notice Called when user wants to withdraw tokens back to root chain\n     * @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\n     * @param amount Amount of tokens to withdraw\n     */\n    function withdraw(uint256 amount) external override {\n        _burn(_msgSender(), amount);\n    }\n\n    // =============================================================================\n    // ======================= New data added for the upgrade ======================\n    // =============================================================================\n\n    mapping(address => bool) public isMinter;\n    /// @notice Reference to the treasury contract which can grant minting rights\n    address public treasury;\n    /// @notice Boolean to check whether the contract has been reinitialized after its upgrade\n    bool public treasuryInitialized;\n\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for fee computation\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    // =============================== Bridging Data ===============================\n\n    /// @notice Struct with some data about a specific bridge token\n    struct BridgeDetails {\n        // Limit on the balance of bridge token held by the contract: it is designed\n        // to reduce the exposure of the system to hacks\n        uint256 limit;\n        // Limit on the hourly volume of token minted through this bridge\n        // Technically the limit over a rolling hour is hourlyLimit x2 as hourly limit\n        // is enforced only between x:00 and x+1:00\n        uint256 hourlyLimit;\n        // Fee taken for swapping in and out the token\n        uint64 fee;\n        // Whether the associated token is allowed or not\n        bool allowed;\n        // Whether swapping in and out from the associated token is paused or not\n        bool paused;\n    }\n\n    /// @notice Maps a bridge token to data\n    mapping(address => BridgeDetails) public bridges;\n    /// @notice List of all bridge tokens\n    address[] public bridgeTokensList;\n    /// @notice Maps a bridge token to the associated hourly volume\n    mapping(address => mapping(uint256 => uint256)) public usage;\n    /// @notice Maps an address to whether it is exempt of fees for when it comes to swapping in and out\n    mapping(address => uint256) public isFeeExempt;\n\n    uint256[44] private __gap;\n\n    // ================================== Events ===================================\n\n    event BridgeTokenAdded(address indexed bridgeToken, uint256 limit, uint256 hourlyLimit, uint64 fee, bool paused);\n    event BridgeTokenToggled(address indexed bridgeToken, bool toggleStatus);\n    event BridgeTokenRemoved(address indexed bridgeToken);\n    event BridgeTokenFeeUpdated(address indexed bridgeToken, uint64 fee);\n    event BridgeTokenLimitUpdated(address indexed bridgeToken, uint256 limit);\n    event BridgeTokenHourlyLimitUpdated(address indexed bridgeToken, uint256 hourlyLimit);\n    event HourlyLimitUpdated(uint256 hourlyLimit);\n    event FeeToggled(address indexed theAddress, uint256 toggleStatus);\n    event KeeperToggled(address indexed keeper, bool toggleStatus);\n    event MinterToggled(address indexed minter);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event TreasuryUpdated(address indexed _treasury);\n\n    // ================================== Errors ===================================\n\n    error AssetStillControlledInReserves();\n    error BurnAmountExceedsAllowance();\n    error HourlyLimitExceeded();\n    error InvalidSender();\n    error InvalidToken();\n    error InvalidTreasury();\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error NotMinter();\n    error NotTreasury();\n    error TooBigAmount();\n    error TooHighParameterValue();\n    error TreasuryAlreadyInitialized();\n    error ZeroAddress();\n\n    /// @notice Checks to see if it is the `Treasury` calling this contract\n    /// @dev There is no Access Control here, because it can be handled cheaply through this modifier\n    modifier onlyTreasury() {\n        if (msg.sender != treasury) revert NotTreasury();\n        _;\n    }\n\n    /// @notice Checks whether the sender has the minting right\n    modifier onlyMinter() {\n        if (!isMinter[msg.sender]) revert NotMinter();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!ITreasury(treasury).isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!ITreasury(treasury).isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    /// @notice Sets up the treasury contract on Polygon after the upgrade\n    /// @param _treasury Address of the treasury contract\n    function setUpTreasury(address _treasury) external {\n        // Only governor on Polygon\n        if (msg.sender != 0xdA2D2f638D6fcbE306236583845e5822554c02EA) revert NotGovernor();\n        if (address(ITreasury(_treasury).stablecoin()) != address(this)) revert InvalidTreasury();\n        if (treasuryInitialized) revert TreasuryAlreadyInitialized();\n        treasury = _treasury;\n        treasuryInitialized = true;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // =========================== External Function ===============================\n\n    /// @notice Allows anyone to burn agToken without redeeming collateral back\n    /// @param amount Amount of stablecoins to burn\n    /// @dev This function can typically be called if there is a settlement mechanism to burn stablecoins\n    function burnStablecoin(uint256 amount) external {\n        _burnCustom(msg.sender, amount);\n    }\n\n    // ======================= Minter Role Only Functions ==========================\n\n    function burnSelf(uint256 amount, address burner) external onlyMinter {\n        _burnCustom(burner, amount);\n    }\n\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external onlyMinter {\n        _burnFromNoRedeem(amount, burner, sender);\n    }\n\n    function mint(address account, uint256 amount) external onlyMinter {\n        _mint(account, amount);\n    }\n\n    // ======================= Treasury Only Functions =============================\n\n    function addMinter(address minter) external onlyTreasury {\n        isMinter[minter] = true;\n        emit MinterToggled(minter);\n    }\n\n    function removeMinter(address minter) external {\n        if (msg.sender != address(treasury) && msg.sender != minter) revert InvalidSender();\n        isMinter[minter] = false;\n        emit MinterToggled(minter);\n    }\n\n    function setTreasury(address _treasury) external onlyTreasury {\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // ============================ Internal Function ==============================\n\n    /// @notice Internal version of the function `burnFromNoRedeem`\n    /// @param amount Amount to burn\n    /// @dev It is at the level of this function that allowance checks are performed\n    function _burnFromNoRedeem(\n        uint256 amount,\n        address burner,\n        address sender\n    ) internal {\n        if (burner != sender) {\n            uint256 currentAllowance = allowance(burner, sender);\n            if (currentAllowance < amount) revert BurnAmountExceedsAllowance();\n            _approve(burner, sender, currentAllowance - amount);\n        }\n        _burnCustom(burner, amount);\n    }\n\n    // ==================== External Permissionless Functions ======================\n\n    /// @notice Returns the list of all supported bridge tokens\n    /// @dev Helpful for UIs\n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridgeTokensList;\n    }\n\n    /// @notice Returns the current volume for a bridge, for the current hour\n    /// @dev Helpful for UIs\n    function currentUsage(address bridge) external view returns (uint256) {\n        return usage[bridge][block.timestamp / 3600];\n    }\n\n    /// @notice Mints the canonical token from a supported bridge token\n    /// @param bridgeToken Bridge token to use to mint\n    /// @param amount Amount of bridge tokens to send\n    /// @param to Address to which the stablecoin should be sent\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapIn(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n        uint256 balance = IERC20(bridgeToken).balanceOf(address(this));\n        if (balance + amount > bridgeDetails.limit) {\n            // In case someone maliciously sends tokens to this contract\n            // Or the limit changes\n            if (bridgeDetails.limit > balance) amount = bridgeDetails.limit - balance;\n            else {\n                amount = 0;\n            }\n        }\n\n        // Checking requirement on the hourly volume\n        uint256 hour = block.timestamp / 3600;\n        uint256 hourlyUsage = usage[bridgeToken][hour] + amount;\n        if (hourlyUsage > bridgeDetails.hourlyLimit) {\n            // Edge case when the hourly limit changes\n            if (bridgeDetails.hourlyLimit > usage[bridgeToken][hour])\n                amount = bridgeDetails.hourlyLimit - usage[bridgeToken][hour];\n            else {\n                amount = 0;\n            }\n        }\n        usage[bridgeToken][hour] = usage[bridgeToken][hour] + amount;\n\n        IERC20(bridgeToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 canonicalOut = amount;\n        // Computing fees\n        if (isFeeExempt[msg.sender] == 0) {\n            canonicalOut -= (canonicalOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        _mint(to, canonicalOut);\n        return canonicalOut;\n    }\n\n    /// @notice Burns the canonical token in exchange for a bridge token\n    /// @param bridgeToken Bridge token required\n    /// @param amount Amount of canonical tokens to burn\n    /// @param to Address to which the bridge token should be sent\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapOut(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n\n        _burnCustom(msg.sender, amount);\n        uint256 bridgeOut = amount;\n        if (isFeeExempt[msg.sender] == 0) {\n            bridgeOut -= (bridgeOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        IERC20(bridgeToken).safeTransfer(to, bridgeOut);\n        return bridgeOut;\n    }\n\n    // ======================= Governance Functions ================================\n\n    /// @notice Adds support for a bridge token\n    /// @param bridgeToken Bridge token to add: it should be a version of the stablecoin from another bridge\n    /// @param limit Limit on the balance of bridge token this contract could hold\n    /// @param hourlyLimit Limit on the hourly volume for this bridge\n    /// @param paused Whether swapping for this token should be paused or not\n    /// @param fee Fee taken upon swapping for or against this token\n    function addBridgeToken(\n        address bridgeToken,\n        uint256 limit,\n        uint256 hourlyLimit,\n        uint64 fee,\n        bool paused\n    ) external onlyGovernor {\n        if (bridges[bridgeToken].allowed || bridgeToken == address(0)) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        BridgeDetails memory _bridge;\n        _bridge.limit = limit;\n        _bridge.hourlyLimit = hourlyLimit;\n        _bridge.paused = paused;\n        _bridge.fee = fee;\n        _bridge.allowed = true;\n        bridges[bridgeToken] = _bridge;\n        bridgeTokensList.push(bridgeToken);\n        emit BridgeTokenAdded(bridgeToken, limit, hourlyLimit, fee, paused);\n    }\n\n    /// @notice Removes support for a token\n    /// @param bridgeToken Address of the bridge token to remove support for\n    function removeBridgeToken(address bridgeToken) external onlyGovernor {\n        if (IERC20(bridgeToken).balanceOf(address(this)) != 0) revert AssetStillControlledInReserves();\n        delete bridges[bridgeToken];\n        // Deletion from `bridgeTokensList` loop\n        uint256 bridgeTokensListLength = bridgeTokensList.length;\n        for (uint256 i = 0; i < bridgeTokensListLength - 1; i++) {\n            if (bridgeTokensList[i] == bridgeToken) {\n                // Replace the `bridgeToken` to remove with the last of the list\n                bridgeTokensList[i] = bridgeTokensList[bridgeTokensListLength - 1];\n                break;\n            }\n        }\n        // Remove last element in array\n        bridgeTokensList.pop();\n        emit BridgeTokenRemoved(bridgeToken);\n    }\n\n    /// @notice Recovers any ERC20 token\n    /// @dev Can be used to withdraw bridge tokens for them to be de-bridged on mainnet\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyGovernor {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Updates the `limit` amount for `bridgeToken`\n    function setLimit(address bridgeToken, uint256 limit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].limit = limit;\n        emit BridgeTokenLimitUpdated(bridgeToken, limit);\n    }\n\n    /// @notice Updates the `hourlyLimit` amount for `bridgeToken`\n    function setHourlyLimit(address bridgeToken, uint256 hourlyLimit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].hourlyLimit = hourlyLimit;\n        emit BridgeTokenHourlyLimitUpdated(bridgeToken, hourlyLimit);\n    }\n\n    /// @notice Updates the `fee` value for `bridgeToken`\n    function setSwapFee(address bridgeToken, uint64 fee) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        bridges[bridgeToken].fee = fee;\n        emit BridgeTokenFeeUpdated(bridgeToken, fee);\n    }\n\n    /// @notice Pauses or unpauses swapping in and out for a token\n    function toggleBridge(address bridgeToken) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bool pausedStatus = bridges[bridgeToken].paused;\n        bridges[bridgeToken].paused = !pausedStatus;\n        emit BridgeTokenToggled(bridgeToken, !pausedStatus);\n    }\n\n    /// @notice Toggles fees for the address `theAddress`\n    function toggleFeesForAddress(address theAddress) external onlyGovernorOrGuardian {\n        uint256 feeExemptStatus = 1 - isFeeExempt[theAddress];\n        isFeeExempt[theAddress] = feeExemptStatus;\n        emit FeeToggled(theAddress, feeExemptStatus);\n    }\n}\n"
    },
    "contracts/agToken/polygon/utils/ERC20UpgradeableCustom.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface modified by Angle Core Team\n *\n * This implementation has a custom burn function to avoid having a {Transfer} event to the zero address\n * in some specific burn cases to avoid having Polygon PoS bridge catching this event\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20UpgradeableCustom is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    //solhint-disable-next-line\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    //solhint-disable-next-line\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Contrary to the other `burn` function, the {Transfer} event is not to the zero address\n     * but rather to this address: the reason is that not all burn events should be caught up\n     * by the PoS bridge\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burnCustom(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(this), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/settlement/Settlement.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ISwapper.sol\";\nimport \"../interfaces/IVaultManager.sol\";\n\n/// @title Settlement\n/// @author Angle Core Team\n/// @notice Settlement Contract for a VaultManager\n/// @dev This settlement contract should be activated by a careful governance which needs to have performed\n/// some key operations before activating this contract\n/// @dev In case of global settlement, there should be one settlement contract per `VaultManager`\ncontract Settlement {\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_PARAMS = 10**9;\n    /// @notice Base used for interest computation\n    uint256 public constant BASE_INTEREST = 10**27;\n    /// @notice Base used for exchange rate computation. It is assumed\n    /// that stablecoins have this base\n    uint256 public constant BASE_STABLECOIN = 10**18;\n    /// @notice Duration of the claim period for over-collateralized vaults\n    uint256 public constant OVER_COLLATERALIZED_CLAIM_DURATION = 3 * 24 * 3600;\n\n    // =============== Immutable references set in the constructor =================\n\n    /// @notice `VaultManager` of this settlement contract\n    IVaultManager public immutable vaultManager;\n    /// @notice Reference to the stablecoin supported by the `VaultManager` contract\n    IAgToken public immutable stablecoin;\n    /// @notice Reference to the collateral supported by the `VaultManager`\n    IERC20 public immutable collateral;\n    /// @notice Base of the collateral\n    uint256 internal immutable _collatBase;\n\n    // ================ Variables frozen at settlement activation ==================\n\n    /// @notice Value of the oracle for the collateral/stablecoin pair\n    uint256 public oracleValue;\n    /// @notice Value of the interest accumulator at settlement activation\n    uint256 public interestAccumulator;\n    /// @notice Timestamp at which settlement was activated\n    uint256 public activationTimestamp;\n    /// @notice Collateral factor of the `VaultManager`\n    uint64 public collateralFactor;\n\n    // =================== Variables updated during the process ====================\n\n    /// @notice How much collateral you can get from stablecoins\n    uint256 public collateralStablecoinExchangeRate;\n    /// @notice Amount of collateral that will be left over at the end of the process\n    uint256 public leftOverCollateral;\n    /// @notice Whether the `collateralStablecoinExchangeRate` has been computed\n    bool public exchangeRateComputed;\n    /// @notice Maps a vault to 1 if it was claimed by its owner\n    mapping(uint256 => uint256) public vaultCheck;\n\n    // ================================ Events =====================================\n\n    event GlobalClaimPeriodActivated(uint256 _collateralStablecoinExchangeRate);\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n    event SettlementActivated(uint256 startTimestamp);\n    event VaultClaimed(uint256 vaultID, uint256 stablecoinAmount, uint256 collateralAmount);\n\n    // ================================ Errors =====================================\n\n    error GlobalClaimPeriodNotStarted();\n    error InsolventVault();\n    error NotGovernor();\n    error NotOwner();\n    error RestrictedClaimPeriodNotEnded();\n    error SettlementNotInitialized();\n    error VaultAlreadyClaimed();\n\n    /// @notice Constructor of the contract\n    /// @param _vaultManager Address of the `VaultManager` associated to this `Settlement` contract\n    /// @dev Out of safety, this constructor reads values from the `VaultManager` contract directly\n    constructor(IVaultManager _vaultManager) {\n        vaultManager = _vaultManager;\n        stablecoin = _vaultManager.stablecoin();\n        collateral = _vaultManager.collateral();\n        _collatBase = 10**(IERC20Metadata(address(collateral)).decimals());\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!(vaultManager.treasury().isGovernor(msg.sender))) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Activates the settlement contract\n    /// @dev When calling this function governance should make sure to have:\n    /// 1. Accrued the interest rate on the contract\n    /// 2. Paused the contract\n    /// 3. Recovered all the collateral available in the `VaultManager` contract either\n    /// by doing a contract upgrade or by calling a `recoverERC20` method if supported\n    function activateSettlement() external onlyGovernor {\n        oracleValue = (vaultManager.oracle()).read();\n        interestAccumulator = vaultManager.interestAccumulator();\n        activationTimestamp = block.timestamp;\n        collateralFactor = vaultManager.collateralFactor();\n        emit SettlementActivated(block.timestamp);\n    }\n\n    /// @notice Allows the owner of an over-collateralized vault to claim its collateral upon bringing back all owed stablecoins\n    /// @param vaultID ID of the vault to claim\n    /// @param to Address to which collateral should be sent\n    /// @param who Address which should be notified if needed of the transfer of stablecoins and collateral\n    /// @param data Data to pass to the `who` contract for it to successfully give the correct amount of stablecoins\n    /// to the `msg.sender` address\n    /// @return Amount of collateral sent to the `to` address\n    /// @return Amount of stablecoins sent to the contract\n    /// @dev Claiming can only happen short after settlement activation\n    /// @dev A vault cannot be claimed twice and only the owner of the vault can claim it (regardless of the approval logic)\n    /// @dev Only over-collateralized vaults can be claimed from this medium\n    function claimOverCollateralizedVault(\n        uint256 vaultID,\n        address to,\n        address who,\n        bytes memory data\n    ) external returns (uint256, uint256) {\n        if (activationTimestamp == 0 || block.timestamp > activationTimestamp + OVER_COLLATERALIZED_CLAIM_DURATION)\n            revert SettlementNotInitialized();\n        if (vaultCheck[vaultID] == 1) revert VaultAlreadyClaimed();\n        if (vaultManager.ownerOf(vaultID) != msg.sender) revert NotOwner();\n        (uint256 collateralAmount, uint256 normalizedDebt) = vaultManager.vaultData(vaultID);\n        uint256 vaultDebt = (normalizedDebt * interestAccumulator) / BASE_INTEREST;\n        if (collateralAmount * oracleValue * collateralFactor < vaultDebt * BASE_PARAMS * _collatBase)\n            revert InsolventVault();\n        vaultCheck[vaultID] = 1;\n        emit VaultClaimed(vaultID, vaultDebt, collateralAmount);\n        return _handleRepay(collateralAmount, vaultDebt, to, who, data);\n    }\n\n    /// @notice Activates the global claim period by setting the `collateralStablecoinExchangeRate` which is going to\n    /// dictate how much of collateral will be recoverable for each stablecoin\n    /// @dev This function can only be called by the governor in order to allow it in case multiple settlements happen across\n    /// different `VaultManager` to rebalance the amount of stablecoins on each to make sure that across all settlement contracts\n    /// a similar value of collateral can be obtained against a similar value of stablecoins\n    function activateGlobalClaimPeriod() external onlyGovernor {\n        if (activationTimestamp == 0 || block.timestamp <= activationTimestamp + OVER_COLLATERALIZED_CLAIM_DURATION)\n            revert RestrictedClaimPeriodNotEnded();\n        uint256 collateralBalance = collateral.balanceOf(address(this));\n        uint256 leftOverDebt = (vaultManager.totalNormalizedDebt() * interestAccumulator) / BASE_INTEREST;\n        uint256 stablecoinBalance = stablecoin.balanceOf(address(this));\n        // How much 1 of stablecoin will give you in collateral\n        uint256 _collateralStablecoinExchangeRate;\n\n        if (stablecoinBalance < leftOverDebt) {\n            // The left over debt is the total debt minus the stablecoins which have already been accumulated\n            // in the first phase\n            leftOverDebt -= stablecoinBalance;\n            // If you control all the debt, then you are entitled to get all the collateral left in the protocol\n            _collateralStablecoinExchangeRate = (collateralBalance * BASE_STABLECOIN) / leftOverDebt;\n            // But at the same time, you cannot get more collateral than the value of the stablecoins you brought\n            uint256 maxExchangeRate = (BASE_STABLECOIN * _collatBase) / oracleValue;\n            if (_collateralStablecoinExchangeRate >= maxExchangeRate) {\n                // In this situation, we're sure that `leftOverCollateral` will be positive: governance should be wary\n                // to call `recoverERC20` short after though as there's nothing that is going to prevent people to redeem\n                // more stablecoins than the `leftOverDebt`\n                leftOverCollateral = collateralBalance - (leftOverDebt * _collatBase) / oracleValue;\n                _collateralStablecoinExchangeRate = maxExchangeRate;\n            }\n        }\n        exchangeRateComputed = true;\n        // In the else case where there is no debt left, you cannot get anything from your stablecoins\n        // and so the `collateralStablecoinExchangeRate` is null\n        collateralStablecoinExchangeRate = _collateralStablecoinExchangeRate;\n        emit GlobalClaimPeriodActivated(_collateralStablecoinExchangeRate);\n    }\n\n    /// @notice Allows to claim collateral from stablecoins\n    /// @param to Address to which collateral should be sent\n    /// @param who Address which should be notified if needed of the transfer of stablecoins and collateral\n    /// @param data Data to pass to the `who` contract for it to successfully give the correct amount of stablecoins\n    /// to the `msg.sender` address\n    /// @return Amount of collateral sent to the `to` address\n    /// @return Amount of stablecoins sent to the contract\n    /// @dev This function reverts if the `collateralStablecoinExchangeRate` is null and hence if the global claim period has\n    /// not been activated\n    function claimCollateralFromStablecoins(\n        uint256 stablecoinAmount,\n        address to,\n        address who,\n        bytes memory data\n    ) external returns (uint256, uint256) {\n        if (!exchangeRateComputed) revert GlobalClaimPeriodNotStarted();\n        return\n            _handleRepay(\n                (stablecoinAmount * collateralStablecoinExchangeRate) / BASE_STABLECOIN,\n                stablecoinAmount,\n                to,\n                who,\n                data\n            );\n    }\n\n    /// @notice Handles the simultaneous repayment of stablecoins with a transfer of collateral\n    /// @param collateralAmountToGive Amount of collateral the contract should give\n    /// @param stableAmountToRepay Amount of stablecoins the contract should burn from the call\n    /// @param to Address to which stablecoins should be sent\n    /// @param who Address which should be notified if needed of the transfer\n    /// @param data Data to pass to the `who` contract for it to successfully give the correct amount of stablecoins\n    /// to the `msg.sender` address\n    /// @dev This function allows for capital-efficient claims of collateral from stablecoins\n    function _handleRepay(\n        uint256 collateralAmountToGive,\n        uint256 stableAmountToRepay,\n        address to,\n        address who,\n        bytes memory data\n    ) internal returns (uint256, uint256) {\n        collateral.safeTransfer(to, collateralAmountToGive);\n        if (data.length > 0) {\n            ISwapper(who).swap(\n                collateral,\n                IERC20(address(stablecoin)),\n                msg.sender,\n                stableAmountToRepay,\n                collateralAmountToGive,\n                data\n            );\n        }\n        stablecoin.transferFrom(msg.sender, address(this), stableAmountToRepay);\n        return (collateralAmountToGive, stableAmountToRepay);\n    }\n\n    /// @notice Recovers leftover tokens from the contract or tokens that were mistakenly sent to the contract\n    /// @param tokenAddress Address of the token to recover\n    /// @param to Address to send the remaining tokens to\n    /// @param amountToRecover Amount to recover from the contract\n    /// @dev Governors cannot recover more collateral than what would be leftover from the contract\n    /// @dev This function can be used to rebalance stablecoin balances across different settlement contracts\n    /// to make sure every stablecoin can be redeemed for the same value of collateral\n    /// @dev It can also be used to recover tokens that are mistakenly sent to this contract\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyGovernor {\n        if (tokenAddress == address(collateral)) {\n            if (!exchangeRateComputed) revert GlobalClaimPeriodNotStarted();\n            leftOverCollateral -= amountToRecover;\n            collateral.safeTransfer(to, amountToRecover);\n        } else {\n            IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        }\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n}\n"
    },
    "contracts/swapper/SwapperSidechain.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IAngleRouterSidechain.sol\";\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/ISwapper.sol\";\nimport \"../interfaces/external/lido/IWStETH.sol\";\nimport \"../interfaces/external/uniswap/IUniswapRouter.sol\";\n\n/// @title SwapperSidechain\n/// @author Angle Core Team\n/// @notice Swapper contract facilitating interactions with the VaultManager: to liquidate and get leverage\ncontract SwapperSidechain is ISwapper {\n    using SafeERC20 for IERC20;\n\n    // ================ Constants and Immutable Variables ==========================\n\n    /// @notice Reference to the `CoreBorrow` contract of the module which handles all AccessControl logic\n    ICoreBorrow public immutable core;\n    /// @notice Uniswap Router contract\n    IUniswapV3Router public immutable uniV3Router;\n    /// @notice 1Inch Router\n    address public immutable oneInch;\n    /// @notice AngleRouter\n    IAngleRouterSidechain public immutable angleRouter;\n\n    // ================================== Enum =====================================\n\n    /// @notice All possible swaps\n    enum SwapType {\n        UniswapV3,\n        oneInch,\n        AngleRouter,\n        None\n    }\n\n    // ================================== Errors ===================================\n\n    error EmptyReturnMessage();\n    error IncompatibleLengths();\n    error NotGovernorOrGuardian();\n    error TooSmallAmountOut();\n    error ZeroAddress();\n\n    /// @notice Constructor of the contract\n    /// @param _core Core address\n    /// @param _uniV3Router UniswapV3 Router address\n    /// @param _oneInch 1Inch Router address\n    /// @param _angleRouter AngleRouter contract address\n    constructor(\n        ICoreBorrow _core,\n        IUniswapV3Router _uniV3Router,\n        address _oneInch,\n        IAngleRouterSidechain _angleRouter\n    ) {\n        if (\n            address(_core) == address(0) ||\n            address(_uniV3Router) == address(0) ||\n            _oneInch == address(0) ||\n            address(_angleRouter) == address(0)\n        ) revert ZeroAddress();\n        core = _core;\n        uniV3Router = _uniV3Router;\n        oneInch = _oneInch;\n        angleRouter = _angleRouter;\n    }\n\n    // ======================= External Access Function ============================\n\n    /// @inheritdoc ISwapper\n    /// @dev This function swaps the `inToken` to the `outToken` by doing a UniV3 swap, a 1Inch swap or by interacting\n    /// with the `AngleRouter` contract\n    /// @dev One slippage check is performed at the end of the call\n    /// @dev In this implementation, the function tries to make sure that the `outTokenRecipient` address has at the end\n    /// of the call `outTokenOwed`, leftover tokens are sent to a `to` address which by default is the `outTokenRecipient`\n    function swap(\n        IERC20 inToken,\n        IERC20 outToken,\n        address outTokenRecipient,\n        uint256 outTokenOwed,\n        uint256 inTokenObtained,\n        bytes memory data\n    ) external {\n        // Address to receive the surplus amount of token at the end of the call\n        address to;\n        // For slippage protection, it is checked at the end of the call\n        uint256 minAmountOut;\n        // Type of the swap to execute: if `swapType == 3`, then it is optional to swap\n        uint128 swapType;\n        // We're reusing the `data` variable (it can be `path` on UniswapV3, a payload for 1Inch or like encoded actions\n        // for a router call)\n        (to, minAmountOut, swapType, data) = abi.decode(data, (address, uint256, uint128, bytes));\n\n        to = (to == address(0)) ? outTokenRecipient : to;\n\n        _swap(inToken, inTokenObtained, SwapType(swapType), data);\n\n        // A final slippage check is performed after the swaps\n        uint256 outTokenBalance = outToken.balanceOf(address(this));\n        if (outTokenBalance < minAmountOut) revert TooSmallAmountOut();\n\n        // The `outTokenRecipient` may already have enough in balance, in which case there's no need to transfer\n        // this address the token and everything can be given already to the `to` address\n        uint256 outTokenBalanceRecipient = outToken.balanceOf(outTokenRecipient);\n        if (outTokenBalanceRecipient >= outTokenOwed || to == outTokenRecipient)\n            outToken.safeTransfer(to, outTokenBalance);\n        else {\n            // The `outTokenRecipient` should receive the delta to make sure its end balance is equal to `outTokenOwed`\n            // Any leftover in this case is sent to the `to` address\n            // The function reverts if it did not obtain more than `outTokenOwed - outTokenBalanceRecipient` from the swap\n            outToken.safeTransfer(outTokenRecipient, outTokenOwed - outTokenBalanceRecipient);\n            outToken.safeTransfer(to, outTokenBalanceRecipient + outTokenBalance - outTokenOwed);\n        }\n        // Reusing the `inTokenObtained` variable for the `inToken` balance\n        // Sending back the remaining amount of inTokens to the `to` address: it is possible that not the full `inTokenObtained`\n        // is swapped to `outToken` if we're using the `1Inch` payload\n        inTokenObtained = inToken.balanceOf(address(this));\n        if (inTokenObtained > 0) inToken.safeTransfer(to, inTokenObtained);\n    }\n\n    // ========================= Governance Function ===============================\n\n    /// @notice Changes allowances of this contract for different tokens\n    /// @param tokens Addresses of the tokens to allow\n    /// @param spenders Addresses to allow transfer\n    /// @param amounts Amounts to allow\n    function changeAllowance(\n        IERC20[] calldata tokens,\n        address[] calldata spenders,\n        uint256[] calldata amounts\n    ) external {\n        if (!core.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        if (tokens.length != spenders.length || tokens.length != amounts.length) revert IncompatibleLengths();\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _changeAllowance(tokens[i], spenders[i], amounts[i]);\n        }\n    }\n\n    // ======================= Internal Utility Functions ==========================\n\n    /// @notice Internal version of the `_changeAllowance` function\n    function _changeAllowance(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 currentAllowance = token.allowance(address(this), spender);\n        if (currentAllowance < amount) {\n            token.safeIncreaseAllowance(spender, amount - currentAllowance);\n        } else if (currentAllowance > amount) {\n            token.safeDecreaseAllowance(spender, currentAllowance - amount);\n        }\n    }\n\n    /// @notice Checks the allowance for a contract and updates it to the max if it is not big enough\n    /// @param token Token for which allowance should be checked\n    /// @param spender Address to grant allowance to\n    /// @param amount Minimum amount of tokens needed for the allowance\n    function _checkAllowance(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 currentAllowance = token.allowance(address(this), spender);\n        if (currentAllowance < amount) token.safeIncreaseAllowance(spender, type(uint256).max - currentAllowance);\n    }\n\n    /// @notice Performs a swap using either Uniswap, 1Inch. This function can also stake stETH to wstETH\n    /// @param inToken Token to swap\n    /// @param amount Amount of tokens to swap\n    /// @param swapType Type of the swap to perform\n    /// @param args Extra args for the swap: in the case of Uniswap it should be a path, for 1Inch it should be\n    /// a payload\n    /// @dev This function does nothing if `swapType` is None and it simply passes on the `amount` it received\n    function _swap(\n        IERC20 inToken,\n        uint256 amount,\n        SwapType swapType,\n        bytes memory args\n    ) internal {\n        if (swapType == SwapType.UniswapV3) _swapOnUniswapV3(inToken, amount, args);\n        else if (swapType == SwapType.oneInch) _swapOn1Inch(inToken, args);\n        else if (swapType == SwapType.AngleRouter) _angleRouterActions(inToken, args);\n    }\n\n    /// @notice Performs a UniswapV3 swap\n    /// @param inToken Token to swap\n    /// @param amount Amount of tokens to swap\n    /// @param path Path for the UniswapV3 swap: this encodes the out token that is going to be obtained\n    /// @dev We don't specify a slippage here as in the `swap` function a final slippage check\n    /// is performed at the end\n    /// @dev This function does not check the out token obtained here: if it is wrongly specified, either\n    /// the `swap` function could fail or these tokens could stay on the contract\n    function _swapOnUniswapV3(\n        IERC20 inToken,\n        uint256 amount,\n        bytes memory path\n    ) internal returns (uint256 amountOut) {\n        // We need more than `amount` of allowance to the contract\n        _checkAllowance(inToken, address(uniV3Router), amount);\n        amountOut = uniV3Router.exactInput(ExactInputParams(path, address(this), block.timestamp, amount, 0));\n    }\n\n    /// @notice Allows to swap any token to an accepted collateral via 1Inch API\n    /// @param inToken Token received for the 1Inch swap\n    /// @param payload Bytes needed for 1Inch API\n    /// @dev Here again, we don't specify a slippage here as in the `swap` function a final slippage check\n    /// is performed at the end\n    function _swapOn1Inch(IERC20 inToken, bytes memory payload) internal returns (uint256 amountOut) {\n        _changeAllowance(inToken, oneInch, type(uint256).max);\n        //solhint-disable-next-line\n        (bool success, bytes memory result) = oneInch.call(payload);\n        if (!success) _revertBytes(result);\n        amountOut = abi.decode(result, (uint256));\n    }\n\n    /// @notice Performs actions with the router contract of the protocol on the corresponding chain\n    /// @param inToken Token concerned by the action and for which\n    function _angleRouterActions(IERC20 inToken, bytes memory args) internal {\n        (ActionType[] memory actions, bytes[] memory actionData) = abi.decode(args, (ActionType[], bytes[]));\n        _changeAllowance(inToken, address(angleRouter), type(uint256).max);\n        PermitType[] memory permits;\n        angleRouter.mixer(permits, actions, actionData);\n    }\n\n    /// @notice Internal function used for error handling\n    /// @param errMsg Error message received\n    function _revertBytes(bytes memory errMsg) internal pure {\n        if (errMsg.length > 0) {\n            //solhint-disable-next-line\n            assembly {\n                revert(add(32, errMsg), mload(errMsg))\n            }\n        }\n        revert EmptyReturnMessage();\n    }\n}\n"
    },
    "contracts/interfaces/IAngleRouterSidechain.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @notice Action types\nenum ActionType {\n    transfer,\n    wrap,\n    wrapNative,\n    sweep,\n    sweepNative,\n    unwrap,\n    unwrapNative,\n    swapIn,\n    swapOut,\n    uniswapV3,\n    oneInch,\n    claimRewards,\n    gaugeDeposit,\n    borrower\n}\n\n/// @notice Data needed to get permits\nstruct PermitType {\n    address token;\n    address owner;\n    uint256 value;\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\n/// @title IAngleRouterSidechain\n/// @author Angle Core Team\n/// @notice Interface for the `AngleRouter` contract on other chains\ninterface IAngleRouterSidechain {\n    function mixer(\n        PermitType[] memory paramsPermit,\n        ActionType[] memory actions,\n        bytes[] calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/external/lido/IWStETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title IWStETH\n/// @author Angle Core Team\n/// @notice Interface for the `WStETH` contract\n/// @dev This interface only contains functions of the `WStETH` which are called by other contracts\n/// of this module\ninterface IWStETH {\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n\n    function stETH() external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/uniswap/IUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nstruct ExactInputParams {\n    bytes path;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n}\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface IUniswapV3Router {\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n}\n\n/// @title Router for price estimation functionality\n/// @notice Functions for getting the price of one token with respect to another using Uniswap V2\n/// @dev This interface is only used for non critical elements of the protocol\ninterface IUniswapV2Router {\n    /// @notice Given an input asset amount, returns the maximum output amount of the\n    /// other asset (accounting for fees) given reserves.\n    /// @param path Addresses of the pools used to get prices\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokens(\n        uint256 swapAmount,\n        uint256 minExpected,\n        address[] calldata path,\n        address receiver,\n        uint256 swapDeadline\n    ) external;\n}\n"
    },
    "contracts/swapper/Swapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IAngleRouter.sol\";\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/ISwapper.sol\";\nimport \"../interfaces/external/lido/IWStETH.sol\";\nimport \"../interfaces/external/uniswap/IUniswapRouter.sol\";\n\n/// @title Swapper\n/// @author Angle Core Team\n/// @notice Swapper contract facilitating interactions with the VaultManager: to liquidate and get leverage\ncontract Swapper is ISwapper {\n    using SafeERC20 for IERC20;\n\n    // ================ Constants and Immutable Variables ==========================\n\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_PARAMS = 10**9;\n    /// @notice AngleRouter\n    IAngleRouter public immutable angleRouter;\n    /// @notice Reference to the `CoreBorrow` contract of the module which handles all AccessControl logic\n    ICoreBorrow public immutable core;\n    /// @notice Wrapped StETH contract\n    IWStETH public immutable wStETH;\n    /// @notice Uniswap Router contract\n    IUniswapV3Router public immutable uniV3Router;\n    /// @notice 1Inch Router\n    address public immutable oneInch;\n\n    // =============================== Mappings ====================================\n\n    /// @notice Whether the token was already approved on Uniswap router\n    mapping(IERC20 => bool) public uniAllowedToken;\n    /// @notice Whether the token was already approved on 1Inch\n    mapping(IERC20 => bool) public oneInchAllowedToken;\n    /// @notice Whether the token was already approved on AngleRouter\n    mapping(IERC20 => bool) public angleRouterAllowedToken;\n\n    // ================================== Enum =====================================\n\n    /// @notice All possible swaps\n    enum SwapType {\n        UniswapV3,\n        oneInch,\n        Wrap,\n        None\n    }\n\n    // ================================== Errors ===================================\n\n    error EmptyReturnMessage();\n    error IncompatibleLengths();\n    error NotGovernorOrGuardian();\n    error TooSmallAmount();\n    error ZeroAddress();\n\n    /// @notice Constructor of the contract\n    /// @param _core Core address\n    /// @param _wStETH wStETH Address\n    /// @param _uniV3Router UniswapV3 Router address\n    /// @param _oneInch 1Inch Router address\n    /// @param _angleRouter Address of the AngleRouter contract\n    constructor(\n        ICoreBorrow _core,\n        IWStETH _wStETH,\n        IUniswapV3Router _uniV3Router,\n        address _oneInch,\n        IAngleRouter _angleRouter\n    ) {\n        if (\n            address(_core) == address(0) ||\n            address(_uniV3Router) == address(0) ||\n            _oneInch == address(0) ||\n            address(_angleRouter) == address(0)\n        ) revert ZeroAddress();\n        core = _core;\n        IERC20 stETH = IERC20(_wStETH.stETH());\n        stETH.safeApprove(address(_wStETH), type(uint256).max);\n        wStETH = _wStETH;\n        uniV3Router = _uniV3Router;\n        oneInch = _oneInch;\n        angleRouter = _angleRouter;\n    }\n\n    receive() external payable {}\n\n    // ======================= External Access Function ============================\n\n    /// @inheritdoc ISwapper\n    /// @dev This function swaps the `inToken` to the `outToken` by either doing mint, or burn from the protocol\n    /// or/and combining it with a UniV3 or 1Inch swap\n    /// @dev No slippage checks are performed at the end of each operation, only one slippage check is performed\n    /// at the end of the call\n    /// @dev In this implementation, the function tries to make sure that the `outTokenRecipient` address has at the end\n    /// of the call `outTokenOwed`, leftover tokens are sent to a `to` address which by default is the `outTokenRecipient`\n    function swap(\n        IERC20 inToken,\n        IERC20 outToken,\n        address outTokenRecipient,\n        uint256 outTokenOwed,\n        uint256 inTokenObtained,\n        bytes memory data\n    ) external {\n        // Optional address that can be given to specify in case of a burn the address of the collateral\n        // to get in exchange for the stablecoin or in case of a mint the collateral used to mint\n        address intermediateToken;\n        // Address to receive the surplus amount of token at the end of the call\n        address to;\n        // For slippage protection, it is checked at the end of the call\n        uint256 minAmountOut;\n        // Type of the swap to execute: if `swapType == 3`, then it is optional to swap\n        uint128 swapType;\n        // Whether a `mint` or `burn` operation should be performed beyond the swap: 1 corresponds\n        // to a burn and 2 to a mint. It is optional. If the value is set to 1 or 2 then the value of the\n        // `intermediateToken` should be made non null\n        uint128 mintOrBurn;\n        // We're reusing the `data` variable (it's now either a `path` on UniswapV3 or a payload for 1Inch)\n        (intermediateToken, to, minAmountOut, swapType, mintOrBurn, data) = abi.decode(\n            data,\n            (address, address, uint256, uint128, uint128, bytes)\n        );\n\n        to = (to == address(0)) ? outTokenRecipient : to;\n\n        if (mintOrBurn == 1) {\n            // First performing burn transactions as you may usually get stablecoins first\n            _checkAngleRouterAllowance(inToken);\n            // In this case there cannot be any leftover `inToken`\n            angleRouter.burn(address(this), inTokenObtained, 0, address(inToken), intermediateToken);\n            inToken = IERC20(intermediateToken);\n            inTokenObtained = inToken.balanceOf(address(this));\n        }\n        // Reusing the `inTokenObtained` variable\n        inTokenObtained = _swap(inToken, inTokenObtained, SwapType(swapType), data);\n\n        if (mintOrBurn == 2) {\n            // Mint transaction is performed last as if you're trying to get stablecoins, it should be the last operation\n            _checkAngleRouterAllowance(IERC20(intermediateToken));\n            angleRouter.mint(address(this), inTokenObtained, 0, address(outToken), intermediateToken);\n        }\n\n        // A final slippage check is performed after the swaps\n        uint256 outTokenBalance = outToken.balanceOf(address(this));\n        if (outTokenBalance <= minAmountOut) revert TooSmallAmount();\n\n        // The `outTokenRecipient` may already have enough in balance, in which case there's no need to transfer\n        // this address the token and everything can be given already to the `to` address\n        uint256 outTokenBalanceRecipient = outToken.balanceOf(outTokenRecipient);\n        if (outTokenBalanceRecipient >= outTokenOwed || to == outTokenRecipient)\n            outToken.safeTransfer(to, outTokenBalance);\n        else {\n            // The `outTokenRecipient` should receive the delta to make sure its end balance is equal to `outTokenOwed`\n            // Any leftover in this case is sent to the `to` address\n            // The function reverts if it did not obtain more than `outTokenOwed - outTokenBalanceRecipient` from the swap\n            outToken.safeTransfer(outTokenRecipient, outTokenOwed - outTokenBalanceRecipient);\n            outToken.safeTransfer(to, outTokenBalanceRecipient + outTokenBalance - outTokenOwed);\n        }\n        // Reusing the `inTokenObtained` variable for the `inToken` balance\n        // Sending back the remaining amount of inTokens to the `to` address: it is possible that not the full `inTokenObtained`\n        // is swapped to `outToken` if we're using the `1Inch` payload\n        // If there has been a burn, the whole `inToken` balance is burnt, but in this case the `inToken` variable has the\n        // `intermediateToken` reference and what is sent back to the `to` address is the leftover balance of this token\n        inTokenObtained = inToken.balanceOf(address(this));\n        if (inTokenObtained > 0) inToken.safeTransfer(to, inTokenObtained);\n    }\n\n    // ========================= Governance Function ===============================\n\n    /// @notice Changes allowance for a contract\n    /// @param tokens Addresses of the tokens to allow\n    /// @param spenders Addresses to allow transfer\n    /// @param amounts Amounts to allow\n    function changeAllowance(\n        IERC20[] calldata tokens,\n        address[] calldata spenders,\n        uint256[] calldata amounts\n    ) external {\n        if (!core.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        if (tokens.length != spenders.length || tokens.length != amounts.length) revert IncompatibleLengths();\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _changeAllowance(tokens[i], spenders[i], amounts[i]);\n        }\n    }\n\n    // ======================= Internal Utility Functions ==========================\n\n    /// @notice Internal version of the `_changeAllowance` function\n    function _changeAllowance(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 currentAllowance = token.allowance(address(this), spender);\n        if (currentAllowance < amount) {\n            token.safeIncreaseAllowance(spender, amount - currentAllowance);\n        } else if (currentAllowance > amount) {\n            token.safeDecreaseAllowance(spender, currentAllowance - amount);\n            // Clean mappings if allowance decreases for Uniswap, 1Inch or Angle routers\n            if (spender == address(uniV3Router)) delete uniAllowedToken[token];\n            else if (spender == oneInch) delete oneInchAllowedToken[token];\n            else if (spender == address(angleRouter)) delete angleRouterAllowedToken[token];\n        }\n    }\n\n    /// @notice Performs a swap using either Uniswap, 1Inch. This function can also stake stETH to wstETH\n    /// @param inToken Token to swap\n    /// @param amount Amount of tokens to swap\n    /// @param swapType Type of the swap to perform\n    /// @param args Extra args for the swap: in the case of Uniswap it should be a path, for 1Inch it should be\n    /// a payload\n    /// @dev If `swapType` is a wrap, then the `inToken` should be `stETH` otherwise the function will revert\n    /// @dev This function does nothing if `swapType` is None and it simply passes on the `amount` it received\n    function _swap(\n        IERC20 inToken,\n        uint256 amount,\n        SwapType swapType,\n        bytes memory args\n    ) internal returns (uint256 amountOut) {\n        if (swapType == SwapType.UniswapV3) amountOut = _swapOnUniswapV3(inToken, amount, args);\n        else if (swapType == SwapType.oneInch) amountOut = _swapOn1Inch(inToken, args);\n        else if (swapType == SwapType.Wrap) amountOut = wStETH.wrap(amount);\n        else amountOut = amount;\n    }\n\n    /// @notice Checks whether a the AngleRouter was given approval for a token and if yes approves\n    /// this token\n    /// @param token Token for which the approval to the `AngleRouter` should be checked\n    function _checkAngleRouterAllowance(IERC20 token) internal {\n        if (!angleRouterAllowedToken[token]) {\n            _changeAllowance(token, address(angleRouter), type(uint256).max);\n            angleRouterAllowedToken[token] = true;\n        }\n    }\n\n    /// @notice Performs a UniswapV3 swap\n    /// @param inToken Token to swap\n    /// @param amount Amount of tokens to swap\n    /// @param path Path for the UniswapV3 swap: this encodes the out token that is going to be obtained\n    /// @dev We don't specify a slippage here as in the `swap` function a final slippage check\n    /// is performed at the end\n    /// @dev This function does not check the out token obtained here: if it is wrongly specified, either\n    /// the `swap` function could fail or these tokens could stay on the contract\n    function _swapOnUniswapV3(\n        IERC20 inToken,\n        uint256 amount,\n        bytes memory path\n    ) internal returns (uint256 amountOut) {\n        // Approve transfer to the `uniswapV3Router` if it is the first time that the token is used\n        if (!uniAllowedToken[inToken]) {\n            _changeAllowance(inToken, address(uniV3Router), type(uint256).max);\n            uniAllowedToken[inToken] = true;\n        }\n        amountOut = uniV3Router.exactInput(ExactInputParams(path, address(this), block.timestamp, amount, 0));\n    }\n\n    /// @notice Allows to swap any token to an accepted collateral via 1Inch API\n    /// @param inToken Token received for the 1Inch swap\n    /// @param payload Bytes needed for 1Inch API\n    /// @dev Here again, we don't specify a slippage here as in the `swap` function a final slippage check\n    /// is performed at the end\n    function _swapOn1Inch(IERC20 inToken, bytes memory payload) internal returns (uint256 amountOut) {\n        // Approve transfer to the `oneInch` router if it is the first time the token is used\n        if (!oneInchAllowedToken[inToken]) {\n            _changeAllowance(inToken, oneInch, type(uint256).max);\n            oneInchAllowedToken[inToken] = true;\n        }\n\n        //solhint-disable-next-line\n        (bool success, bytes memory result) = oneInch.call(payload);\n        if (!success) _revertBytes(result);\n\n        amountOut = abi.decode(result, (uint256));\n    }\n\n    /// @notice Internal function used for error handling\n    /// @param errMsg Error message received\n    function _revertBytes(bytes memory errMsg) internal pure {\n        if (errMsg.length > 0) {\n            //solhint-disable-next-line\n            assembly {\n                revert(add(32, errMsg), mload(errMsg))\n            }\n        }\n        revert EmptyReturnMessage();\n    }\n}\n"
    },
    "contracts/interfaces/IAngleRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title IAngleRouter\n/// @author Angle Core Team\n/// @notice Interface for the `AngleRouter` contract\n/// @dev This interface only contains functions of the `AngleRouter01` contract which are called by other contracts\n/// of this module\ninterface IAngleRouter {\n    function mint(\n        address user,\n        uint256 amount,\n        uint256 minStableAmount,\n        address stablecoin,\n        address collateral\n    ) external;\n\n    function burn(\n        address user,\n        uint256 amount,\n        uint256 minAmountOut,\n        address stablecoin,\n        address collateral\n    ) external;\n}\n"
    },
    "contracts/mock/MockRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IAngleRouter.sol\";\nimport \"../interfaces/external/uniswap/IUniswapRouter.sol\";\nimport \"../interfaces/external/lido/IWStETH.sol\";\n\ncontract MockRouter is IAngleRouter, IUniswapV3Router, IWStETH {\n    using SafeERC20 for IERC20;\n\n    uint256 public counterAngleMint;\n    uint256 public counterAngleBurn;\n    uint256 public counter1Inch;\n    uint256 public counterUni;\n    uint256 public counterWrap;\n    uint256 public counterMixer;\n    uint256 public amountOutUni;\n    uint256 public multiplierMintBurn;\n    uint256 public stETHMultiplier;\n    address public inToken;\n    address public outToken;\n\n    address public stETH;\n\n    /// @notice Action types\n    enum ActionType {\n        transfer,\n        wrap,\n        wrapNative,\n        sweep,\n        sweepNative,\n        unwrap,\n        unwrapNative,\n        swapIn,\n        swapOut,\n        uniswapV3,\n        oneInch,\n        claimRewards,\n        gaugeDeposit,\n        borrower\n    }\n\n    /// @notice Data needed to get permits\n    struct PermitType {\n        address token;\n        address owner;\n        uint256 value;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    constructor() {}\n\n    function mint(\n        address user,\n        uint256 amount,\n        uint256,\n        address stablecoin,\n        address collateral\n    ) external {\n        counterAngleMint += 1;\n        IERC20(collateral).safeTransferFrom(msg.sender, address(this), amount);\n        IERC20(stablecoin).safeTransfer(user, (amount * 10**9) / multiplierMintBurn);\n    }\n\n    function setStETH(address _stETH) external {\n        stETH = _stETH;\n    }\n\n    function burn(\n        address user,\n        uint256 amount,\n        uint256,\n        address stablecoin,\n        address collateral\n    ) external {\n        counterAngleBurn += 1;\n        IERC20(stablecoin).safeTransferFrom(msg.sender, address(this), amount);\n        IERC20(collateral).safeTransfer(user, (amount * multiplierMintBurn) / 10**9);\n    }\n\n    function mixer(\n        PermitType[] memory paramsPermit,\n        ActionType[] memory actions,\n        bytes[] calldata data\n    ) public payable virtual {\n        paramsPermit;\n        counterMixer += 1;\n        for (uint256 i = 0; i < actions.length; i++) {\n            if (actions[i] == ActionType.transfer) {\n                (address transferToken, uint256 amount) = abi.decode(data[i], (address, uint256));\n                IERC20(transferToken).safeTransferFrom(msg.sender, address(this), amount);\n            }\n        }\n    }\n\n    function wrap(uint256 amount) external returns (uint256 amountOut) {\n        amountOut = (amount * stETHMultiplier) / 10**9;\n        counterWrap += 1;\n        IERC20(stETH).safeTransferFrom(msg.sender, address(this), amount);\n        IERC20(outToken).safeTransfer(msg.sender, amountOut);\n    }\n\n    function oneInch(uint256 amountIn) external returns (uint256 amountOut) {\n        counter1Inch += 1;\n        amountOut = (amountOutUni * amountIn) / 10**9;\n        IERC20(inToken).safeTransferFrom(msg.sender, address(this), amountIn);\n        IERC20(outToken).safeTransfer(msg.sender, amountOut);\n    }\n\n    function oneInchReverts() external {\n        counter1Inch += 1;\n        revert(\"wrong swap\");\n    }\n\n    function oneInchRevertsWithoutMessage() external {\n        counter1Inch += 1;\n        require(false);\n    }\n\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut) {\n        counterUni += 1;\n        amountOut = (params.amountIn * amountOutUni) / 10**9;\n        IERC20(inToken).safeTransferFrom(msg.sender, address(this), params.amountIn);\n        IERC20(outToken).safeTransfer(params.recipient, amountOut);\n        require(amountOut >= params.amountOutMinimum);\n    }\n\n    function setMultipliers(uint256 a, uint256 b) external {\n        amountOutUni = a;\n        multiplierMintBurn = b;\n    }\n\n    function setStETHMultiplier(uint256 value) external {\n        stETHMultiplier = value;\n    }\n\n    function setInOut(address _collateral, address _stablecoin) external {\n        inToken = _collateral;\n        outToken = _stablecoin;\n    }\n}\n"
    },
    "contracts/mock/MockTokenPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract MockTokenPermit is ERC20Permit {\n    using SafeERC20 for IERC20;\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    uint8 internal _decimal;\n    mapping(address => bool) public minters;\n    address public treasury;\n    uint256 public fees;\n\n    bool public reverts;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) ERC20Permit(name_) ERC20(name_, symbol_) {\n        _decimal = decimal_;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimal;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function setAllowance(address from, address to) public {\n        _approve(from, to, type(uint256).max);\n    }\n\n    function burnSelf(uint256 amount, address account) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function addMinter(address minter) public {\n        minters[minter] = true;\n    }\n\n    function removeMinter(address minter) public {\n        minters[minter] = false;\n    }\n\n    function setTreasury(address _treasury) public {\n        treasury = _treasury;\n    }\n\n    function setFees(uint256 _fees) public {\n        fees = _fees;\n    }\n\n    function recoverERC20(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) external {\n        token.safeTransfer(to, amount);\n    }\n\n    function swapIn(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        require(!reverts);\n\n        IERC20(bridgeToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 canonicalOut = amount;\n        canonicalOut -= (canonicalOut * fees) / 10**9;\n        _mint(to, canonicalOut);\n        return canonicalOut;\n    }\n\n    function swapOut(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        require(!reverts);\n        _burn(msg.sender, amount);\n        uint256 bridgeOut = amount;\n        bridgeOut -= (bridgeOut * fees) / 10**9;\n        IERC20(bridgeToken).safeTransfer(to, bridgeOut);\n        return bridgeOut;\n    }\n}\n"
    },
    "contracts/mock/MockSwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/ISwapper.sol\";\n\ncontract MockSwapper is ISwapper {\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    uint256 public counter;\n\n    constructor() {}\n\n    function swap(\n        IERC20,\n        IERC20,\n        address,\n        uint256,\n        uint256,\n        bytes calldata data\n    ) external {\n        counter += 1;\n        data;\n    }\n}\n\ncontract MockSwapperWithSwap is ISwapper {\n    using SafeERC20 for IERC20;\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    uint256 public counter;\n\n    constructor() {}\n\n    function swap(\n        IERC20,\n        IERC20 outToken,\n        address outTokenRecipient,\n        uint256 outTokenOwed,\n        uint256,\n        bytes calldata data\n    ) external {\n        counter += 1;\n        outToken.safeTransfer(outTokenRecipient, outTokenOwed);\n\n        data;\n    }\n}\n"
    },
    "contracts/mock/MockKeeperMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract MockKeeperMulticall is Initializable, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    //solhint-disable-next-line\n    address private constant _oneInch = 0x1111111254fb6c44bAC0beD2854e76F90643097d;\n\n    struct Action {\n        address target;\n        bytes data;\n        bool isDelegateCall;\n    }\n\n    event LogAction(address indexed target, bytes data);\n    event SentToMiner(uint256 indexed value);\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n\n    error AmountOutTooLow(uint256 amount, uint256 min);\n    error BalanceTooLow();\n    error FlashbotsErrorPayingMiner(uint256 value);\n    error IncompatibleLengths();\n    error RevertBytes();\n    error ZeroAddress();\n\n    constructor() initializer {}\n\n    function initialize(address keeper) public initializer {\n        __AccessControl_init();\n\n        _setupRole(KEEPER_ROLE, keeper);\n        _setRoleAdmin(KEEPER_ROLE, KEEPER_ROLE);\n    }\n}\n\ncontract MockKeeperMulticall2 {\n    uint256 public varTest = 1;\n\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    //solhint-disable-next-line\n    address private constant _oneInch = 0x1111111254fb6c44bAC0beD2854e76F90643097d;\n\n    struct Action {\n        address target;\n        bytes data;\n        bool isDelegateCall;\n    }\n\n    event LogAction(address indexed target, bytes data);\n    event SentToMiner(uint256 indexed value);\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n\n    error AmountOutTooLow(uint256 amount, uint256 min);\n    error BalanceTooLow();\n    error FlashbotsErrorPayingMiner(uint256 value);\n    error IncompatibleLengths();\n    error RevertBytes();\n    error ZeroAddress();\n\n    function functionTest() external pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/keeperMulticall/KeeperMulticall.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./RevertReasonParser.sol\";\n\n/// @title KeeperMulticall\n/// @notice Allows an authorized caller (keeper) to execute multiple actions in a single tx.\n/// @author Angle Core Team\n/// @dev Special features:\n///         - ability to pay the miner (for private Flashbots transactions)\n///         - swap tokens through 1inch\n/// @dev Tx need to be encoded as an array of Action. The flag `isDelegateCall` is used for calling functions within this same contract\ncontract KeeperMulticall is Initializable, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    //solhint-disable-next-line\n    address private constant _oneInch = 0x1111111254fb6c44bAC0beD2854e76F90643097d;\n\n    struct Action {\n        address target;\n        bytes data;\n        bool isDelegateCall;\n    }\n\n    event LogAction(address indexed target, bytes data);\n    event SentToMiner(uint256 indexed value);\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n\n    error AmountOutTooLow(uint256 amount, uint256 min);\n    error BalanceTooLow();\n    error FlashbotsErrorPayingMiner(uint256 value);\n    error IncompatibleLengths();\n    error RevertBytes();\n    error WrongAmount();\n    error ZeroAddress();\n\n    constructor() initializer {}\n\n    function initialize(address keeper) public initializer {\n        __AccessControl_init();\n\n        _setupRole(KEEPER_ROLE, keeper);\n        _setRoleAdmin(KEEPER_ROLE, KEEPER_ROLE);\n    }\n\n    /// @notice Allows an authorized keeper to execute multiple actions in a single step\n    /// @param actions Actions to be executed\n    /// @param percentageToMiner Percentage to pay to miner expressed in bps (10000)\n    /// @dev This is the main entry point for actions to be executed. The `isDelegateCall` flag is used for calling function inside this `KeeperMulticall` contract,\n    /// if we call other contracts, the flag should be false\n    function executeActions(Action[] memory actions, uint256 percentageToMiner)\n        external\n        payable\n        onlyRole(KEEPER_ROLE)\n        returns (bytes[] memory)\n    {\n        uint256 numberOfActions = actions.length;\n        if (numberOfActions == 0) revert IncompatibleLengths();\n\n        bytes[] memory returnValues = new bytes[](numberOfActions + 1);\n\n        uint256 balanceBefore = address(this).balance;\n\n        for (uint256 i = 0; i < numberOfActions; ++i) {\n            returnValues[i] = _executeAction(actions[i]);\n        }\n\n        if (percentageToMiner > 0) {\n            if (percentageToMiner >= 10000) revert WrongAmount();\n            uint256 balanceAfter = address(this).balance;\n            if (balanceAfter > balanceBefore) {\n                uint256 amountToMiner = ((balanceAfter - balanceBefore) * percentageToMiner) / 10000;\n                returnValues[numberOfActions] = payFlashbots(amountToMiner);\n            }\n        }\n\n        return returnValues;\n    }\n\n    /// @notice Gets the action address and data and executes it\n    /// @param action Action to be executed\n    function _executeAction(Action memory action) internal returns (bytes memory) {\n        bool success;\n        bytes memory response;\n\n        if (action.isDelegateCall) {\n            //solhint-disable-next-line\n            (success, response) = action.target.delegatecall(action.data);\n        } else {\n            //solhint-disable-next-line\n            (success, response) = action.target.call(action.data);\n        }\n\n        require(success, RevertReasonParser.parse(response, \"action reverted: \"));\n        emit LogAction(action.target, action.data);\n        return response;\n    }\n\n    /// @notice Ability to pay miner directly. Used for Flashbots to execute private transactions\n    /// @param value Value to be sent\n    function payFlashbots(uint256 value) public payable onlyRole(KEEPER_ROLE) returns (bytes memory) {\n        //solhint-disable-next-line\n        (bool success, bytes memory response) = block.coinbase.call{ value: value }(\"\");\n        if (!success) revert FlashbotsErrorPayingMiner(value);\n        emit SentToMiner(value);\n        return response;\n    }\n\n    /// @notice Used to check the balances the token holds for each token. If we don't have enough of a token, we revert the tx\n    /// @param tokens Array of tokens to check\n    /// @param minBalances Array of balances for each token\n    function finalBalanceCheck(IERC20[] memory tokens, uint256[] memory minBalances) external view returns (bool) {\n        uint256 tokensLength = tokens.length;\n        if (tokensLength == 0 || tokensLength != minBalances.length) revert IncompatibleLengths();\n\n        for (uint256 i; i < tokensLength; ++i) {\n            if (address(tokens[i]) == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n                if (address(this).balance < minBalances[i]) revert BalanceTooLow();\n            } else {\n                if (tokens[i].balanceOf(address(this)) < minBalances[i]) revert BalanceTooLow();\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice Swap token to another through 1Inch\n    /// @param minAmountOut Minimum amount of `out` token to receive for the swap to happen\n    /// @param payload Bytes needed for 1Inch API\n    function swapToken(uint256 minAmountOut, bytes memory payload) external onlyRole(KEEPER_ROLE) {\n        //solhint-disable-next-line\n        (bool success, bytes memory result) = _oneInch.call(payload);\n        if (!success) _revertBytes(result);\n\n        uint256 amountOut = abi.decode(result, (uint256));\n        if (amountOut < minAmountOut) revert AmountOutTooLow(amountOut, minAmountOut);\n    }\n\n    /// @notice Copied from 1Inch contract, used to revert if there is an error\n    function _revertBytes(bytes memory errMsg) internal pure {\n        if (errMsg.length > 0) {\n            //solhint-disable-next-line\n            assembly {\n                revert(add(32, errMsg), mload(errMsg))\n            }\n        }\n        revert RevertBytes();\n    }\n\n    /// @notice Approve a `spender` for `token`\n    /// @param token Address of the token to approve\n    /// @param spender Address of the spender to approve\n    /// @param amount Amount to approve\n    function approve(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) external onlyRole(KEEPER_ROLE) {\n        uint256 currentAllowance = token.allowance(address(this), spender);\n        if (currentAllowance < amount) {\n            token.safeIncreaseAllowance(spender, amount - currentAllowance);\n        } else if (currentAllowance > amount) {\n            token.safeDecreaseAllowance(spender, currentAllowance - amount);\n        }\n    }\n\n    receive() external payable {}\n\n    /// @notice Withdraw stuck funds\n    /// @param token Address of the token to recover\n    /// @param receiver Address where to send the tokens\n    /// @param amount Amount to recover\n    function withdrawStuckFunds(\n        address token,\n        address receiver,\n        uint256 amount\n    ) external onlyRole(KEEPER_ROLE) {\n        if (receiver == address(0)) revert ZeroAddress();\n        if (token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            payable(receiver).transfer(amount);\n        } else {\n            IERC20(token).safeTransfer(receiver, amount);\n        }\n\n        emit Recovered(token, receiver, amount);\n    }\n}\n"
    },
    "contracts/keeperMulticall/RevertReasonParser.sol": {
      "content": "// SPDX-License-Identifier: GNU-3\n\npragma solidity 0.8.12;\n\n/// @title RevertReasonParser\n/// @author 1Inch team, taken from:\n///     - https://docs.1inch.io/docs/limit-order-protocol/smart-contract/libraries/RevertReasonParser/\n///     - https://etherscan.io/address/0x1111111254fb6c44bAC0beD2854e76F90643097d#code\nlibrary RevertReasonParser {\n    bytes4 private constant _PANIC_SELECTOR = bytes4(keccak256(\"Panic(uint256)\"));\n    bytes4 private constant _ERROR_SELECTOR = bytes4(keccak256(\"Error(string)\"));\n\n    function parse(bytes memory data, string memory prefix) internal pure returns (string memory) {\n        if (data.length >= 4) {\n            bytes4 selector;\n            //solhint-disable-next-line\n            assembly {\n                selector := mload(add(data, 0x20))\n            }\n\n            // 68 = 4-byte selector + 32 bytes offset + 32 bytes length\n            if (selector == _ERROR_SELECTOR && data.length >= 68) {\n                uint256 offset;\n                bytes memory reason;\n                // solhint-disable no-inline-assembly\n                assembly {\n                    // 36 = 32 bytes data length + 4-byte selector\n                    offset := mload(add(data, 36))\n                    reason := add(data, add(36, offset))\n                }\n                /*\n                    revert reason is padded up to 32 bytes with ABI encoder: Error(string)\n                    also sometimes there is extra 32 bytes of zeros padded in the end:\n                    https://github.com/ethereum/solidity/issues/10170\n                    because of that we can't check for equality and instead check\n                    that offset + string length + extra 36 bytes is less than overall data length\n                */\n                require(data.length >= 36 + offset + reason.length, \"Invalid revert reason\");\n                return string(abi.encodePacked(prefix, \"Error(\", reason, \")\"));\n            }\n            // 36 = 4-byte selector + 32 bytes integer\n            else if (selector == _PANIC_SELECTOR && data.length == 36) {\n                uint256 code;\n                // solhint-disable no-inline-assembly\n                assembly {\n                    // 36 = 32 bytes data length + 4-byte selector\n                    code := mload(add(data, 36))\n                }\n                return string(abi.encodePacked(prefix, \"Panic(\", _toHex(code), \")\"));\n            }\n        }\n\n        return string(abi.encodePacked(prefix, \"Unknown(\", _toHex(data), \")\"));\n    }\n\n    function _toHex(uint256 value) private pure returns (string memory) {\n        return _toHex(abi.encodePacked(value));\n    }\n\n    function _toHex(bytes memory data) private pure returns (string memory) {\n        bytes16 alphabet = 0x30313233343536373839616263646566;\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i = 0; i < data.length; i++) {\n            str[2 * i + 2] = alphabet[uint8(data[i] >> 4)];\n            str[2 * i + 3] = alphabet[uint8(data[i] & 0x0f)];\n        }\n        return string(str);\n    }\n}\n"
    },
    "contracts/agToken/polygon/TokenPolygonUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./utils/ERC20UpgradeableCustom.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IAgToken.sol\";\nimport \"../../interfaces/ITreasury.sol\";\n\ninterface IChildToken {\n    function deposit(address user, bytes calldata depositData) external;\n\n    function withdraw(uint256 amount) external;\n}\n\ncontract TokenPolygonUpgradeable is\n    Initializable,\n    ERC20UpgradeableCustom,\n    AccessControlUpgradeable,\n    EIP712Upgradeable,\n    IChildToken\n{\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    /// @dev Emitted when the child chain manager changes\n    event ChildChainManagerAdded(address newAddress);\n    event ChildChainManagerRevoked(address oldAddress);\n\n    constructor() initializer {}\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address childChainManager,\n        address guardian\n    ) public initializer {\n        __ERC20_init(_name, _symbol);\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, guardian);\n        _setupRole(DEPOSITOR_ROLE, childChainManager);\n        __EIP712_init(_name, \"1\");\n    }\n\n    /**\n     * @notice Called when the bridge has tokens to mint\n     * @param user Address to mint the token to\n     * @param depositData Encoded amount to mint\n     */\n    function deposit(address user, bytes calldata depositData) external override {\n        require(hasRole(DEPOSITOR_ROLE, msg.sender));\n        uint256 amount = abi.decode(depositData, (uint256));\n        _mint(user, amount);\n    }\n\n    /**\n     * @notice Called when user wants to withdraw tokens back to root chain\n     * @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\n     * @param amount Amount of tokens to withdraw\n     */\n    function withdraw(uint256 amount) external override {\n        _burn(_msgSender(), amount);\n    }\n\n    // =============================================================================\n    // ======================= New data added for the upgrade ======================\n    // =============================================================================\n\n    mapping(address => bool) public isMinter;\n    /// @notice Reference to the treasury contract which can grant minting rights\n    address public treasury;\n    /// @notice Boolean to check whether the contract has been reinitialized after its upgrade\n    bool public treasuryInitialized;\n\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for fee computation\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    // =============================== Bridging Data ===============================\n\n    /// @notice Struct with some data about a specific bridge token\n    struct BridgeDetails {\n        // Limit on the balance of bridge token held by the contract: it is designed\n        // to reduce the exposure of the system to hacks\n        uint256 limit;\n        // Limit on the hourly volume of token minted through this bridge\n        // Technically the limit over a rolling hour is hourlyLimit x2 as hourly limit\n        // is enforced only between x:00 and x+1:00\n        uint256 hourlyLimit;\n        // Fee taken for swapping in and out the token\n        uint64 fee;\n        // Whether the associated token is allowed or not\n        bool allowed;\n        // Whether swapping in and out from the associated token is paused or not\n        bool paused;\n    }\n\n    /// @notice Maps a bridge token to data\n    mapping(address => BridgeDetails) public bridges;\n    /// @notice List of all bridge tokens\n    address[] public bridgeTokensList;\n    /// @notice Maps a bridge token to the associated hourly volume\n    mapping(address => mapping(uint256 => uint256)) public usage;\n    /// @notice Maps an address to whether it is exempt of fees for when it comes to swapping in and out\n    mapping(address => uint256) public isFeeExempt;\n    /// @notice Limit to the amount of tokens that can be sent from that chain to another chain\n    uint256 public chainTotalHourlyLimit;\n    /// @notice Usage per hour on that chain. Maps an hourly timestamp to the total volume swapped out on the chain\n    mapping(uint256 => uint256) public chainTotalUsage;\n\n    uint256[42] private __gap;\n\n    // ================================== Events ===================================\n\n    event BridgeTokenAdded(address indexed bridgeToken, uint256 limit, uint256 hourlyLimit, uint64 fee, bool paused);\n    event BridgeTokenToggled(address indexed bridgeToken, bool toggleStatus);\n    event BridgeTokenRemoved(address indexed bridgeToken);\n    event BridgeTokenFeeUpdated(address indexed bridgeToken, uint64 fee);\n    event BridgeTokenLimitUpdated(address indexed bridgeToken, uint256 limit);\n    event BridgeTokenHourlyLimitUpdated(address indexed bridgeToken, uint256 hourlyLimit);\n    event HourlyLimitUpdated(uint256 hourlyLimit);\n    event FeeToggled(address indexed theAddress, uint256 toggleStatus);\n    event KeeperToggled(address indexed keeper, bool toggleStatus);\n    event MinterToggled(address indexed minter);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event TreasuryUpdated(address indexed _treasury);\n\n    // ================================== Errors ===================================\n\n    error AssetStillControlledInReserves();\n    error BurnAmountExceedsAllowance();\n    error HourlyLimitExceeded();\n    error InvalidSender();\n    error InvalidToken();\n    error InvalidTreasury();\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error NotMinter();\n    error NotTreasury();\n    error TooBigAmount();\n    error TooHighParameterValue();\n    error TreasuryAlreadyInitialized();\n    error ZeroAddress();\n\n    /// @notice Checks to see if it is the `Treasury` calling this contract\n    /// @dev There is no Access Control here, because it can be handled cheaply through this modifier\n    modifier onlyTreasury() {\n        if (msg.sender != treasury) revert NotTreasury();\n        _;\n    }\n\n    /// @notice Checks whether the sender has the minting right\n    modifier onlyMinter() {\n        if (!isMinter[msg.sender]) revert NotMinter();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!ITreasury(treasury).isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!ITreasury(treasury).isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    /// @notice Sets up the treasury contract on Polygon after the upgrade\n    /// @param _treasury Address of the treasury contract\n    function setUpTreasury(address _treasury) external {\n        // Only governor on Polygon\n        if (msg.sender != 0xdA2D2f638D6fcbE306236583845e5822554c02EA) revert NotGovernor();\n        if (address(ITreasury(_treasury).stablecoin()) != address(this)) revert InvalidTreasury();\n        if (treasuryInitialized) revert TreasuryAlreadyInitialized();\n        treasury = _treasury;\n        treasuryInitialized = true;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // =========================== External Function ===============================\n\n    /// @notice Allows anyone to burn agToken without redeeming collateral back\n    /// @param amount Amount of stablecoins to burn\n    /// @dev This function can typically be called if there is a settlement mechanism to burn stablecoins\n    function burnStablecoin(uint256 amount) external {\n        _burnCustom(msg.sender, amount);\n    }\n\n    // ======================= Minter Role Only Functions ==========================\n\n    function burnSelf(uint256 amount, address burner) external onlyMinter {\n        _burnCustom(burner, amount);\n    }\n\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external onlyMinter {\n        _burnFromNoRedeem(amount, burner, sender);\n    }\n\n    function mint(address account, uint256 amount) external onlyMinter {\n        _mint(account, amount);\n    }\n\n    // ======================= Treasury Only Functions =============================\n\n    function addMinter(address minter) external onlyTreasury {\n        isMinter[minter] = true;\n        emit MinterToggled(minter);\n    }\n\n    function removeMinter(address minter) external {\n        if (msg.sender != address(treasury) && msg.sender != minter) revert InvalidSender();\n        isMinter[minter] = false;\n        emit MinterToggled(minter);\n    }\n\n    function setTreasury(address _treasury) external onlyTreasury {\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // ============================ Internal Function ==============================\n\n    /// @notice Internal version of the function `burnFromNoRedeem`\n    /// @param amount Amount to burn\n    /// @dev It is at the level of this function that allowance checks are performed\n    function _burnFromNoRedeem(\n        uint256 amount,\n        address burner,\n        address sender\n    ) internal {\n        if (burner != sender) {\n            uint256 currentAllowance = allowance(burner, sender);\n            if (currentAllowance < amount) revert BurnAmountExceedsAllowance();\n            _approve(burner, sender, currentAllowance - amount);\n        }\n        _burnCustom(burner, amount);\n    }\n\n    // ==================== External Permissionless Functions ======================\n\n    /// @notice Returns the list of all supported bridge tokens\n    /// @dev Helpful for UIs\n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridgeTokensList;\n    }\n\n    /// @notice Returns the current volume for a bridge, for the current hour\n    /// @dev Helpful for UIs\n    function currentUsage(address bridge) external view returns (uint256) {\n        return usage[bridge][block.timestamp / 3600];\n    }\n\n    /// @notice Returns the current total volume on the chain for the current hour\n    /// @dev Helpful for UIs\n    function currentTotalUsage() external view returns (uint256) {\n        return chainTotalUsage[block.timestamp / 3600];\n    }\n\n    /// @notice Mints the canonical token from a supported bridge token\n    /// @param bridgeToken Bridge token to use to mint\n    /// @param amount Amount of bridge tokens to send\n    /// @param to Address to which the stablecoin should be sent\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapIn(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n        uint256 balance = IERC20(bridgeToken).balanceOf(address(this));\n        if (balance + amount > bridgeDetails.limit) {\n            // In case someone maliciously sends tokens to this contract\n            // Or the limit changes\n            if (bridgeDetails.limit > balance) amount = bridgeDetails.limit - balance;\n            else {\n                amount = 0;\n            }\n        }\n\n        // Checking requirement on the hourly volume\n        uint256 hour = block.timestamp / 3600;\n        uint256 hourlyUsage = usage[bridgeToken][hour] + amount;\n        if (hourlyUsage > bridgeDetails.hourlyLimit) {\n            // Edge case when the hourly limit changes\n            if (bridgeDetails.hourlyLimit > usage[bridgeToken][hour])\n                amount = bridgeDetails.hourlyLimit - usage[bridgeToken][hour];\n            else {\n                amount = 0;\n            }\n        }\n        usage[bridgeToken][hour] = usage[bridgeToken][hour] + amount;\n\n        IERC20(bridgeToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 canonicalOut = amount;\n        // Computing fees\n        if (isFeeExempt[msg.sender] == 0) {\n            canonicalOut -= (canonicalOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        _mint(to, canonicalOut);\n        return canonicalOut;\n    }\n\n    /// @notice Burns the canonical token in exchange for a bridge token\n    /// @param bridgeToken Bridge token required\n    /// @param amount Amount of canonical tokens to burn\n    /// @param to Address to which the bridge token should be sent\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapOut(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n\n        uint256 hour = block.timestamp / 3600;\n        uint256 hourlyUsage = chainTotalUsage[hour] + amount;\n        // If the amount being swapped out exceeds the limit, we revert\n        // We don't want to change the amount being swapped out.\n        // The user can decide to send another tx with the correct amount to reach the limit\n        if (hourlyUsage > chainTotalHourlyLimit) revert HourlyLimitExceeded();\n        chainTotalUsage[hour] = hourlyUsage;\n\n        _burnCustom(msg.sender, amount);\n        uint256 bridgeOut = amount;\n        if (isFeeExempt[msg.sender] == 0) {\n            bridgeOut -= (bridgeOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        IERC20(bridgeToken).safeTransfer(to, bridgeOut);\n        return bridgeOut;\n    }\n\n    // ======================= Governance Functions ================================\n\n    /// @notice Adds support for a bridge token\n    /// @param bridgeToken Bridge token to add: it should be a version of the stablecoin from another bridge\n    /// @param limit Limit on the balance of bridge token this contract could hold\n    /// @param hourlyLimit Limit on the hourly volume for this bridge\n    /// @param paused Whether swapping for this token should be paused or not\n    /// @param fee Fee taken upon swapping for or against this token\n    function addBridgeToken(\n        address bridgeToken,\n        uint256 limit,\n        uint256 hourlyLimit,\n        uint64 fee,\n        bool paused\n    ) external onlyGovernor {\n        if (bridges[bridgeToken].allowed || bridgeToken == address(0)) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        BridgeDetails memory _bridge;\n        _bridge.limit = limit;\n        _bridge.hourlyLimit = hourlyLimit;\n        _bridge.paused = paused;\n        _bridge.fee = fee;\n        _bridge.allowed = true;\n        bridges[bridgeToken] = _bridge;\n        bridgeTokensList.push(bridgeToken);\n        emit BridgeTokenAdded(bridgeToken, limit, hourlyLimit, fee, paused);\n    }\n\n    /// @notice Removes support for a token\n    /// @param bridgeToken Address of the bridge token to remove support for\n    function removeBridgeToken(address bridgeToken) external onlyGovernor {\n        if (IERC20(bridgeToken).balanceOf(address(this)) != 0) revert AssetStillControlledInReserves();\n        delete bridges[bridgeToken];\n        // Deletion from `bridgeTokensList` loop\n        uint256 bridgeTokensListLength = bridgeTokensList.length;\n        for (uint256 i = 0; i < bridgeTokensListLength - 1; i++) {\n            if (bridgeTokensList[i] == bridgeToken) {\n                // Replace the `bridgeToken` to remove with the last of the list\n                bridgeTokensList[i] = bridgeTokensList[bridgeTokensListLength - 1];\n                break;\n            }\n        }\n        // Remove last element in array\n        bridgeTokensList.pop();\n        emit BridgeTokenRemoved(bridgeToken);\n    }\n\n    /// @notice Recovers any ERC20 token\n    /// @dev Can be used to withdraw bridge tokens for them to be de-bridged on mainnet\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyGovernor {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Updates the `limit` amount for `bridgeToken`\n    function setLimit(address bridgeToken, uint256 limit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].limit = limit;\n        emit BridgeTokenLimitUpdated(bridgeToken, limit);\n    }\n\n    /// @notice Updates the `hourlyLimit` amount for `bridgeToken`\n    function setHourlyLimit(address bridgeToken, uint256 hourlyLimit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].hourlyLimit = hourlyLimit;\n        emit BridgeTokenHourlyLimitUpdated(bridgeToken, hourlyLimit);\n    }\n\n    /// @notice Updates the `chainTotalHourlyLimit` amount\n    function setChainTotalHourlyLimit(uint256 hourlyLimit) external onlyGovernorOrGuardian {\n        chainTotalHourlyLimit = hourlyLimit;\n        emit HourlyLimitUpdated(hourlyLimit);\n    }\n\n    /// @notice Updates the `fee` value for `bridgeToken`\n    function setSwapFee(address bridgeToken, uint64 fee) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        bridges[bridgeToken].fee = fee;\n        emit BridgeTokenFeeUpdated(bridgeToken, fee);\n    }\n\n    /// @notice Pauses or unpauses swapping in and out for a token\n    function toggleBridge(address bridgeToken) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bool pausedStatus = bridges[bridgeToken].paused;\n        bridges[bridgeToken].paused = !pausedStatus;\n        emit BridgeTokenToggled(bridgeToken, !pausedStatus);\n    }\n\n    /// @notice Toggles fees for the address `theAddress`\n    function toggleFeesForAddress(address theAddress) external onlyGovernorOrGuardian {\n        uint256 feeExemptStatus = 1 - isFeeExempt[theAddress];\n        isFeeExempt[theAddress] = feeExemptStatus;\n        emit FeeToggled(theAddress, feeExemptStatus);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/coreBorrow/CoreBorrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\n/// @title CoreBorrow\n/// @author Angle Core Team\n/// @notice Core contract of the borrowing module. This contract handles the access control across all contracts\n/// (it is read by all treasury contracts), and manages the `flashLoanModule`. It has no minting rights over the\n/// stablecoin contracts\ncontract CoreBorrow is ICoreBorrow, Initializable, AccessControlEnumerableUpgradeable {\n    /// @notice Role for guardians\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    /// @notice Role for governors\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    /// @notice Role for treasury contract\n    bytes32 public constant FLASHLOANER_TREASURY_ROLE = keccak256(\"FLASHLOANER_TREASURY_ROLE\");\n\n    // ============================= Reference =====================================\n\n    /// @notice Reference to the `flashLoanModule` with minting rights over the different stablecoins of the protocol\n    address public flashLoanModule;\n\n    // =============================== Events ======================================\n\n    event FlashLoanModuleUpdated(address indexed _flashloanModule);\n    event CoreUpdated(address indexed _core);\n\n    // =============================== Errors ======================================\n\n    error InvalidCore();\n    error IncompatibleGovernorAndGuardian();\n    error NotEnoughGovernorsLeft();\n    error ZeroAddress();\n\n    /// @notice Initializes the `CoreBorrow` contract and the access control of the borrowing module\n    /// @param governor Address of the governor of the Angle Protocol\n    /// @param guardian Guardian address of the protocol\n    function initialize(address governor, address guardian) public initializer {\n        if (governor == address(0) || guardian == address(0)) revert ZeroAddress();\n        if (governor == guardian) revert IncompatibleGovernorAndGuardian();\n        _setupRole(GOVERNOR_ROLE, governor);\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setupRole(GUARDIAN_ROLE, governor);\n        _setRoleAdmin(GUARDIAN_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(FLASHLOANER_TREASURY_ROLE, GOVERNOR_ROLE);\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // =========================== View Functions ==================================\n\n    /// @inheritdoc ICoreBorrow\n    function isFlashLoanerTreasury(address treasury) external view returns (bool) {\n        return hasRole(FLASHLOANER_TREASURY_ROLE, treasury);\n    }\n\n    /// @inheritdoc ICoreBorrow\n    function isGovernor(address admin) external view returns (bool) {\n        return hasRole(GOVERNOR_ROLE, admin);\n    }\n\n    /// @inheritdoc ICoreBorrow\n    function isGovernorOrGuardian(address admin) external view returns (bool) {\n        return hasRole(GUARDIAN_ROLE, admin);\n    }\n\n    // =========================== Governor Functions ==============================\n\n    /// @notice Grants the `FLASHLOANER_TREASURY_ROLE` to a `treasury` contract\n    /// @param treasury Contract to grant the role to\n    /// @dev This function can be used to allow flash loans on a stablecoin of the protocol\n    function addFlashLoanerTreasuryRole(address treasury) external {\n        grantRole(FLASHLOANER_TREASURY_ROLE, treasury);\n        address _flashLoanModule = flashLoanModule;\n        if (_flashLoanModule != address(0)) {\n            // This call will revert if `treasury` is the zero address or if it is not linked\n            // to this `CoreBorrow` contract\n            ITreasury(treasury).setFlashLoanModule(_flashLoanModule);\n            IFlashAngle(_flashLoanModule).addStablecoinSupport(treasury);\n        }\n    }\n\n    /// @notice Adds a governor in the protocol\n    /// @param governor Address to grant the role to\n    /// @dev It is necessary to call this function to grant a governor role to make sure\n    /// all governors also have the guardian role\n    function addGovernor(address governor) external {\n        grantRole(GOVERNOR_ROLE, governor);\n        grantRole(GUARDIAN_ROLE, governor);\n    }\n\n    /// @notice Revokes the flash loan ability for a stablecoin\n    /// @param treasury Treasury address associated with the stablecoin for which flash loans\n    /// should no longer be available\n    function removeFlashLoanerTreasuryRole(address treasury) external {\n        revokeRole(FLASHLOANER_TREASURY_ROLE, treasury);\n        ITreasury(treasury).setFlashLoanModule(address(0));\n        address _flashLoanModule = flashLoanModule;\n        if (_flashLoanModule != address(0)) {\n            IFlashAngle(flashLoanModule).removeStablecoinSupport(treasury);\n        }\n    }\n\n    /// @notice Revokes a governor from the protocol\n    /// @param governor Address to remove the role to\n    /// @dev It is necessary to call this function to remove a governor role to make sure\n    /// the address also loses its guardian role\n    function removeGovernor(address governor) external {\n        if (getRoleMemberCount(GOVERNOR_ROLE) <= 1) revert NotEnoughGovernorsLeft();\n        revokeRole(GUARDIAN_ROLE, governor);\n        revokeRole(GOVERNOR_ROLE, governor);\n    }\n\n    /// @notice Changes the `flashLoanModule` of the protocol\n    /// @param _flashLoanModule Address of the new flash loan module\n    function setFlashLoanModule(address _flashLoanModule) external onlyRole(GOVERNOR_ROLE) {\n        if (_flashLoanModule != address(0)) {\n            if (address(IFlashAngle(_flashLoanModule).core()) != address(this)) revert InvalidCore();\n        }\n        uint256 count = getRoleMemberCount(FLASHLOANER_TREASURY_ROLE);\n        for (uint256 i = 0; i < count; i++) {\n            ITreasury(getRoleMember(FLASHLOANER_TREASURY_ROLE, i)).setFlashLoanModule(_flashLoanModule);\n        }\n        flashLoanModule = _flashLoanModule;\n        emit FlashLoanModuleUpdated(_flashLoanModule);\n    }\n\n    /// @notice Changes the core contract of the protocol\n    /// @param _core New core contract\n    /// @dev This function verifies that all governors of the current core contract are also governors\n    /// of the new core contract. It also notifies the `flashLoanModule` of the change.\n    /// @dev Governance wishing to change the core contract should also make sure to call `setCore`\n    /// in the different treasury contracts\n    function setCore(ICoreBorrow _core) external onlyRole(GOVERNOR_ROLE) {\n        uint256 count = getRoleMemberCount(GOVERNOR_ROLE);\n        bool success;\n        for (uint256 i = 0; i < count; i++) {\n            success = _core.isGovernor(getRoleMember(GOVERNOR_ROLE, i));\n            if (!success) break;\n        }\n        if (!success) revert InvalidCore();\n        address _flashLoanModule = flashLoanModule;\n        if (_flashLoanModule != address(0)) IFlashAngle(_flashLoanModule).setCore(address(_core));\n        emit CoreUpdated(address(_core));\n    }\n}\n"
    },
    "contracts/mock/MockTreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/IVaultManager.sol\";\n\ncontract MockTreasury is ITreasury {\n    IAgToken public override stablecoin;\n    address public governor;\n    address public guardian;\n    address public vaultManager1;\n    address public vaultManager2;\n    address public flashLoanModule;\n\n    constructor(\n        IAgToken _stablecoin,\n        address _governor,\n        address _guardian,\n        address _vaultManager1,\n        address _vaultManager2,\n        address _flashLoanModule\n    ) {\n        stablecoin = _stablecoin;\n        governor = _governor;\n        guardian = _guardian;\n        vaultManager1 = _vaultManager1;\n        vaultManager2 = _vaultManager2;\n        flashLoanModule = _flashLoanModule;\n    }\n\n    function isGovernor(address admin) external view override returns (bool) {\n        return (admin == governor);\n    }\n\n    function isGovernorOrGuardian(address admin) external view override returns (bool) {\n        return (admin == governor || admin == guardian);\n    }\n\n    function isVaultManager(address _vaultManager) external view override returns (bool) {\n        return (_vaultManager == vaultManager1 || _vaultManager == vaultManager2);\n    }\n\n    function setStablecoin(IAgToken _stablecoin) external {\n        stablecoin = _stablecoin;\n    }\n\n    function setFlashLoanModule(address _flashLoanModule) external override {\n        flashLoanModule = _flashLoanModule;\n    }\n\n    function setGovernor(address _governor) external {\n        governor = _governor;\n    }\n\n    function setVaultManager(address _vaultManager) external {\n        vaultManager1 = _vaultManager;\n    }\n\n    function setVaultManager2(address _vaultManager) external {\n        vaultManager2 = _vaultManager;\n    }\n\n    function setTreasury(address _agTokenOrVaultManager, address _treasury) external {\n        IAgToken(_agTokenOrVaultManager).setTreasury(_treasury);\n    }\n\n    function addMinter(IAgToken _agToken, address _minter) external {\n        _agToken.addMinter(_minter);\n    }\n\n    function removeMinter(IAgToken _agToken, address _minter) external {\n        _agToken.removeMinter(_minter);\n    }\n\n    function accrueInterestToTreasury(IFlashAngle flashAngle) external returns (uint256 balance) {\n        balance = flashAngle.accrueInterestToTreasury(stablecoin);\n    }\n\n    function accrueInterestToTreasuryVaultManager(IVaultManager _vaultManager) external returns (uint256, uint256) {\n        return _vaultManager.accrueInterestToTreasury();\n    }\n}\n"
    },
    "contracts/mock/MockFlashLoanModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ICoreBorrow.sol\";\n\ncontract MockFlashLoanModule is IFlashAngle {\n    ICoreBorrow public override core;\n    mapping(address => bool) public stablecoinsSupported;\n    mapping(IAgToken => uint256) public interestAccrued;\n    uint256 public surplusValue;\n\n    constructor(ICoreBorrow _core) {\n        core = _core;\n    }\n\n    function accrueInterestToTreasury(IAgToken stablecoin) external override returns (uint256 balance) {\n        balance = surplusValue;\n        interestAccrued[stablecoin] += balance;\n    }\n\n    function addStablecoinSupport(address _treasury) external override {\n        stablecoinsSupported[_treasury] = true;\n    }\n\n    function removeStablecoinSupport(address _treasury) external override {\n        stablecoinsSupported[_treasury] = false;\n    }\n\n    function setCore(address _core) external override {\n        core = ICoreBorrow(_core);\n    }\n\n    function setSurplusValue(uint256 _surplusValue) external {\n        surplusValue = _surplusValue;\n    }\n}\n"
    },
    "contracts/mock/MockCoreBorrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\ncontract MockCoreBorrow is ICoreBorrow {\n    mapping(address => bool) public flashLoaners;\n    mapping(address => bool) public governors;\n    mapping(address => bool) public guardians;\n\n    function isFlashLoanerTreasury(address treasury) external view override returns (bool) {\n        return flashLoaners[treasury];\n    }\n\n    function isGovernor(address admin) external view override returns (bool) {\n        return governors[admin];\n    }\n\n    function isGovernorOrGuardian(address admin) external view override returns (bool) {\n        return guardians[admin];\n    }\n\n    function toggleGovernor(address admin) external {\n        governors[admin] = !governors[admin];\n    }\n\n    function toggleGuardian(address admin) external {\n        guardians[admin] = !guardians[admin];\n    }\n\n    function toggleFlashLoaners(address admin) external {\n        flashLoaners[admin] = !flashLoaners[admin];\n    }\n\n    function addStablecoinSupport(IFlashAngle flashAngle, address _treasury) external {\n        flashAngle.addStablecoinSupport(_treasury);\n    }\n\n    function removeStablecoinSupport(IFlashAngle flashAngle, address _treasury) external {\n        flashAngle.removeStablecoinSupport(_treasury);\n    }\n\n    function setCore(IFlashAngle flashAngle, address _core) external {\n        flashAngle.setCore(_core);\n    }\n\n    function setFlashLoanModule(ITreasury _treasury, address _flashLoanModule) external {\n        _treasury.setFlashLoanModule(_flashLoanModule);\n    }\n}\n"
    },
    "contracts/flashloan/FlashAngle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\n/// @title FlashAngle\n/// @author Angle Core Team\n/// @notice Contract to take flash loans on top of several AgToken contracts\ncontract FlashAngle is IERC3156FlashLender, IFlashAngle, Initializable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_PARAMS = 10**9;\n    /// @notice Success message received when calling a `FlashBorrower` contract\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// @notice Struct encoding for a given stablecoin the parameters\n    struct StablecoinData {\n        // Maximum amount borrowable for this stablecoin\n        uint256 maxBorrowable;\n        // Flash loan fee taken by the protocol for a flash loan on this stablecoin\n        uint64 flashLoanFee;\n        // Treasury address responsible of the stablecoin\n        address treasury;\n    }\n\n    // ======================= Parameters and References ===========================\n\n    /// @notice Maps a stablecoin to the data and parameters for flash loans\n    mapping(IAgToken => StablecoinData) public stablecoinMap;\n    /// @inheritdoc IFlashAngle\n    ICoreBorrow public core;\n\n    // =============================== Event =======================================\n\n    event FlashLoan(address indexed stablecoin, uint256 amount, IERC3156FlashBorrower indexed receiver);\n    event FlashLoanParametersUpdated(IAgToken indexed stablecoin, uint64 _flashLoanFee, uint256 _maxBorrowable);\n\n    // =============================== Errors ======================================\n\n    error InvalidReturnMessage();\n    error NotCore();\n    error NotGovernorOrGuardian();\n    error NotTreasury();\n    error TooBigAmount();\n    error TooHighParameterValue();\n    error UnsupportedStablecoin();\n    error ZeroAddress();\n\n    /// @notice Initializes the contract\n    /// @param _core Core address handling this module\n    function initialize(ICoreBorrow _core) public initializer {\n        if (address(_core) == address(0)) revert ZeroAddress();\n        core = _core;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // =================================== Modifiers ===============================\n\n    /// @notice Checks whether the sender is the core contract\n    modifier onlyCore() {\n        if (msg.sender != address(core)) revert NotCore();\n        _;\n    }\n\n    /// @notice Checks whether a given stablecoin has been initialized in this contract\n    /// @param stablecoin Stablecoin to check\n    /// @dev To check whether a stablecoin has been initialized, we just need to check whether its associated\n    /// `treasury` address is not null in the `stablecoinMap`. This is what's checked in the `CoreBorrow` contract\n    /// when adding support for a stablecoin\n    modifier onlyExistingStablecoin(IAgToken stablecoin) {\n        if (stablecoinMap[stablecoin].treasury == address(0)) revert UnsupportedStablecoin();\n        _;\n    }\n\n    // ================================ ERC3156 Spec ===============================\n\n    /// @inheritdoc IERC3156FlashLender\n    function flashFee(address token, uint256 amount) external view returns (uint256) {\n        return _flashFee(token, amount);\n    }\n\n    /// @inheritdoc IERC3156FlashLender\n    function maxFlashLoan(address token) external view returns (uint256) {\n        // It will be 0 anyway if the token was not added\n        return stablecoinMap[IAgToken(token)].maxBorrowable;\n    }\n\n    /// @inheritdoc IERC3156FlashLender\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external nonReentrant returns (bool) {\n        uint256 fee = _flashFee(token, amount);\n        if (amount > stablecoinMap[IAgToken(token)].maxBorrowable) revert TooBigAmount();\n        IAgToken(token).mint(address(receiver), amount);\n        if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS)\n            revert InvalidReturnMessage();\n        // Token must be an agToken here so normally no need to use `safeTransferFrom`, but out of safety\n        // and in case governance whitelists an agToken which does not have a correct implementation, we prefer\n        // to use `safeTransferFrom` here\n        IERC20(token).safeTransferFrom(address(receiver), address(this), amount + fee);\n        IAgToken(token).burnSelf(amount, address(this));\n        emit FlashLoan(token, amount, receiver);\n        return true;\n    }\n\n    /// @notice Internal function to compute the fee induced for taking a flash loan of `amount` of `token`\n    /// @param token The loan currency\n    /// @param amount The amount of tokens lent\n    /// @dev This function will revert if the `token` requested is not whitelisted here\n    function _flashFee(address token, uint256 amount)\n        internal\n        view\n        onlyExistingStablecoin(IAgToken(token))\n        returns (uint256)\n    {\n        return (amount * stablecoinMap[IAgToken(token)].flashLoanFee) / BASE_PARAMS;\n    }\n\n    // ============================ Treasury Only Function =========================\n\n    /// @inheritdoc IFlashAngle\n    function accrueInterestToTreasury(IAgToken stablecoin) external returns (uint256 balance) {\n        address treasury = stablecoinMap[stablecoin].treasury;\n        if (msg.sender != treasury) revert NotTreasury();\n        balance = stablecoin.balanceOf(address(this));\n        IERC20(address(stablecoin)).safeTransfer(treasury, balance);\n    }\n\n    // =========================== Governance Only Function ========================\n\n    /// @notice Sets the parameters for a given stablecoin\n    /// @param stablecoin Stablecoin to change the parameters for\n    /// @param _flashLoanFee New flash loan fee for this stablecoin\n    /// @param _maxBorrowable Maximum amount that can be borrowed in a single flash loan\n    /// @dev Setting a `maxBorrowable` parameter equal to 0 is a way to pause the functionality\n    /// @dev Parameters can only be modified for whitelisted stablecoins\n    function setFlashLoanParameters(\n        IAgToken stablecoin,\n        uint64 _flashLoanFee,\n        uint256 _maxBorrowable\n    ) external onlyExistingStablecoin(stablecoin) {\n        if (!core.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        if (_flashLoanFee > BASE_PARAMS) revert TooHighParameterValue();\n        stablecoinMap[stablecoin].flashLoanFee = _flashLoanFee;\n        stablecoinMap[stablecoin].maxBorrowable = _maxBorrowable;\n        emit FlashLoanParametersUpdated(stablecoin, _flashLoanFee, _maxBorrowable);\n    }\n\n    // =========================== CoreBorrow Only Functions =======================\n\n    /// @inheritdoc IFlashAngle\n    function addStablecoinSupport(address _treasury) external onlyCore {\n        stablecoinMap[IAgToken(ITreasury(_treasury).stablecoin())].treasury = _treasury;\n    }\n\n    /// @inheritdoc IFlashAngle\n    function removeStablecoinSupport(address _treasury) external onlyCore {\n        delete stablecoinMap[IAgToken(ITreasury(_treasury).stablecoin())];\n    }\n\n    /// @inheritdoc IFlashAngle\n    function setCore(address _core) external onlyCore {\n        core = ICoreBorrow(_core);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "contracts/mock/MockFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\n\ncontract MockFlashLoanReceiver is IERC3156FlashBorrower {\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    constructor() {}\n\n    function onFlashLoan(\n        address,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external override returns (bytes32) {\n        IERC20(token).approve(msg.sender, amount + fee);\n        if (amount >= 10**21) return keccak256(\"error\");\n        if (amount == 2 * 10**18) {\n            IERC3156FlashLender(msg.sender).flashLoan(IERC3156FlashBorrower(address(this)), token, amount, data);\n            return keccak256(\"reentrant\");\n        } else return CALLBACK_SUCCESS;\n    }\n}\n"
    },
    "contracts/mock/MockEulerPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockEulerPool {\n    IERC20 public collateral;\n    uint256 public poolSize;\n    //solhint-disable-next-line\n    uint256 public MAX_SANE_AMOUNT;\n\n    mapping(address => uint256) public users;\n    uint256 public interestRateAccumulator;\n\n    constructor(IERC20 collateral_, uint256 poolSize_) {\n        collateral = collateral_;\n        poolSize = poolSize_;\n        interestRateAccumulator = 10**18;\n        MAX_SANE_AMOUNT = type(uint112).max;\n    }\n\n    function setPoolSize(uint256 poolSize_) external {\n        uint256 balance = collateral.balanceOf(address(this));\n        poolSize = poolSize_;\n        if (balance > poolSize_) collateral.transfer(msg.sender, balance - poolSize_);\n        if (balance < poolSize_) collateral.transferFrom(msg.sender, address(this), poolSize_ - balance);\n    }\n\n    function setInterestRateAccumulator(uint256 interestRateAccumulator_) external {\n        interestRateAccumulator = interestRateAccumulator_;\n    }\n\n    //solhint-disable-next-line\n    function setMAXSANEAMOUNT(uint256 MAX_SANE_AMOUNT_) external {\n        MAX_SANE_AMOUNT = MAX_SANE_AMOUNT_;\n    }\n\n    function balanceOfUnderlying(address account) external view returns (uint256) {\n        return (users[account] * interestRateAccumulator) / 10**18;\n    }\n\n    function deposit(uint256, uint256 amount) external {\n        users[msg.sender] += (amount * 10**18) / interestRateAccumulator;\n        poolSize += amount;\n        collateral.transferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256, uint256 amount) external {\n        if (amount == type(uint256).max) amount = (users[msg.sender] * interestRateAccumulator) / 10**18;\n\n        require(amount <= poolSize, \"4\");\n        users[msg.sender] -= (amount * 10**18) / interestRateAccumulator;\n        collateral.transfer(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/mock/Mock1Inch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract Mock1Inch {\n    using SafeERC20 for IERC20;\n\n    function swap(\n        address tokenIn,\n        uint256 amountIn,\n        address to,\n        address tokenOut,\n        uint256 amountOut\n    ) external {\n        IERC20(tokenIn).safeTransferFrom(msg.sender, to, amountIn);\n        if (tokenOut == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            //solhint-disable-next-line\n            (bool sent, bytes memory data) = msg.sender.call{ value: amountOut }(\"\");\n            data;\n            require(sent, \"Failed to send Ether\");\n        } else {\n            IERC20(tokenOut).safeTransferFrom(to, msg.sender, amountOut);\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/merkleRootDistributor/MerkleRootDistributorV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/ITreasury.sol\";\n\nstruct MerkleTree {\n    // Root of a Merkle tree which leaves are (address user, address token, uint amount)\n    // representing an amount of tokens owed to user.\n    // The Merkle tree is assumed to have only increasing amounts: that is to say if a user can claim 1,\n    // then after the amount associated in the Merkle tree for this token should be x > 1\n    bytes32 merkleRoot;\n    // Ipfs hash of the tree data\n    bytes32 ipfsHash;\n}\n\n/// @title MerkleRootDistributor\n/// @notice Allows the DAO to distribute rewards through Merkle Roots\n/// @author Angle Core Team\ncontract MerkleRootDistributorV2 is Initializable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Tree of claimable tokens through this contract\n    MerkleTree public tree;\n\n    /// @notice Treasury contract handling access control\n    ITreasury public treasury;\n\n    /// @notice Mapping user -> token -> amount to track claimed amounts\n    mapping(address => mapping(address => uint256)) public claimed;\n\n    /// @notice Trusted EOAs to update the merkle root\n    mapping(address => uint256) public trusted;\n\n    /// @notice Whether or not to enable permissionless claiming\n    mapping(address => uint256) public whitelist;\n\n    /// @notice user -> operator -> authorisation to claim\n    mapping(address => mapping(address => uint256)) public operators;\n\n    uint256[44] private __gap;\n\n    // ================================== Events ===================================\n\n    event TrustedToggled(address indexed eoa, bool trust);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event TreeUpdated(bytes32 merkleRoot, bytes32 ipfsHash);\n    event Claimed(address user, address token, uint256 amount);\n    event WhitelistToggled(address user, bool isEnabled);\n    event OperatorToggled(address user, address operator, bool isWhitelisted);\n\n    // ================================== Errors ===================================\n\n    error InvalidLengths();\n    error InvalidProof();\n    error NotGovernorOrGuardian();\n    error NotTrusted();\n    error ZeroAddress();\n    error NotWhitelisted();\n\n    // ================================= Modifiers =================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!treasury.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` is a trusted address to change the Merkle root of the contract\n    modifier onlyTrusted() {\n        if (!treasury.isGovernorOrGuardian(msg.sender) && trusted[msg.sender] != 1) revert NotTrusted();\n        _;\n    }\n\n    // ============================ Constructor ====================================\n\n    constructor() initializer {}\n\n    function initialize(ITreasury _treasury) public initializer {\n        if (address(_treasury) == address(0)) revert ZeroAddress();\n        treasury = _treasury;\n    }\n\n    // =========================== Main Function ===================================\n\n    /// @notice Claims rewards for a given set of users\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// who provides the proof and pays the gas: `msg.sender` is not used in this function\n    /// @param users Recipient of tokens\n    /// @param tokens ERC20 claimed\n    /// @param amounts Amount of tokens that will be sent to the corresponding users\n    /// @param proofs Array of hashes bridging from leaf (hash of user | token | amount) to Merkle root\n    function claim(\n        address[] calldata users,\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata proofs\n    ) public {\n        if (\n            users.length == 0 ||\n            users.length != tokens.length ||\n            users.length != amounts.length ||\n            users.length != proofs.length\n        ) revert InvalidLengths();\n\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n            address token = tokens[i];\n            uint256 amount = amounts[i];\n\n            // Check whitelist if needed\n            if (whitelist[user] == 1 && operators[user][msg.sender] == 0) revert NotWhitelisted();\n\n            // Verifying proof\n            bytes32 leaf = keccak256(abi.encode(user, token, amount));\n            if (!_verifyProof(leaf, proofs[i])) revert InvalidProof();\n\n            // Closing reentrancy gate here\n            uint256 toSend = amount - claimed[user][token];\n            claimed[user][token] = amount;\n\n            IERC20(token).safeTransfer(user, toSend);\n            emit Claimed(user, token, toSend);\n        }\n    }\n\n    // =========================== Governance Functions ============================\n\n    /// @notice Pull reward amount from caller\n    function deposit_reward_token(IERC20 token, uint256 amount) external {\n        token.transferFrom(msg.sender, address(this), amount);\n    }\n\n    /// @notice Adds or removes trusted EOA\n    function toggleTrusted(address eoa) external onlyGovernorOrGuardian {\n        uint256 trustedStatus = 1 - trusted[eoa];\n        trusted[eoa] = trustedStatus;\n        emit TrustedToggled(eoa, trustedStatus == 1);\n    }\n\n    /// @notice Updates Merkle Tree\n    function updateTree(MerkleTree calldata _tree) external onlyTrusted {\n        tree = _tree;\n        emit TreeUpdated(_tree.merkleRoot, _tree.ipfsHash);\n    }\n\n    /// @notice Toggles permissionless claiming for a given user\n    function toggleWhitelist(address user) external {\n        if (user != msg.sender && !treasury.isGovernorOrGuardian(msg.sender) && trusted[msg.sender] != 1)\n            revert NotTrusted();\n        whitelist[user] = 1 - whitelist[user];\n        emit WhitelistToggled(user, whitelist[user] == 1);\n    }\n\n    /// @notice Toggles whitelisting for a given user and a given operator\n    function toggleOperator(address user, address operator) external {\n        if (user != msg.sender && !treasury.isGovernorOrGuardian(msg.sender) && trusted[msg.sender] != 1)\n            revert NotTrusted();\n        operators[user][operator] = 1 - operators[user][operator];\n        emit OperatorToggled(user, operator, operators[user][operator] == 1);\n    }\n\n    /// @notice Recovers any ERC20 token\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyGovernorOrGuardian {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    // =========================== Internal Functions ==============================\n\n    /// @notice Checks the validity of a proof\n    /// @param leaf Hashed leaf data, the starting point of the proof\n    /// @param proof Array of hashes forming a hash chain from leaf to root\n    /// @return true If proof is correct, else false\n    function _verifyProof(bytes32 leaf, bytes32[] memory proof) internal view returns (bool) {\n        bytes32 currentHash = leaf;\n        for (uint256 i = 0; i < proof.length; i += 1) {\n            if (currentHash < proof[i]) {\n                currentHash = keccak256(abi.encode(currentHash, proof[i]));\n            } else {\n                currentHash = keccak256(abi.encode(proof[i], currentHash));\n            }\n        }\n        return currentHash == tree.merkleRoot;\n    }\n}\n"
    },
    "contracts/merkleRootDistributor/MerkleRootDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/ITreasury.sol\";\n\nstruct MerkleTree {\n    // Root of a Merkle tree which leaves are (address user, address token, uint amount)\n    // representing an amount of tokens owed to user.\n    // The Merkle tree is assumed to have only increasing amounts: that is to say if a user can claim 1,\n    // then after the amount associated in the Merkle tree for this token should be x > 1\n    bytes32 merkleRoot;\n    // Ipfs hash of the tree data\n    bytes32 ipfsHash;\n}\n\n/// @title MerkleRootDistributor\n/// @notice Allows the DAO to distribute rewards through Merkle Roots\n/// @author Angle Core Team\ncontract MerkleRootDistributor is Initializable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Tree of claimable tokens through this contract\n    MerkleTree public tree;\n\n    /// @notice Treasury contract handling access control\n    ITreasury public treasury;\n\n    /// @notice Mapping user -> token -> amount to track claimed amounts\n    mapping(address => mapping(address => uint256)) public claimed;\n\n    /// @notice Trusted EOAs to update the merkle root\n    mapping(address => uint256) public trusted;\n\n    uint256[46] private __gap;\n\n    // ================================== Events ===================================\n\n    event TrustedToggled(address indexed eoa, bool trust);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event TreeUpdated(bytes32 merkleRoot, bytes32 ipfsHash);\n    event Claimed(address user, address token, uint256 amount);\n\n    // ================================== Errors ===================================\n\n    error InvalidLengths();\n    error InvalidProof();\n    error NotGovernorOrGuardian();\n    error NotTrusted();\n    error ZeroAddress();\n\n    // ================================= Modifiers =================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!treasury.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` is a trusted address to change the Merkle root of the contract\n    modifier onlyTrusted() {\n        if (!treasury.isGovernorOrGuardian(msg.sender) && trusted[msg.sender] != 1) revert NotTrusted();\n        _;\n    }\n\n    // ============================ Constructor ====================================\n\n    constructor() initializer {}\n\n    function initialize(ITreasury _treasury) public initializer {\n        if (address(_treasury) == address(0)) revert ZeroAddress();\n        treasury = _treasury;\n    }\n\n    // =========================== Main Function ===================================\n\n    /// @notice Claims rewards for a given set of users\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// who provides the proof and pays the gas: `msg.sender` is not used in this function\n    /// @param users Recipient of tokens\n    /// @param tokens ERC20 claimed\n    /// @param amounts Amount of tokens that will be sent to the corresponding users\n    /// @param proofs Array of hashes bridging from leaf (hash of user | token | amount) to Merkle root\n    function claim(\n        address[] calldata users,\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata proofs\n    ) public {\n        if (\n            users.length == 0 ||\n            users.length != tokens.length ||\n            users.length != amounts.length ||\n            users.length != proofs.length\n        ) revert InvalidLengths();\n\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n            address token = tokens[i];\n            uint256 amount = amounts[i];\n\n            // Verifying proof\n            bytes32 leaf = keccak256(abi.encode(user, token, amount));\n            if (!_verifyProof(leaf, proofs[i])) revert InvalidProof();\n\n            // Closing reentrancy gate here\n            uint256 toSend = amount - claimed[user][token];\n            claimed[user][token] = amount;\n\n            IERC20(token).safeTransfer(user, toSend);\n            emit Claimed(user, token, toSend);\n        }\n    }\n\n    // =========================== Governance Functions ============================\n\n    /// @notice Pull reward amount from caller\n    //solhint-disable-next-line\n    function deposit_reward_token(IERC20 token, uint256 amount) external {\n        token.transferFrom(msg.sender, address(this), amount);\n    }\n\n    /// @notice Adds or removes trusted EOA\n    function toggleTrusted(address eoa) external onlyGovernorOrGuardian {\n        uint256 trustedStatus = 1 - trusted[eoa];\n        trusted[eoa] = trustedStatus;\n        emit TrustedToggled(eoa, trustedStatus == 1);\n    }\n\n    /// @notice Updates Merkle Tree\n    function updateTree(MerkleTree calldata _tree) external onlyTrusted {\n        tree = _tree;\n        emit TreeUpdated(_tree.merkleRoot, _tree.ipfsHash);\n    }\n\n    /// @notice Recovers any ERC20 token\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyGovernorOrGuardian {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    // =========================== Internal Functions ==============================\n\n    /// @notice Checks the validity of a proof\n    /// @param leaf Hashed leaf data, the starting point of the proof\n    /// @param proof Array of hashes forming a hash chain from leaf to root\n    /// @return true If proof is correct, else false\n    function _verifyProof(bytes32 leaf, bytes32[] memory proof) internal view returns (bool) {\n        bytes32 currentHash = leaf;\n        for (uint256 i = 0; i < proof.length; i += 1) {\n            if (currentHash < proof[i]) {\n                currentHash = keccak256(abi.encode(currentHash, proof[i]));\n            } else {\n                currentHash = keccak256(abi.encode(proof[i], currentHash));\n            }\n        }\n        return currentHash == tree.merkleRoot;\n    }\n}\n"
    },
    "contracts/interfaces/external/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Interface for WETH9\ninterface IWETH9 is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/agToken/AgTokenSideChainMultiBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./BaseAgTokenSideChain.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title AgTokenSideChainMultiBridge\n/// @author Angle Core Team\n/// @notice Contract for Angle agTokens on other chains than Ethereum mainnet\n/// @dev This contract supports bridge tokens having a minting right on the stablecoin (also referred to as the canonical\n/// or the native token)\n/// @dev References:\n///      - FRAX implementation: https://polygonscan.com/address/0x45c32fA6DF82ead1e2EF74d17b76547EDdFaFF89#code\n///      - QiDAO implementation: https://snowtrace.io/address/0x5c49b268c9841AFF1Cc3B0a418ff5c3442eE3F3b#code\ncontract AgTokenSideChainMultiBridge is BaseAgTokenSideChain {\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for fee computation\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    // =============================== Bridging Data ===============================\n\n    /// @notice Struct with some data about a specific bridge token\n    struct BridgeDetails {\n        // Limit on the balance of bridge token held by the contract: it is designed\n        // to reduce the exposure of the system to hacks\n        uint256 limit;\n        // Limit on the hourly volume of token minted through this bridge\n        // Technically the limit over a rolling hour is hourlyLimit x2 as hourly limit\n        // is enforced only between x:00 and x+1:00\n        uint256 hourlyLimit;\n        // Fee taken for swapping in and out the token\n        uint64 fee;\n        // Whether the associated token is allowed or not\n        bool allowed;\n        // Whether swapping in and out from the associated token is paused or not\n        bool paused;\n    }\n\n    /// @notice Maps a bridge token to data\n    mapping(address => BridgeDetails) public bridges;\n    /// @notice List of all bridge tokens\n    address[] public bridgeTokensList;\n    /// @notice Maps a bridge token to the associated hourly volume\n    mapping(address => mapping(uint256 => uint256)) public usage;\n    /// @notice Maps an address to whether it is exempt of fees for when it comes to swapping in and out\n    mapping(address => uint256) public isFeeExempt;\n    /// @notice Limit to the amount of tokens that can be sent from that chain to another chain\n    uint256 public chainTotalHourlyLimit;\n    /// @notice Usage per hour on that chain. Maps an hourly timestamp to the total volume swapped out on the chain\n    mapping(uint256 => uint256) public chainTotalUsage;\n\n    // ================================== Events ===================================\n\n    event BridgeTokenAdded(address indexed bridgeToken, uint256 limit, uint256 hourlyLimit, uint64 fee, bool paused);\n    event BridgeTokenToggled(address indexed bridgeToken, bool toggleStatus);\n    event BridgeTokenRemoved(address indexed bridgeToken);\n    event BridgeTokenFeeUpdated(address indexed bridgeToken, uint64 fee);\n    event BridgeTokenLimitUpdated(address indexed bridgeToken, uint256 limit);\n    event BridgeTokenHourlyLimitUpdated(address indexed bridgeToken, uint256 hourlyLimit);\n    event HourlyLimitUpdated(uint256 hourlyLimit);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event FeeToggled(address indexed theAddress, uint256 toggleStatus);\n\n    // =============================== Errors ================================\n\n    error AssetStillControlledInReserves();\n    error HourlyLimitExceeded();\n    error InvalidToken();\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error TooBigAmount();\n    error TooHighParameterValue();\n    error ZeroAddress();\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializes the `AgToken` contract\n    /// @param name_ Name of the token\n    /// @param symbol_ Symbol of the token\n    /// @param _treasury Reference to the `Treasury` contract associated to this agToken\n    /// @dev By default, agTokens are ERC-20 tokens with 18 decimals\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address _treasury\n    ) external {\n        _initialize(name_, symbol_, _treasury);\n    }\n\n    // =============================== Modifiers ===================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!ITreasury(treasury).isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!ITreasury(treasury).isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    // ==================== External Permissionless Functions ======================\n\n    /// @notice Returns the list of all supported bridge tokens\n    /// @dev Helpful for UIs\n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridgeTokensList;\n    }\n\n    /// @notice Returns the current volume for a bridge, for the current hour\n    /// @param bridgeToken Bridge used to mint\n    /// @dev Helpful for UIs\n    function currentUsage(address bridgeToken) external view returns (uint256) {\n        return usage[bridgeToken][block.timestamp / 3600];\n    }\n\n    /// @notice Returns the current total volume on the chain for the current hour\n    /// @dev Helpful for UIs\n    function currentTotalUsage() external view returns (uint256) {\n        return chainTotalUsage[block.timestamp / 3600];\n    }\n\n    /// @notice Mints the canonical token from a supported bridge token\n    /// @param bridgeToken Bridge token to use to mint\n    /// @param amount Amount of bridge tokens to send\n    /// @param to Address to which the stablecoin should be sent\n    /// @return Amount of the canonical stablecoin actually minted\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapIn(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n        uint256 balance = IERC20(bridgeToken).balanceOf(address(this));\n        if (balance + amount > bridgeDetails.limit) {\n            // In case someone maliciously sends tokens to this contract\n            // Or the limit changes\n            if (bridgeDetails.limit > balance) amount = bridgeDetails.limit - balance;\n            else {\n                amount = 0;\n            }\n        }\n\n        // Checking requirement on the hourly volume\n        uint256 hour = block.timestamp / 3600;\n        uint256 hourlyUsage = usage[bridgeToken][hour] + amount;\n        if (hourlyUsage > bridgeDetails.hourlyLimit) {\n            // Edge case when the hourly limit changes\n            if (bridgeDetails.hourlyLimit > usage[bridgeToken][hour])\n                amount = bridgeDetails.hourlyLimit - usage[bridgeToken][hour];\n            else {\n                amount = 0;\n            }\n        }\n        usage[bridgeToken][hour] = usage[bridgeToken][hour] + amount;\n\n        IERC20(bridgeToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 canonicalOut = amount;\n        // Computing fees\n        if (isFeeExempt[msg.sender] == 0) {\n            canonicalOut -= (canonicalOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        _mint(to, canonicalOut);\n        return canonicalOut;\n    }\n\n    /// @notice Burns the canonical token in exchange for a bridge token\n    /// @param bridgeToken Bridge token required\n    /// @param amount Amount of canonical tokens to burn\n    /// @param to Address to which the bridge token should be sent\n    /// @return Amount of bridge tokens actually sent back\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapOut(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n\n        uint256 hour = block.timestamp / 3600;\n        uint256 hourlyUsage = chainTotalUsage[hour] + amount;\n        // If the amount being swapped out exceeds the limit, we revert\n        // We don't want to change the amount being swapped out.\n        // The user can decide to send another tx with the correct amount to reach the limit\n        if (hourlyUsage > chainTotalHourlyLimit) revert HourlyLimitExceeded();\n        chainTotalUsage[hour] = hourlyUsage;\n\n        _burn(msg.sender, amount);\n        uint256 bridgeOut = amount;\n        if (isFeeExempt[msg.sender] == 0) {\n            bridgeOut -= (bridgeOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        IERC20(bridgeToken).safeTransfer(to, bridgeOut);\n        return bridgeOut;\n    }\n\n    // ======================= Governance Functions ================================\n\n    /// @notice Adds support for a bridge token\n    /// @param bridgeToken Bridge token to add: it should be a version of the stablecoin from another bridge\n    /// @param limit Limit on the balance of bridge token this contract could hold\n    /// @param hourlyLimit Limit on the hourly volume for this bridge\n    /// @param paused Whether swapping for this token should be paused or not\n    /// @param fee Fee taken upon swapping for or against this token\n    function addBridgeToken(\n        address bridgeToken,\n        uint256 limit,\n        uint256 hourlyLimit,\n        uint64 fee,\n        bool paused\n    ) external onlyGovernor {\n        if (bridges[bridgeToken].allowed || bridgeToken == address(0)) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        BridgeDetails memory _bridge;\n        _bridge.limit = limit;\n        _bridge.hourlyLimit = hourlyLimit;\n        _bridge.paused = paused;\n        _bridge.fee = fee;\n        _bridge.allowed = true;\n        bridges[bridgeToken] = _bridge;\n        bridgeTokensList.push(bridgeToken);\n        emit BridgeTokenAdded(bridgeToken, limit, hourlyLimit, fee, paused);\n    }\n\n    /// @notice Removes support for a token\n    /// @param bridgeToken Address of the bridge token to remove support for\n    function removeBridgeToken(address bridgeToken) external onlyGovernor {\n        if (IERC20(bridgeToken).balanceOf(address(this)) != 0) revert AssetStillControlledInReserves();\n        delete bridges[bridgeToken];\n        // Deletion from `bridgeTokensList` loop\n        uint256 bridgeTokensListLength = bridgeTokensList.length;\n        for (uint256 i = 0; i < bridgeTokensListLength - 1; i++) {\n            if (bridgeTokensList[i] == bridgeToken) {\n                // Replace the `bridgeToken` to remove with the last of the list\n                bridgeTokensList[i] = bridgeTokensList[bridgeTokensListLength - 1];\n                break;\n            }\n        }\n        // Remove last element in array\n        bridgeTokensList.pop();\n        emit BridgeTokenRemoved(bridgeToken);\n    }\n\n    /// @notice Recovers any ERC20 token\n    /// @dev Can be used to withdraw bridge tokens for them to be de-bridged on mainnet\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyGovernor {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Updates the `limit` amount for `bridgeToken`\n    function setLimit(address bridgeToken, uint256 limit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].limit = limit;\n        emit BridgeTokenLimitUpdated(bridgeToken, limit);\n    }\n\n    /// @notice Updates the `hourlyLimit` amount for `bridgeToken`\n    function setHourlyLimit(address bridgeToken, uint256 hourlyLimit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].hourlyLimit = hourlyLimit;\n        emit BridgeTokenHourlyLimitUpdated(bridgeToken, hourlyLimit);\n    }\n\n    /// @notice Updates the `chainTotalHourlyLimit` amount\n    function setChainTotalHourlyLimit(uint256 hourlyLimit) external onlyGovernorOrGuardian {\n        chainTotalHourlyLimit = hourlyLimit;\n        emit HourlyLimitUpdated(hourlyLimit);\n    }\n\n    /// @notice Updates the `fee` value for `bridgeToken`\n    function setSwapFee(address bridgeToken, uint64 fee) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        bridges[bridgeToken].fee = fee;\n        emit BridgeTokenFeeUpdated(bridgeToken, fee);\n    }\n\n    /// @notice Pauses or unpauses swapping in and out for a token\n    function toggleBridge(address bridgeToken) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bool pausedStatus = bridges[bridgeToken].paused;\n        bridges[bridgeToken].paused = !pausedStatus;\n        emit BridgeTokenToggled(bridgeToken, !pausedStatus);\n    }\n\n    /// @notice Toggles fees for the address `theAddress`\n    function toggleFeesForAddress(address theAddress) external onlyGovernorOrGuardian {\n        uint256 feeExemptStatus = 1 - isFeeExempt[theAddress];\n        isFeeExempt[theAddress] = feeExemptStatus;\n        emit FeeToggled(theAddress, feeExemptStatus);\n    }\n}\n"
    },
    "contracts/mock/MockStableMaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IAgToken.sol\";\n\ncontract MockStableMaster {\n    mapping(address => uint256) public poolManagerMap;\n\n    constructor() {}\n\n    function updateStocksUsers(uint256 amount, address poolManager) external {\n        poolManagerMap[poolManager] += amount;\n    }\n\n    function burnSelf(\n        IAgToken agToken,\n        uint256 amount,\n        address burner\n    ) external {\n        agToken.burnSelf(amount, burner);\n    }\n\n    function burnFrom(\n        IAgToken agToken,\n        uint256 amount,\n        address burner,\n        address sender\n    ) external {\n        agToken.burnFrom(amount, burner, sender);\n    }\n\n    function mint(\n        IAgToken agToken,\n        address account,\n        uint256 amount\n    ) external {\n        agToken.mint(account, amount);\n    }\n}\n"
    },
    "contracts/agToken/AgTokenIntermediateUpgrade.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/coreModule/IStableMaster.sol\";\n// OpenZeppelin may update its version of the ERC20PermitUpgradeable token\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\n/// @title AgTokenIntermediateUpgrade\n/// @author Angle Core Team\n/// @notice Base contract for agToken, that is to say Angle's stablecoins\n/// @dev This contract is used to create and handle the stablecoins of Angle protocol\n/// @dev It is still possible for any address to burn its agTokens without redeeming collateral in exchange\n/// @dev This contract is the upgraded version of the AgToken that was first deployed on Ethereum mainnet and is used to\n/// add other minters as needed by AMOs\ncontract AgTokenIntermediateUpgrade is ERC20PermitUpgradeable {\n    // ========================= References to other contracts =====================\n\n    /// @notice Reference to the `StableMaster` contract associated to this `AgToken`\n    address public stableMaster;\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializes the `AgToken` contract\n    /// @param name_ Name of the token\n    /// @param symbol_ Symbol of the token\n    /// @param stableMaster_ Reference to the `StableMaster` contract associated to this agToken\n    /// @dev By default, agTokens are ERC-20 tokens with 18 decimals\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address stableMaster_\n    ) external initializer {\n        __ERC20Permit_init(name_);\n        __ERC20_init(name_, symbol_);\n        require(stableMaster_ != address(0), \"0\");\n        stableMaster = stableMaster_;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ======= Added Parameters and Variables from the first implementation ========\n\n    /// @notice Checks whether an address has the right to mint agTokens\n    mapping(address => bool) public isMinter;\n\n    // =============================== Added Events ================================\n\n    event MinterToggled(address indexed minter);\n\n    // =============================== Setup Function ==============================\n\n    /// @notice Sets up the minter role and gives it to the governor\n    /// @dev This function just has to be called once\n    function setUpMinter() external {\n        address governor = 0xdC4e6DFe07EFCa50a197DF15D9200883eF4Eb1c8;\n        require(msg.sender == governor);\n        isMinter[governor] = true;\n        emit MinterToggled(governor);\n    }\n\n    // =============================== Modifiers ===================================\n\n    /// @notice Checks whether the sender has the minting right\n    modifier onlyMinter() {\n        require(isMinter[msg.sender] || msg.sender == stableMaster, \"35\");\n        _;\n    }\n\n    // ========================= External Functions ================================\n    // The following functions allow anyone to burn stablecoins without redeeming collateral\n    // in exchange for that\n\n    /// @notice Destroys `amount` token from the caller without giving collateral back\n    /// @param amount Amount to burn\n    /// @param poolManager Reference to the `PoolManager` contract for which the `stocksUsers` will\n    /// need to be updated\n    /// @dev When calling this function, people should specify the `poolManager` for which they want to decrease\n    /// the `stocksUsers`: this is a way for the protocol to maintain healthy accounting variables\n    function burnNoRedeem(uint256 amount, address poolManager) external {\n        _burn(msg.sender, amount);\n        IStableMaster(stableMaster).updateStocksUsers(amount, poolManager);\n    }\n\n    /// @notice Burns `amount` of agToken on behalf of another account without redeeming collateral back\n    /// @param account Account to burn on behalf of\n    /// @param amount Amount to burn\n    /// @param poolManager Reference to the `PoolManager` contract for which the `stocksUsers` will need to be updated\n    function burnFromNoRedeem(\n        address account,\n        uint256 amount,\n        address poolManager\n    ) external {\n        _burnFromNoRedeem(amount, account, msg.sender);\n        IStableMaster(stableMaster).updateStocksUsers(amount, poolManager);\n    }\n\n    // ======================= Minter Role Only Functions ==========================\n\n    /// @notice Burns `amount` tokens from a `burner` address\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @dev This method is to be called by a contract with a minter right on the AgToken after being\n    /// requested to do so by an address willing to burn tokens from its address\n    function burnSelf(uint256 amount, address burner) external onlyMinter {\n        _burn(burner, amount);\n    }\n\n    /// @notice Burns `amount` tokens from a `burner` address after being asked to by `sender`\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @param sender Address which requested the burn from `burner`\n    /// @dev This method is to be called by a contract with the minter right after being requested\n    /// to do so by a `sender` address willing to burn tokens from another `burner` address\n    /// @dev The method checks the allowance between the `sender` and the `burner`\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external onlyMinter {\n        _burnFromNoRedeem(amount, burner, sender);\n    }\n\n    /// @notice Lets the `StableMaster` contract or another whitelisted contract mint agTokens\n    /// @param account Address to mint to\n    /// @param amount Amount to mint\n    /// @dev The contracts allowed to issue agTokens are the `StableMaster` contract, `VaultManager` contracts\n    /// associated to this stablecoin as well as the flash loan module (if activated) and potentially contracts\n    /// whitelisted by governance\n    function mint(address account, uint256 amount) external onlyMinter {\n        _mint(account, amount);\n    }\n\n    // ======================= Minter Only Functions ===============================\n\n    /// @notice Adds a minter in the contract\n    /// @param minter Minter address to add\n    function addMinter(address minter) external onlyMinter {\n        isMinter[minter] = true;\n        emit MinterToggled(minter);\n    }\n\n    /// @notice Removes a minter from the contract\n    /// @param minter Minter address to remove\n    /// @dev This function can at the moment only be called by a minter wishing to revoke itself\n    function removeMinter(address minter) external {\n        require(msg.sender == minter && isMinter[msg.sender], \"36\");\n        isMinter[minter] = false;\n        emit MinterToggled(minter);\n    }\n\n    // ============================ Internal Function ==============================\n\n    /// @notice Internal version of the function `burnFromNoRedeem`\n    /// @param amount Amount to burn\n    /// @dev It is at the level of this function that allowance checks are performed\n    function _burnFromNoRedeem(\n        uint256 amount,\n        address burner,\n        address sender\n    ) internal {\n        if (burner != sender) {\n            uint256 currentAllowance = allowance(burner, sender);\n            require(currentAllowance >= amount, \"23\");\n            _approve(burner, sender, currentAllowance - amount);\n        }\n        _burn(burner, amount);\n    }\n}\n"
    },
    "contracts/reactor/BaseReactor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.12;\n\nimport \"./BaseReactorStorage.sol\";\n\n/// @title BaseReactor\n/// @notice Reactor for using a token as collateral for agTokens. ERC4646 tokenized Vault implementation.\n/// @author Angle Core Team, based on Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @dev A token used as an asset built to exploit this reactor could perform reentrancy attacks if not enough checks\n/// are performed: as such the protocol implements reentrancy checks on all external entry point\nabstract contract BaseReactor is BaseReactorStorage, ERC20Upgradeable, IERC721ReceiverUpgradeable, IERC4626 {\n    using SafeERC20 for IERC20;\n\n    /// @notice Initializes the `BaseReactor` contract and the underlying `VaultManager`\n    /// @param _name Name of the ERC4626 token\n    /// @param _symbol Symbol of the ERC4626 token\n    /// @param _vaultManager Underlying `VaultManager` used to borrow stablecoin\n    /// @param _lowerCF Lower Collateral Factor accepted without rebalancing\n    /// @param _targetCF Target Collateral Factor\n    /// @param _upperCF Upper Collateral Factor accepted without rebalancing\n    /// @param _protocolInterestShare Share of the profit (or losses) from strategies going to the protocol\n    function _initialize(\n        string memory _name,\n        string memory _symbol,\n        IVaultManager _vaultManager,\n        uint64 _lowerCF,\n        uint64 _targetCF,\n        uint64 _upperCF,\n        uint64 _protocolInterestShare\n    ) internal initializer {\n        __ERC20_init(_name, _symbol);\n        vaultManager = _vaultManager;\n        stablecoin = _vaultManager.stablecoin();\n        IERC20 _asset = _vaultManager.collateral();\n        treasury = _vaultManager.treasury();\n        oracle = _vaultManager.oracle();\n        vaultManagerDust = _vaultManager.dust();\n        asset = _asset;\n        _assetBase = 10**(IERC20Metadata(address(_asset)).decimals());\n        lastTime = block.timestamp;\n\n        vaultID = _vaultManager.createVault(address(this));\n\n        if (\n            0 == _lowerCF ||\n            _lowerCF > _targetCF ||\n            _targetCF > _upperCF ||\n            _upperCF > _vaultManager.collateralFactor() ||\n            _protocolInterestShare > BASE_PARAMS\n        ) revert InvalidSetOfParameters();\n        lowerCF = _lowerCF;\n        targetCF = _targetCF;\n        upperCF = _upperCF;\n        protocolInterestShare = _protocolInterestShare;\n\n        asset.approve(address(vaultManager), type(uint256).max);\n    }\n\n    // ============================== Modifiers ====================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!treasury.isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!treasury.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    // ========================= External Access Functions =========================\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets, address to) external nonReentrant returns (uint256 shares) {\n        (uint256 usedAssets, uint256 looseAssets) = _getAssets();\n        shares = _convertToShares(assets, usedAssets + looseAssets, 0);\n        if (shares == 0) revert ZeroShares();\n        _deposit(assets, shares, to, usedAssets, looseAssets + assets);\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address to) external nonReentrant returns (uint256 assets) {\n        (uint256 usedAssets, uint256 looseAssets) = _getAssets();\n        uint256 totalSupply = totalSupply();\n        assets = _convertToAssets(shares, usedAssets + looseAssets, totalSupply);\n        assets += (_convertToShares(assets, usedAssets + looseAssets, totalSupply) < shares ? 1 : 0);\n        _deposit(assets, shares, to, usedAssets, looseAssets + assets);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev The amount of assets specified should be smaller than the amount of assets controlled by the\n    /// reactor\n    /// @dev `assets` should also be inferior to maxWithdraw(from)\n    function withdraw(\n        uint256 assets,\n        address to,\n        address from\n    ) external nonReentrant returns (uint256 shares) {\n        (uint256 usedAssets, uint256 looseAssets) = _getAssets();\n        uint256 totalSupply = totalSupply();\n        shares = _convertToShares(assets, usedAssets + looseAssets, totalSupply);\n        shares += (_convertToAssets(shares, usedAssets + looseAssets, totalSupply) < assets ? 1 : 0);\n        _withdraw(assets, shares, to, from, usedAssets, looseAssets);\n    }\n\n    /// @notice Rebalances the underlying vault\n    function rebalance() external nonReentrant {\n        (uint256 usedAssets, uint256 looseAssets) = _getAssets();\n        _rebalance(0, usedAssets, looseAssets);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev `shares` should be inferior to maxRedeem(from)\n    function redeem(\n        uint256 shares,\n        address to,\n        address from\n    ) external nonReentrant returns (uint256 assets) {\n        (uint256 usedAssets, uint256 looseAssets) = _getAssets();\n        assets = _convertToAssets(shares, usedAssets + looseAssets, 0);\n        if (assets == 0) revert ZeroAssets();\n        _withdraw(assets, shares, to, from, usedAssets, looseAssets);\n    }\n\n    /// @notice Claims earned rewards\n    /// @param from Address to claim for\n    /// @return Amount claimed\n    function claim(address from) external nonReentrant returns (uint256) {\n        _updateAccumulator(from);\n        return _claim(from);\n    }\n\n    // ============================= View Functions ================================\n\n    /// @inheritdoc IERC4626\n    function totalAssets() public view returns (uint256 assets) {\n        (uint256 usedAssets, uint256 looseAssets) = _getAssets();\n        assets = usedAssets + looseAssets;\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        return _convertToShares(assets, totalAssets(), 0);\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        return _convertToAssets(shares, totalAssets(), 0);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets) external view returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares) external view returns (uint256) {\n        uint256 totalAssetAmount = totalAssets();\n        uint256 totalSupply = totalSupply();\n        uint256 assets = _convertToAssets(shares, totalAssetAmount, totalSupply);\n        return assets + (_convertToShares(assets, totalAssetAmount, totalSupply) < shares ? 1 : 0);\n    }\n\n    /// @notice Computes how many shares one would need to withdraw assets\n    /// @param assets Amount of asset to withdraw\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) external view returns (uint256) {\n        uint256 totalAssetAmount = totalAssets();\n        uint256 totalSupply = totalSupply();\n        uint256 shares = _convertToShares(assets, totalAssetAmount, totalSupply);\n        return shares + (_convertToAssets(shares, totalAssetAmount, totalSupply) < assets ? 1 : 0);\n    }\n\n    /// @notice Computes how many assets one would get by burning shares\n    /// @param shares Amount of shares to burn\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares) external view returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev Technically, the maximum deposit could be less than the max uint256\n    /// if there is a `debtCeiling` in the associated `VaultManager`. This implementation\n    /// assumes that the `VaultManager` does not have any debt ceiling\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) external view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address user) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf(user));\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address user) external view virtual returns (uint256) {\n        return balanceOf(user);\n    }\n\n    /// @inheritdoc IERC721ReceiverUpgradeable\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) external view returns (bytes4) {\n        if (msg.sender != address(vaultManager)) revert NotVaultManager();\n        return this.onERC721Received.selector;\n    }\n\n    // =========================== Internal Functions ==============================\n\n    /// @notice Gets the assets controlled by the reactor: those in the associated vaultManager\n    /// as well as those in the contract\n    /// @return usedAssets Amount of the `asset` in the associated `VaultManager`\n    /// @return looseAssets Amount of the `asset` in the contract\n    function _getAssets() internal view returns (uint256 usedAssets, uint256 looseAssets) {\n        (usedAssets, ) = vaultManager.vaultData(vaultID);\n        looseAssets = asset.balanceOf(address(this));\n    }\n\n    /// @notice Converts an amount of assets to shares of the reactor from an amount of assets controlled by the vault\n    /// @param assets Amount of assets to convert\n    /// @param totalAssetAmount Total amount of asset controlled by the vault\n    /// @param _supply Optional value of the total supply of the reactor, it is recomputed if zero\n    /// @return Corresponding amount of shares\n    function _convertToShares(\n        uint256 assets,\n        uint256 totalAssetAmount,\n        uint256 _supply\n    ) internal view returns (uint256) {\n        uint256 supply = _supply == 0 ? totalSupply() : _supply;\n        return supply == 0 ? assets : (assets * supply) / totalAssetAmount;\n    }\n\n    /// @notice Converts an amount of shares of the reactor to assets\n    /// @param shares Amount of shares to convert\n    /// @param totalAssetAmount Total amount of asset controlled by the vault\n    /// @param _supply Optional value of the total supply of the reactor, it is recomputed if zero\n    /// @return Corresponding amount of assets\n    /// @dev It is at the level of this function that losses from liquidations are taken into account, because this\n    /// reduces the `totalAssetAmount` and hence the amount of assets you are entitled to get from your shares\n    function _convertToAssets(\n        uint256 shares,\n        uint256 totalAssetAmount,\n        uint256 _supply\n    ) internal view returns (uint256) {\n        uint256 supply = _supply == 0 ? totalSupply() : _supply;\n        return supply == 0 ? shares : (shares * totalAssetAmount) / supply;\n    }\n\n    /// @notice Handles the new value of the debt: propagates a loss to the claimable rewards\n    /// or a gain depending on the evolution of this debt\n    /// @param currentDebt Current value of the debt\n    /// @notice In the case where you get liquidated, you actually record a gain in stablecoin,\n    /// which is normal to compensate for the decrease of the collateral in the vault\n    /// @dev In case where a loss (like from interest taken by the `VaultManager`) is planned, then stakeholders\n    /// are incentivized to front run it and claim their rewards in advance. In normal times, this reactor therefore\n    /// works well mostly with `VaultManager` on which there are no interest taken (and no borrowing fees)\n    function _handleCurrentDebt(uint256 currentDebt) internal {\n        if (lastDebt >= currentDebt) {\n            // This happens if you have been liquidated or if debt has been paid on your behalf\n            _handleGain(lastDebt - currentDebt);\n        } else {\n            _handleLoss(currentDebt - lastDebt);\n        }\n    }\n\n    /// @notice Propagates a gain to the claimable rewards\n    /// @param gain Gain to propagate\n    function _handleGain(uint256 gain) internal {\n        uint256 currentLossVariable = currentLoss;\n        if (currentLossVariable >= gain) {\n            currentLoss -= gain;\n        } else {\n            claimableRewards += gain - currentLossVariable;\n            currentLoss = 0;\n        }\n    }\n\n    /// @notice Propagates a loss to the claimable rewards and/or currentLoss\n    /// @param loss Loss to propagate\n    function _handleLoss(uint256 loss) internal {\n        if (claimableRewards >= loss) {\n            claimableRewards -= loss;\n        } else {\n            currentLoss += loss - claimableRewards;\n            claimableRewards = 0;\n        }\n    }\n\n    /// @notice Rebalances the underlying vault\n    /// @param toWithdraw Amount of assets to withdraw\n    /// @param usedAssets Amount of assets in the vault\n    /// @param looseAssets Amount of assets already in the contract\n    /// @dev `toWithdraw` is always lower than managed assets (`= usedAssets+looseAssets`): indeed if it was superior\n    /// it would mean either\n    /// - that the `withdraw` function was called with an amount of assets greater than the amount of asset controlled\n    /// by the reactor\n    /// - or that the `redeem` function was called with an amount of shares greater than the total supply\n    /// @dev `usedAssets` and `looseAssets` are passed as parameters here to avoid performing the same calculation twice\n    function _rebalance(\n        uint256 toWithdraw,\n        uint256 usedAssets,\n        uint256 looseAssets\n    ) internal {\n        uint256 debt = vaultManager.getVaultDebt(vaultID);\n        _handleCurrentDebt(debt);\n        lastDebt = debt;\n\n        uint256 toRepay;\n        uint256 toBorrow;\n\n        (uint256 futureStablecoinsInVault, uint256 collateralFactor) = _getFutureDebtAndCF(\n            toWithdraw,\n            usedAssets,\n            looseAssets,\n            debt,\n            oracle.read()\n        );\n\n        // 1 action to add or remove collateral + 1 additional action if we need to borrow or repay\n        uint8 len = (collateralFactor >= upperCF) ||\n            (collateralFactor <= lowerCF && futureStablecoinsInVault > vaultManagerDust)\n            ? 2\n            : 1;\n\n        ActionType[] memory actions = new ActionType[](len);\n        bytes[] memory datas = new bytes[](len);\n\n        len = 0;\n\n        if (toWithdraw <= looseAssets) {\n            // Add Collateral\n            actions[len] = ActionType.addCollateral;\n            datas[len] = abi.encodePacked(vaultID, looseAssets - toWithdraw);\n            len += 1;\n        }\n\n        // Dust is also handled here to avoid reverting calls: if repaying the debt would leave a dusty\n        // amount then all the debt is repaid\n        // If borrowing would only create a dusty debt amount, then nothing happens\n        if (collateralFactor >= upperCF) {\n            // If the `collateralFactor` is too high, then too much has been borrowed\n            // and stablecoins should be repaid\n            actions[len] = ActionType.repayDebt;\n            toRepay = debt - futureStablecoinsInVault;\n            lastDebt -= toRepay;\n            if (futureStablecoinsInVault <= vaultManagerDust) {\n                // If this happens in a moment at which the reactor has a loss, then it will not be able\n                // to repay it all, and the function will revert\n                toRepay = type(uint256).max;\n                lastDebt = 0;\n            }\n            datas[len] = abi.encodePacked(vaultID, toRepay);\n            len += 1;\n        } else if (collateralFactor <= lowerCF && futureStablecoinsInVault > vaultManagerDust) {\n            // If the `collateralFactor` is too low, then stablecoins can be borrowed and later\n            // invested in strategies\n            toBorrow = futureStablecoinsInVault - debt;\n            actions[len] = ActionType.borrow;\n            datas[len] = abi.encodePacked(vaultID, toBorrow);\n            len += 1;\n            // We don't directly update the debt in this contract as there may be some rounding issues\n        }\n\n        if (toWithdraw > looseAssets) {\n            // Removes Collateral\n            actions[len] = ActionType.removeCollateral;\n            datas[len] = abi.encodePacked(vaultID, toWithdraw - looseAssets);\n        }\n\n        if (toRepay > 0) {\n            toRepay = toRepay == type(uint256).max ? debt : toRepay;\n            _pull(toRepay);\n        }\n\n        PaymentData memory paymentData = vaultManager.angle(\n            actions,\n            datas,\n            address(this),\n            address(this),\n            address(this),\n            \"\"\n        );\n\n        // VaultManagers always round to their advantages + there can be a borrow fee taken\n        if (toBorrow > 0) {\n            lastDebt += paymentData.stablecoinAmountToGive;\n            // If there is a borrow fee, then it will be seen as a loss at the next rebalance\n            _push(paymentData.stablecoinAmountToGive);\n        }\n    }\n\n    /// @notice Computes future debt to the `vaultManager` and the collateral factor of the current debt with future assets\n    /// @param toWithdraw Amount of assets to withdraw\n    /// @param usedAssets Amount of assets in the vault\n    /// @param looseAssets Amount of assets already in the contract\n    /// @param debt Current debt owed to the `vaultManager`\n    /// @param oracleRate Exchange rate from asset to stablecoin\n    /// @return futureStablecoinsInVault Future amount of stablecoins borrowed in the vault\n    /// if this vault is at `targetCF` at the end of the call\n    /// @return collateralFactor Collateral factor of the vault if its debt remains unchanged but `toWithdraw` collateral\n    /// is removed from it\n    function _getFutureDebtAndCF(\n        uint256 toWithdraw,\n        uint256 usedAssets,\n        uint256 looseAssets,\n        uint256 debt,\n        uint256 oracleRate\n    ) internal view returns (uint256 futureStablecoinsInVault, uint256 collateralFactor) {\n        // We're first using as an intermediate in this variable something that does not correspond\n        // to the future amount of stablecoins borrowed in the vault: it is the future collateral amount in\n        // the vault expressed in stablecoin value and in a custom base\n        futureStablecoinsInVault = (usedAssets + looseAssets - toWithdraw) * oracleRate;\n        // The function will revert above if `toWithdraw` is too big\n\n        if (futureStablecoinsInVault == 0) collateralFactor = type(uint256).max;\n        else {\n            collateralFactor = (debt * BASE_PARAMS * _assetBase) / futureStablecoinsInVault;\n        }\n        // This is the targeted debt at the end of the call, which might not be reached if the collateral\n        // factor is not moved enough\n        futureStablecoinsInVault = (futureStablecoinsInVault * targetCF) / (BASE_PARAMS * _assetBase);\n    }\n\n    /// @notice Virtual function to invest stablecoins\n    /// @param amount Amount of new stablecoins managed\n    /// @return amountInvested Amount invested in the strategy\n    /// @dev Calling this function should eventually trigger something regarding strategies depending\n    /// on a threshold\n    function _push(uint256 amount) internal virtual returns (uint256 amountInvested) {}\n\n    /// @notice Virtual function to withdraw stablecoins to the reactor: full amounts may not be available\n    /// @param amount Amount needed at the end of the call\n    /// @return amountAvailable Amount available in the contracts, it's like a new `looseAssets` value\n    function _pull(uint256 amount) internal virtual returns (uint256 amountAvailable) {}\n\n    /// @notice Claims rewards earned by a user\n    /// @param from Address to claim rewards from\n    /// @return amount Amount claimed by the user\n    /// @dev Function will revert if there has been no mint\n    function _claim(address from) internal returns (uint256 amount) {\n        amount = (claimableRewards * rewardsAccumulatorOf[from]) / (rewardsAccumulator - claimedRewardsAccumulator);\n        uint256 amountAvailable = _pull(amount);\n        // If we cannot pull enough from the strat then `claim` has no effect\n        if (amountAvailable >= amount) {\n            claimedRewardsAccumulator += rewardsAccumulatorOf[from];\n            rewardsAccumulatorOf[from] = 0;\n            lastTimeOf[from] = block.timestamp;\n            claimableRewards -= amount;\n            stablecoin.transfer(from, amount);\n        }\n    }\n\n    /// @notice Updates global and `msg.sender` accumulator and rewards share\n    /// @param from Address balance changed\n    function _updateAccumulator(address from) internal {\n        rewardsAccumulator += (block.timestamp - lastTime) * totalSupply();\n        lastTime = block.timestamp;\n\n        // This will be 0 on the first deposit since the balance is initialized later\n        rewardsAccumulatorOf[from] += (block.timestamp - lastTimeOf[from]) * balanceOf(from);\n        lastTimeOf[from] = block.timestamp;\n    }\n\n    /// @notice Internal function for `deposit` and `mint`\n    /// @dev This function takes `usedAssets` and `looseAssets` as parameters to avoid repeated external calls\n    function _deposit(\n        uint256 assets,\n        uint256 shares,\n        address to,\n        uint256 usedAssets,\n        uint256 looseAssets\n    ) internal {\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n        _updateAccumulator(to);\n        _mint(to, shares);\n\n        emit Deposit(msg.sender, to, assets, shares);\n\n        _rebalance(0, usedAssets, looseAssets);\n    }\n\n    /// @notice Internal function for `redeem` and `withdraw`\n    /// @dev This function takes `usedAssets` and `looseAssets` as parameters to avoid repeated external calls\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address to,\n        address from,\n        uint256 usedAssets,\n        uint256 looseAssets\n    ) internal {\n        if (msg.sender != from) {\n            uint256 currentAllowance = allowance(from, msg.sender);\n            if (currentAllowance < shares) revert TransferAmountExceedsAllowance();\n            if (currentAllowance != type(uint256).max) {\n                unchecked {\n                    _approve(from, msg.sender, currentAllowance - shares);\n                }\n            }\n        }\n\n        _updateAccumulator(from);\n        _burn(from, shares);\n\n        _rebalance(assets, usedAssets, looseAssets);\n\n        _claim(from);\n\n        emit Withdraw(from, to, assets, shares);\n        asset.safeTransfer(to, assets);\n    }\n\n    // ======================== Governance Functions ===============================\n\n    /// @notice Changes the reference to the `oracle` contract\n    /// @dev This is a permissionless function anyone can call to make sure that the oracle\n    /// contract of the `VaultManager` is the same as the oracle contract of this contract\n    function setOracle() external {\n        oracle = vaultManager.oracle();\n    }\n\n    /// @notice Changes the treasury contract\n    /// @dev Like the function above, this permissionless function just adjusts the treasury to\n    /// the address of the treasury contract from the `VaultManager` in case it has been modified\n    function setTreasury() external {\n        treasury = vaultManager.treasury();\n    }\n\n    /// @notice Changes the dust parameter by querying the `VaultManager`\n    function setDust() external {\n        vaultManagerDust = vaultManager.dust();\n    }\n\n    /// @notice Sets parameters encoded as uint64\n    /// @param param Value for the parameter\n    /// @param what Parameter to change\n    /// @dev This function performs the required checks when updating a parameter\n    function setUint64(uint64 param, bytes32 what) external onlyGovernorOrGuardian {\n        if (what == \"lowerCF\") {\n            if (0 == param || param > targetCF) revert InvalidParameterValue();\n            lowerCF = param;\n        } else if (what == \"targetCF\") {\n            if (lowerCF > param || param > upperCF) revert InvalidParameterValue();\n            targetCF = param;\n        } else if (what == \"upperCF\") {\n            if (targetCF > param || param > vaultManager.collateralFactor()) revert InvalidParameterValue();\n            upperCF = param;\n        } else if (what == \"protocolInterestShare\") {\n            if (param > BASE_PARAMS) revert TooHighParameterValue();\n            protocolInterestShare = param;\n        } else {\n            revert InvalidParameterType();\n        }\n        emit FiledUint64(param, what);\n    }\n\n    function setSurplusManager(address _newSurplusManager) external onlyGovernorOrGuardian {\n        if (_newSurplusManager == address(0)) revert ZeroAddress();\n        surplusManager = _newSurplusManager;\n    }\n\n    /// @notice Allows to recover any ERC20 token, including the asset managed by the reactor\n    /// @param tokenAddress Address of the token to recover\n    /// @param to Address of the contract to send collateral to\n    /// @param amountToRecover Amount of collateral to transfer\n    /// @dev Can be used to handle partial liquidation and debt repayment in case it is needed: in this\n    /// case governance can withdraw assets, swap in stablecoins to repay debt\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyGovernor {\n        if (tokenAddress == address(stablecoin)) revert InvalidToken();\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Pulls the fees accumulated by the protocol from its strategies\n    /// @param to Address to which tokens should be sent\n    function pushProtocolFees(address to) external {\n        if (to == address(0)) revert ZeroAddress();\n        if (to != surplusManager) {\n            if (!treasury.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        }\n        uint256 amountToRecover = protocolInterestAccumulated;\n        uint256 amountAvailable = _pull(amountToRecover);\n        amountToRecover = amountToRecover <= amountAvailable ? amountToRecover : amountAvailable;\n        protocolInterestAccumulated -= amountToRecover;\n        stablecoin.transfer(to, amountToRecover);\n    }\n}\n\ncontract Reactor is BaseReactor {\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        IVaultManager _vaultManager,\n        uint64 _lowerCF,\n        uint64 _targetCF,\n        uint64 _upperCF,\n        uint64 _protocolInterestShare\n    ) external {\n        _initialize(_name, _symbol, _vaultManager, _lowerCF, _targetCF, _upperCF, _protocolInterestShare);\n    }\n}\n"
    },
    "contracts/interfaces/external/euler/IEulerMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Forked from https://github.com/euler-xyz/euler-interfaces\npragma solidity >=0.8.12;\n\n/// @notice Main storage contract for the Euler system\ninterface IEulerConstants {\n    /// @notice gives the maxExternalAmount in base 18\n    //solhint-disable-next-line\n    function MAX_SANE_AMOUNT() external view returns (uint256);\n}\n\n/// @notice Main storage contract for the Euler system\ninterface IEuler {\n    /// @notice Lookup the current implementation contract for a module\n    /// @param moduleId Fixed constant that refers to a module type (ie MODULEID__ETOKEN)\n    /// @return An internal address specifies the module's implementation code\n    function moduleIdToImplementation(uint256 moduleId) external view returns (address);\n\n    /// @notice Lookup a proxy that can be used to interact with a module (only valid for single-proxy modules)\n    /// @param moduleId Fixed constant that refers to a module type (ie MODULEID__MARKETS)\n    /// @return An address that should be cast to the appropriate module interface, ie IEulerMarkets(moduleIdToProxy(2))\n    function moduleIdToProxy(uint256 moduleId) external view returns (address);\n\n    /// @notice Euler-related configuration for an asset\n    struct AssetConfig {\n        address eTokenAddress;\n        bool borrowIsolated;\n        uint32 collateralFactor;\n        uint32 borrowFactor;\n        uint24 twapWindow;\n    }\n}\n\n/// @notice Activating and querying markets, and maintaining entered markets lists\ninterface IEulerMarkets {\n    /// @notice Create an Euler pool and associated EToken and DToken addresses.\n    /// @param underlying The address of an ERC20-compliant token. There must be an initialised uniswap3 pool for the underlying/reference asset pair.\n    /// @return The created EToken, or the existing EToken if already activated.\n    function activateMarket(address underlying) external returns (address);\n\n    /// @notice Create a pToken and activate it on Euler. pTokens are protected wrappers around assets that prevent borrowing.\n    /// @param underlying The address of an ERC20-compliant token. There must already be an activated market on Euler for this underlying, and it must have a non-zero collateral factor.\n    /// @return The created pToken, or an existing one if already activated.\n    function activatePToken(address underlying) external returns (address);\n\n    /// @notice Given an underlying, lookup the associated EToken\n    /// @param underlying Token address\n    /// @return EToken address, or address(0) if not activated\n    function underlyingToEToken(address underlying) external view returns (address);\n\n    /// @notice Given an underlying, lookup the associated DToken\n    /// @param underlying Token address\n    /// @return DToken address, or address(0) if not activated\n    function underlyingToDToken(address underlying) external view returns (address);\n\n    /// @notice Given an underlying, lookup the associated PToken\n    /// @param underlying Token address\n    /// @return PToken address, or address(0) if it doesn't exist\n    function underlyingToPToken(address underlying) external view returns (address);\n\n    /// @notice Looks up the Euler-related configuration for a token, and resolves all default-value placeholders to their currently configured values.\n    /// @param underlying Token address\n    /// @return Configuration struct\n    function underlyingToAssetConfig(address underlying) external view returns (IEuler.AssetConfig memory);\n\n    /// @notice Looks up the Euler-related configuration for a token, and returns it unresolved (with default-value placeholders)\n    /// @param underlying Token address\n    /// @return config Configuration struct\n    function underlyingToAssetConfigUnresolved(address underlying)\n        external\n        view\n        returns (IEuler.AssetConfig memory config);\n\n    /// @notice Given an EToken address, looks up the associated underlying\n    /// @param eToken EToken address\n    /// @return underlying Token address\n    function eTokenToUnderlying(address eToken) external view returns (address underlying);\n\n    /// @notice Given an EToken address, looks up the associated DToken\n    /// @param eToken EToken address\n    /// @return dTokenAddr DToken address\n    function eTokenToDToken(address eToken) external view returns (address dTokenAddr);\n\n    /// @notice Looks up an asset's currently configured interest rate model\n    /// @param underlying Token address\n    /// @return Module ID that represents the interest rate model (IRM)\n    function interestRateModel(address underlying) external view returns (uint256);\n\n    /// @notice Retrieves the current interest rate for an asset\n    /// @param underlying Token address\n    /// @return The interest rate in yield-per-second, scaled by 10**27\n    function interestRate(address underlying) external view returns (int96);\n\n    /// @notice Retrieves the current interest rate accumulator for an asset\n    /// @param underlying Token address\n    /// @return An opaque accumulator that increases as interest is accrued\n    function interestAccumulator(address underlying) external view returns (uint256);\n\n    /// @notice Retrieves the reserve fee in effect for an asset\n    /// @param underlying Token address\n    /// @return Amount of interest that is redirected to the reserves, as a fraction scaled by RESERVE_FEE_SCALE (4e9)\n    function reserveFee(address underlying) external view returns (uint32);\n\n    /// @notice Retrieves the pricing config for an asset\n    /// @param underlying Token address\n    /// @return pricingType (1=pegged, 2=uniswap3, 3=forwarded)\n    /// @return pricingParameters If uniswap3 pricingType then this represents the uniswap pool fee used, otherwise unused\n    /// @return pricingForwarded If forwarded pricingType then this is the address prices are forwarded to, otherwise address(0)\n    function getPricingConfig(address underlying)\n        external\n        view\n        returns (\n            uint16 pricingType,\n            uint32 pricingParameters,\n            address pricingForwarded\n        );\n\n    /// @notice Retrieves the list of entered markets for an account (assets enabled for collateral or borrowing)\n    /// @param account User account\n    /// @return List of underlying token addresses\n    function getEnteredMarkets(address account) external view returns (address[] memory);\n\n    /// @notice Add an asset to the entered market list, or do nothing if already entered\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param newMarket Underlying token address\n    function enterMarket(uint256 subAccountId, address newMarket) external;\n\n    /// @notice Remove an asset from the entered market list, or do nothing if not already present\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param oldMarket Underlying token address\n    function exitMarket(uint256 subAccountId, address oldMarket) external;\n}\n\n/// @notice Definition of callback method that deferLiquidityCheck will invoke on your contract\ninterface IDeferredLiquidityCheck {\n    function onDeferredLiquidityCheck(bytes memory data) external;\n}\n\n/// @notice Batch executions, liquidity check deferrals, and interfaces to fetch prices and account liquidity\ninterface IEulerExec {\n    /// @notice Liquidity status for an account, either in aggregate or for a particular asset\n    struct LiquidityStatus {\n        uint256 collateralValue;\n        uint256 liabilityValue;\n        uint256 numBorrows;\n        bool borrowIsolated;\n    }\n\n    /// @notice Aggregate struct for reporting detailed (per-asset) liquidity for an account\n    struct AssetLiquidity {\n        address underlying;\n        LiquidityStatus status;\n    }\n\n    /// @notice Single item in a batch request\n    struct EulerBatchItem {\n        bool allowError;\n        address proxyAddr;\n        bytes data;\n    }\n\n    /// @notice Single item in a batch response\n    struct EulerBatchItemResponse {\n        bool success;\n        bytes result;\n    }\n\n    /// @notice Compute aggregate liquidity for an account\n    /// @param account User address\n    /// @return status Aggregate liquidity (sum of all entered assets)\n    function liquidity(address account) external returns (LiquidityStatus memory status);\n\n    /// @notice Compute detailed liquidity for an account, broken down by asset\n    /// @param account User address\n    /// @return assets List of user's entered assets and each asset's corresponding liquidity\n    function detailedLiquidity(address account) external returns (AssetLiquidity[] memory assets);\n\n    /// @notice Retrieve Euler's view of an asset's price\n    /// @param underlying Token address\n    /// @return twap Time-weighted average price\n    /// @return twapPeriod TWAP duration, either the twapWindow value in AssetConfig, or less if that duration not available\n    function getPrice(address underlying) external returns (uint256 twap, uint256 twapPeriod);\n\n    /// @notice Retrieve Euler's view of an asset's price, as well as the current marginal price on uniswap\n    /// @param underlying Token address\n    /// @return twap Time-weighted average price\n    /// @return twapPeriod TWAP duration, either the twapWindow value in AssetConfig, or less if that duration not available\n    /// @return currPrice The current marginal price on uniswap3 (informational: not used anywhere in the Euler protocol)\n    function getPriceFull(address underlying)\n        external\n        returns (\n            uint256 twap,\n            uint256 twapPeriod,\n            uint256 currPrice\n        );\n\n    /// @notice Defer liquidity checking for an account, to perform rebalancing, flash loans, etc. msg.sender must implement IDeferredLiquidityCheck\n    /// @param account The account to defer liquidity for. Usually address(this), although not always\n    /// @param data Passed through to the onDeferredLiquidityCheck() callback, so contracts don't need to store transient data in storage\n    function deferLiquidityCheck(address account, bytes memory data) external;\n\n    /// @notice Execute several operations in a single transaction\n    /// @param items List of operations to execute\n    /// @param deferLiquidityChecks List of user accounts to defer liquidity checks for\n    /// @return List of operation results\n    function batchDispatch(EulerBatchItem[] calldata items, address[] calldata deferLiquidityChecks)\n        external\n        returns (EulerBatchItemResponse[] memory);\n\n    /// @notice Results of a batchDispatch, but with extra information\n    struct EulerBatchExtra {\n        EulerBatchItemResponse[] responses;\n        uint256 gasUsed;\n        AssetLiquidity[][] liquidities;\n    }\n\n    /// @notice Call batchDispatch, but return extra information. Only intended to be used with callStatic.\n    /// @param items List of operations to execute\n    /// @param deferLiquidityChecks List of user accounts to defer liquidity checks for\n    /// @param queryLiquidity List of user accounts to return detailed liquidity information for\n    /// @return output Structure with extra information\n    function batchDispatchExtra(\n        EulerBatchItem[] calldata items,\n        address[] calldata deferLiquidityChecks,\n        address[] calldata queryLiquidity\n    ) external returns (EulerBatchExtra memory output);\n\n    /// @notice Enable average liquidity tracking for your account. Operations will cost more gas, but you may get additional benefits when performing liquidations\n    /// @param subAccountId subAccountId 0 for primary, 1-255 for a sub-account.\n    /// @param delegate An address of another account that you would allow to use the benefits of your account's average liquidity (use the null address if you don't care about this). The other address must also reciprocally delegate to your account.\n    /// @param onlyDelegate Set this flag to skip tracking average liquidity and only set the delegate.\n    function trackAverageLiquidity(\n        uint256 subAccountId,\n        address delegate,\n        bool onlyDelegate\n    ) external;\n\n    /// @notice Disable average liquidity tracking for your account and remove delegate\n    /// @param subAccountId subAccountId 0 for primary, 1-255 for a sub-account\n    function unTrackAverageLiquidity(uint256 subAccountId) external;\n\n    /// @notice Retrieve the average liquidity for an account\n    /// @param account User account (xor in subAccountId, if applicable)\n    /// @return The average liquidity, in terms of the reference asset, and post risk-adjustment\n    function getAverageLiquidity(address account) external returns (uint256);\n\n    /// @notice Retrieve the average liquidity for an account or a delegate account, if set\n    /// @param account User account (xor in subAccountId, if applicable)\n    /// @return The average liquidity, in terms of the reference asset, and post risk-adjustment\n    function getAverageLiquidityWithDelegate(address account) external returns (uint256);\n\n    /// @notice Retrieve the account which delegates average liquidity for an account, if set\n    /// @param account User account (xor in subAccountId, if applicable)\n    /// @return The average liquidity delegate account\n    function getAverageLiquidityDelegateAccount(address account) external view returns (address);\n\n    /// @notice Transfer underlying tokens from sender's wallet into the pToken wrapper. Allowance should be set for the euler address.\n    /// @param underlying Token address\n    /// @param amount The amount to wrap in underlying units\n    function pTokenWrap(address underlying, uint256 amount) external;\n\n    /// @notice Transfer underlying tokens from the pToken wrapper to the sender's wallet.\n    /// @param underlying Token address\n    /// @param amount The amount to unwrap in underlying units\n    function pTokenUnWrap(address underlying, uint256 amount) external;\n}\n\n/// @notice Tokenised representation of assets\ninterface IEulerEToken is IEulerConstants {\n    /// @notice Pool name, ie \"Euler Pool: DAI\"\n    function name() external view returns (string memory);\n\n    /// @notice Pool symbol, ie \"eDAI\"\n    function symbol() external view returns (string memory);\n\n    /// @notice Decimals, always normalised to 18.\n    function decimals() external pure returns (uint8);\n\n    /// @notice Sum of all balances, in internal book-keeping units (non-increasing)\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Sum of all balances, in underlying units (increases as interest is earned)\n    function totalSupplyUnderlying() external view returns (uint256);\n\n    /// @notice Balance of a particular account, in internal book-keeping units (non-increasing)\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Balance of a particular account, in underlying units (increases as interest is earned)\n    function balanceOfUnderlying(address account) external view returns (uint256);\n\n    /// @notice Balance of the reserves, in internal book-keeping units (non-increasing)\n    function reserveBalance() external view returns (uint256);\n\n    /// @notice Balance of the reserves, in underlying units (increases as interest is earned)\n    function reserveBalanceUnderlying() external view returns (uint256);\n\n    /// @notice Updates interest accumulator and totalBorrows, credits reserves, re-targets interest rate, and logs asset status\n    function touch() external;\n\n    /// @notice Transfer underlying tokens from sender to the Euler pool, and increase account's eTokens\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param amount In underlying units (use max uint256 for full underlying token balance)\n    function deposit(uint256 subAccountId, uint256 amount) external;\n\n    /// @notice Transfer underlying tokens from Euler pool to sender, and decrease account's eTokens\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param amount In underlying units (use max uint256 for full pool balance)\n    function withdraw(uint256 subAccountId, uint256 amount) external;\n}\n"
    },
    "contracts/mock/MockReactor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.12;\n\nimport \"../reactor/BaseReactor.sol\";\n\ncontract MockReactor is BaseReactor {\n    uint256 public counter;\n    uint256 public multiplier;\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        IVaultManager _vaultManager,\n        uint64 _lowerCF,\n        uint64 _targetCF,\n        uint64 _upperCF,\n        uint64 _protocolInterestShare\n    ) external {\n        _initialize(_name, _symbol, _vaultManager, _lowerCF, _targetCF, _upperCF, _protocolInterestShare);\n        multiplier = 10**9;\n    }\n\n    function _pull(uint256 amount) internal override returns (uint256) {\n        counter += 1;\n        return (amount * multiplier) / 10**9;\n    }\n\n    function increaseAccumulator(uint256 amount) external {\n        protocolInterestAccumulated += amount;\n    }\n\n    function setMultiplier(uint256 _multiplier) external {\n        multiplier = _multiplier;\n    }\n}\n"
    },
    "contracts/mock/MockToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    uint8 internal _decimal;\n    mapping(address => bool) public minters;\n    address public treasury;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) ERC20(name_, symbol_) {\n        _decimal = decimal_;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimal;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function setAllowance(address from, address to) public {\n        _approve(from, to, type(uint256).max);\n    }\n\n    function burnSelf(uint256 amount, address account) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function addMinter(address minter) public {\n        minters[minter] = true;\n    }\n\n    function removeMinter(address minter) public {\n        minters[minter] = false;\n    }\n\n    function setTreasury(address _treasury) public {\n        treasury = _treasury;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/external/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n * This contract was fully forked from OpenZeppelin `ProxyAdmin`\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{ value: msg.value }(implementation, data);\n    }\n}\n"
    },
    "contracts/external/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin. It is fully forked from OpenZeppelin\n * `TransparentUpgradeableProxy`\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/vaultManager/VaultManagerERC721.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./VaultManagerStorage.sol\";\n\n/// @title VaultManagerERC721\n/// @author Angle Core Team\n/// @dev Base ERC721 Implementation of VaultManager\nabstract contract VaultManagerERC721 is IERC721MetadataUpgradeable, VaultManagerStorage {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// @inheritdoc IERC721MetadataUpgradeable\n    string public name;\n    /// @inheritdoc IERC721MetadataUpgradeable\n    string public symbol;\n\n    // ============================== Modifiers ====================================\n\n    /// @notice Checks if the person interacting with the vault with `vaultID` is approved\n    /// @param caller Address of the person seeking to interact with the vault\n    /// @param vaultID ID of the concerned vault\n    modifier onlyApprovedOrOwner(address caller, uint256 vaultID) {\n        if (!_isApprovedOrOwner(caller, vaultID)) revert NotApproved();\n        _;\n    }\n\n    // =============================== ERC721 Logic ================================\n\n    /// @notice Returns all the vaults owned or controlled (under the form of approval) by an address\n    /// @param spender Address for which vault ownerships should be checked\n    /// @return List of `vaultID` controlled by this address\n    /// @return Count of vaults owned by the address\n    /// @dev This function is never to be called on-chain since it iterates over all vaultIDs. It is here\n    /// to reduce dependency on an external graph to link an ID to its owner\n    function getControlledVaults(address spender) external view returns (uint256[] memory, uint256) {\n        uint256 arraySize = vaultIDCount;\n        uint256[] memory vaultsControlled = new uint256[](arraySize);\n        address owner;\n        uint256 count;\n        for (uint256 i = 1; i <= arraySize; i++) {\n            owner = _owners[i];\n            if (spender == owner || _getApproved(i) == spender || _operatorApprovals[owner][spender] == 1) {\n                vaultsControlled[count] = i;\n                count += 1;\n            }\n        }\n        return (vaultsControlled, count);\n    }\n\n    /// @notice Checks whether a given address is approved for a vault or owns this vault\n    /// @param spender Address for which vault ownership should be checked\n    /// @param vaultID ID of the vault to check\n    /// @return Whether the `spender` address owns or is approved for `vaultID`\n    function isApprovedOrOwner(address spender, uint256 vaultID) external view returns (bool) {\n        return _isApprovedOrOwner(spender, vaultID);\n    }\n\n    /// @inheritdoc IERC721MetadataUpgradeable\n    function tokenURI(uint256 vaultID) external view returns (string memory) {\n        if (!_exists(vaultID)) revert NonexistentVault();\n        // There is no vault with `vaultID` equal to 0, so the following variable is\n        // always greater than zero\n        uint256 temp = vaultID;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (vaultID != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(vaultID % 10)));\n            vaultID /= 10;\n        }\n        return bytes(_baseURI).length > 0 ? string(abi.encodePacked(_baseURI, string(buffer))) : \"\";\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function balanceOf(address owner) external view returns (uint256) {\n        if (owner == address(0)) revert ZeroAddress();\n        return _balances[owner];\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function ownerOf(uint256 vaultID) external view returns (address) {\n        return _ownerOf(vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function approve(address to, uint256 vaultID) external {\n        address owner = _ownerOf(vaultID);\n        if (to == owner) revert ApprovalToOwner();\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert NotApproved();\n\n        _approve(to, vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function getApproved(uint256 vaultID) external view returns (address) {\n        if (!_exists(vaultID)) revert NonexistentVault();\n        return _getApproved(vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator] == 1;\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function transferFrom(\n        address from,\n        address to,\n        uint256 vaultID\n    ) external onlyApprovedOrOwner(msg.sender, vaultID) {\n        _transfer(from, to, vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 vaultID\n    ) external {\n        safeTransferFrom(from, to, vaultID, \"\");\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 vaultID,\n        bytes memory _data\n    ) public onlyApprovedOrOwner(msg.sender, vaultID) {\n        _safeTransfer(from, to, vaultID, _data);\n    }\n\n    // =============================== ERC165 logic ================================\n\n    /// @inheritdoc IERC165Upgradeable\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IVaultManager).interfaceId ||\n            interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    // ============== Internal Functions for the ERC721 Logic ======================\n\n    /// @notice Internal version of the `ownerOf` function\n    function _ownerOf(uint256 vaultID) internal view returns (address owner) {\n        owner = _owners[vaultID];\n        if (owner == address(0)) revert NonexistentVault();\n    }\n\n    /// @notice Internal version of the `getApproved` function\n    function _getApproved(uint256 vaultID) internal view returns (address) {\n        return _vaultApprovals[vaultID];\n    }\n\n    /// @notice Internal version of the `safeTransferFrom` function (with the data parameter)\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 vaultID,\n        bytes memory _data\n    ) internal {\n        _transfer(from, to, vaultID);\n        if (!_checkOnERC721Received(from, to, vaultID, _data)) revert NonERC721Receiver();\n    }\n\n    /// @notice Checks whether a vault exists\n    /// @param vaultID ID of the vault to check\n    /// @return Whether `vaultID` has been created\n    function _exists(uint256 vaultID) internal view returns (bool) {\n        return _owners[vaultID] != address(0);\n    }\n\n    /// @notice Internal version of the `isApprovedOrOwner` function\n    function _isApprovedOrOwner(address spender, uint256 vaultID) internal view returns (bool) {\n        // The following checks if the vault exists\n        address owner = _ownerOf(vaultID);\n        return (spender == owner || _getApproved(vaultID) == spender || _operatorApprovals[owner][spender] == 1);\n    }\n\n    /// @notice Internal version of the `createVault` function\n    /// Mints `vaultID` and transfers it to `to`\n    /// @dev This method is equivalent to the `_safeMint` method used in OpenZeppelin ERC721 contract\n    /// @dev Emits a {Transfer} event\n    function _mint(address to) internal returns (uint256 vaultID) {\n        if (whitelistingActivated && (isWhitelisted[to] != 1 || isWhitelisted[msg.sender] != 1))\n            revert NotWhitelisted();\n        if (to == address(0)) revert ZeroAddress();\n        unchecked {\n            vaultIDCount += 1;\n            _balances[to] += 1;\n        }\n        vaultID = vaultIDCount;\n        _owners[vaultID] = to;\n        emit Transfer(address(0), to, vaultID);\n        if (!_checkOnERC721Received(address(0), to, vaultID, \"\")) revert NonERC721Receiver();\n    }\n\n    /// @notice Destroys `vaultID`\n    /// @dev `vaultID` must exist\n    /// @dev Emits a {Transfer} event\n    function _burn(uint256 vaultID) internal {\n        address owner = _ownerOf(vaultID);\n\n        // Clear approvals\n        _approve(address(0), vaultID);\n        // The following line cannot underflow as the owner's balance is necessarily\n        // greater than 1\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[vaultID];\n        delete vaultData[vaultID];\n\n        emit Transfer(owner, address(0), vaultID);\n    }\n\n    /// @notice Transfers `vaultID` from `from` to `to` as opposed to {transferFrom},\n    /// this imposes no restrictions on msg.sender\n    /// @dev `to` cannot be the zero address and `perpetualID` must be owned by `from`\n    /// @dev Emits a {Transfer} event\n    /// @dev A whitelist check is performed if necessary on the `to` address\n    function _transfer(\n        address from,\n        address to,\n        uint256 vaultID\n    ) internal {\n        if (_ownerOf(vaultID) != from) revert NotApproved();\n        if (to == address(0)) revert ZeroAddress();\n        if (whitelistingActivated && isWhitelisted[to] != 1) revert NotWhitelisted();\n        // Clear approvals from the previous owner\n        _approve(address(0), vaultID);\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[vaultID] = to;\n\n        emit Transfer(from, to, vaultID);\n    }\n\n    /// @notice Approves `to` to operate on `vaultID`\n    function _approve(address to, uint256 vaultID) internal {\n        _vaultApprovals[vaultID] = to;\n        emit Approval(_ownerOf(vaultID), to, vaultID);\n    }\n\n    /// @notice Internal version of the `setApprovalForAll` function\n    /// @dev It contains an `approver` field to be used in case someone signs a permit for a particular\n    /// address, and this signature is given to the contract by another address (like a router)\n    function _setApprovalForAll(\n        address approver,\n        address operator,\n        bool approved\n    ) internal {\n        if (operator == approver) revert ApprovalToCaller();\n        uint256 approval = approved ? 1 : 0;\n        _operatorApprovals[approver][operator] = approval;\n        emit ApprovalForAll(approver, operator, approved);\n    }\n\n    /// @notice Internal function to invoke {IERC721Receiver-onERC721Received} on a target address\n    /// The call is not executed if the target address is not a contract\n    /// @param from Address representing the previous owner of the given token ID\n    /// @param to Target address that will receive the tokens\n    /// @param vaultID ID of the token to be transferred\n    /// @param _data Bytes optional data to send along with the call\n    /// @return Bool whether the call correctly returned the expected value\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 vaultID,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(msg.sender, from, vaultID, _data) returns (\n                bytes4 retval\n            ) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert NonERC721Receiver();\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n}\n"
    },
    "contracts/vaultManager/VaultManagerPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./VaultManagerERC721.sol\";\nimport \"../interfaces/external/IERC1271.sol\";\n\n/// @title VaultManagerPermit\n/// @author Angle Core Team\n/// @dev Base Implementation of permit functions for the `VaultManager` contract\nabstract contract VaultManagerPermit is Initializable, VaultManagerERC721 {\n    using Address for address;\n\n    mapping(address => uint256) private _nonces;\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private _PERMIT_TYPEHASH;\n    /* solhint-enable var-name-mixedcase */\n\n    error ExpiredDeadline();\n    error InvalidSignature();\n\n    //solhint-disable-next-line\n    function __ERC721Permit_init(string memory _name) internal onlyInitializing {\n        _PERMIT_TYPEHASH = keccak256(\n            \"Permit(address owner,address spender,bool approved,uint256 nonce,uint256 deadline)\"\n        );\n        _HASHED_NAME = keccak256(bytes(_name));\n        _HASHED_VERSION = keccak256(bytes(\"1\"));\n    }\n\n    /// @notice Allows an address to give or revoke approval for all its vaults to another address\n    /// @param owner Address signing the permit and giving (or revoking) its approval for all the controlled vaults\n    /// @param spender Address to give approval to\n    /// @param approved Whether to give or revoke the approval\n    /// @param deadline Deadline parameter for the signature to be valid\n    /// @dev The `v`, `r`, and `s` parameters are used as signature data\n    function permit(\n        address owner,\n        address spender,\n        bool approved,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        if (block.timestamp > deadline) revert ExpiredDeadline();\n        // Additional signature checks performed in the `ECDSAUpgradeable.recover` function\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0 || (v != 27 && v != 28))\n            revert InvalidSignature();\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                _domainSeparatorV4(),\n                keccak256(\n                    abi.encode(\n                        _PERMIT_TYPEHASH,\n                        // 0x3f43a9c6bafb5c7aab4e0cfe239dc5d4c15caf0381c6104188191f78a6640bd8,\n                        owner,\n                        spender,\n                        approved,\n                        _useNonce(owner),\n                        deadline\n                    )\n                )\n            )\n        );\n        if (owner.isContract()) {\n            if (IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) != 0x1626ba7e)\n                revert InvalidSignature();\n        } else {\n            address signer = ecrecover(digest, v, r, s);\n            if (signer != owner || signer == address(0)) revert InvalidSignature();\n        }\n\n        _setApprovalForAll(owner, spender, approved);\n    }\n\n    /// @notice Returns the current nonce for an `owner` address\n    function nonces(address owner) public view returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /// @notice Returns the domain separator for the current chain.\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /// @notice Internal version of the `DOMAIN_SEPARATOR` function\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                    _HASHED_NAME,\n                    _HASHED_VERSION,\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /// @notice Consumes a nonce for an address: returns the current value and increments it\n    function _useNonce(address owner) internal returns (uint256 current) {\n        current = _nonces[owner];\n        _nonces[owner] = current + 1;\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/interfaces/external/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.12;\n\n/// @title Interface for verifying contract-based account signatures\n/// @notice Interface that verifies provided signature for the data\n/// @dev Interface defined by EIP-1271\ninterface IERC1271 {\n    /// @notice Returns whether the provided signature is valid for the provided data\n    /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\n    /// MUST allow external calls.\n    /// @param hash Hash of the data to be signed\n    /// @param signature Signature byte array associated with _data\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "contracts/mock/MockERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/external/IERC1271.sol\";\n\ncontract MockERC1271 is IERC1271 {\n    uint256 public mode = 0;\n\n    function setMode(uint256 _mode) public {\n        mode = _mode;\n    }\n\n    /// @notice Returns whether the provided signature is valid for the provided data\n    /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\n    /// MUST allow external calls.\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\n    function isValidSignature(bytes32, bytes memory) external view returns (bytes4 magicValue) {\n        if (mode == 1) magicValue = 0x1626ba7e;\n    }\n}\n"
    },
    "contracts/agToken/AgTokenSideChain.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./BaseAgTokenSideChain.sol\";\n\n/// @title AgTokenSideChain\n/// @author Angle Core Team\n/// @notice Implementation for Angle agTokens to be deployed on other chains than Ethereum mainnet without\n/// supporting bridging and swapping in and out\ncontract AgTokenSideChain is BaseAgTokenSideChain {\n    /// @notice Initializes the `AgTokenSideChain` contract by calling the child contract\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address _treasury\n    ) external {\n        _initialize(name_, symbol_, _treasury);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}