{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"IERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721Metadata.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/agToken/AgEUR.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/coreModule/IStableMaster.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\n/// @title AgEUR\n/// @author Angle Labs, Inc.\n/// @notice Base contract for agEUR, Angle's Euro stablecoin\n/// @dev This contract is an upgraded version of the agEUR contract that was first deployed on Ethereum mainnet\ncontract AgEUR is IAgToken, ERC20PermitUpgradeable {\n    // ================================= REFERENCES ================================\n\n    /// @notice Reference to the `StableMaster` contract associated to agEUR\n    address public stableMaster;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ============================== ADDED PARAMETERS =============================\n\n    /// @inheritdoc IAgToken\n    mapping(address => bool) public isMinter;\n    /// @notice Reference to the treasury contract which can grant minting rights\n    address public treasury;\n    /// @notice Boolean used to check whether the contract had been reinitialized after an upgrade\n    bool public treasuryInitialized;\n\n    // =================================== EVENTS ==================================\n\n    event TreasuryUpdated(address indexed _treasury);\n    event MinterToggled(address indexed minter);\n\n    // =================================== ERRORS ==================================\n\n    error BurnAmountExceedsAllowance();\n    error InvalidSender();\n    error InvalidTreasury();\n    error NotGovernor();\n    error NotMinter();\n    error NotTreasury();\n    error TreasuryAlreadyInitialized();\n\n    // ================================= MODIFIERS =================================\n\n    /// @notice Checks to see if it is the `Treasury` calling this contract\n    modifier onlyTreasury() {\n        if (msg.sender != treasury) revert NotTreasury();\n        _;\n    }\n\n    /// @notice Checks whether the sender has the minting right\n    modifier onlyMinter() {\n        if (!isMinter[msg.sender]) revert NotMinter();\n        _;\n    }\n\n    // ============================= EXTERNAL FUNCTION =============================\n\n    /// @notice Allows anyone to burn stablecoins\n    /// @param amount Amount of stablecoins to burn\n    /// @dev This function can typically be called if there is a settlement mechanism to burn stablecoins\n    function burnStablecoin(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    // ========================= MINTER ROLE ONLY FUNCTIONS ========================\n\n    /// @inheritdoc IAgToken\n    function burnSelf(uint256 amount, address burner) external onlyMinter {\n        _burn(burner, amount);\n    }\n\n    /// @inheritdoc IAgToken\n    function burnFrom(uint256 amount, address burner, address sender) external onlyMinter {\n        if (burner != sender) {\n            uint256 currentAllowance = allowance(burner, sender);\n            if (currentAllowance < amount) revert BurnAmountExceedsAllowance();\n            _approve(burner, sender, currentAllowance - amount);\n        }\n        _burn(burner, amount);\n    }\n\n    /// @inheritdoc IAgToken\n    function mint(address account, uint256 amount) external onlyMinter {\n        _mint(account, amount);\n    }\n\n    // ========================== TREASURY ONLY FUNCTIONS ==========================\n\n    /// @inheritdoc IAgToken\n    function addMinter(address minter) external onlyTreasury {\n        isMinter[minter] = true;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function removeMinter(address minter) external {\n        if (msg.sender != minter && msg.sender != address(treasury)) revert InvalidSender();\n        isMinter[minter] = false;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function setTreasury(address _treasury) external onlyTreasury {\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n}\n"
    },
    "contracts/agToken/AgToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/*\n                  *                                                                                \n                *****                                                                            \n                  *                                                                        \n                                   *            ///.                                  \n                                 *****        ////////                                      \n                                   *       /////////////                                         \n                                       //////////////////                                      \n                                  ///////////////////////                                   \n                               ////////////////////////////                                 \n                              /////////////////////////                                \n                            ,//////////////////////////////////////                           \n                          //////////////////////////////////////////                           \n                        ///////////////////////////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////.,//////////////////////////                     \n                       .//////////////////////..,./////////////////////                       \n                        ...////////////////.....,.////////////////                        \n                          ,.,//////////// ........,///////////                          \n                            .,.,//////      ,.......///////                            \n                               ,..//           ........./                               \n                                 ..,                .....,                                 \n                                    .                     ,.,                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                   \n                                                                            \n                                                                          \n                                                            \n*/\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\n/// @title AgToken\n/// @author Angle Labs, Inc.\n/// @notice Base contract for Angle agTokens on Ethereum and on other chains\n/// @dev By default, agTokens are ERC-20 tokens with 18 decimals\ncontract AgToken is IAgToken, ERC20PermitUpgradeable {\n    // =========================== PARAMETERS / VARIABLES ==========================\n\n    /// @inheritdoc IAgToken\n    mapping(address => bool) public isMinter;\n    /// @notice Reference to the treasury contract which can grant minting rights\n    address public treasury;\n\n    // =================================== EVENTS ==================================\n\n    event TreasuryUpdated(address indexed _treasury);\n    event MinterToggled(address indexed minter);\n\n    // =================================== ERRORS ==================================\n\n    error BurnAmountExceedsAllowance();\n    error InvalidSender();\n    error InvalidTreasury();\n    error NotMinter();\n    error NotTreasury();\n\n    // ================================ CONSTRUCTOR ================================\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @notice Initializes the `AgToken` contract\n    function initialize(string memory name_, string memory symbol_, address _treasury) external {\n        _initialize(name_, symbol_, _treasury);\n    }\n\n    /// @notice Initializes the contract\n    function _initialize(string memory name_, string memory symbol_, address _treasury) internal virtual initializer {\n        if (address(ITreasury(_treasury).stablecoin()) != address(this)) revert InvalidTreasury();\n        __ERC20Permit_init(name_);\n        __ERC20_init(name_, symbol_);\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // ================================= MODIFIERS =================================\n\n    /// @notice Checks to see if it is the `Treasury` calling this contract\n    modifier onlyTreasury() {\n        if (msg.sender != treasury) revert NotTreasury();\n        _;\n    }\n\n    /// @notice Checks whether the sender has the minting right\n    modifier onlyMinter() {\n        if (!isMinter[msg.sender]) revert NotMinter();\n        _;\n    }\n\n    // ============================= EXTERNAL FUNCTION =============================\n\n    /// @notice Allows anyone to burn stablecoins\n    /// @param amount Amount of stablecoins to burn\n    /// @dev This function can typically be called if there is a settlement mechanism to burn stablecoins\n    function burnStablecoin(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    // ========================= MINTER ROLE ONLY FUNCTIONS ========================\n\n    /// @inheritdoc IAgToken\n    function burnSelf(uint256 amount, address burner) external onlyMinter {\n        _burn(burner, amount);\n    }\n\n    /// @inheritdoc IAgToken\n    function burnFrom(uint256 amount, address burner, address sender) external onlyMinter {\n        if (burner != sender) {\n            uint256 currentAllowance = allowance(burner, sender);\n            if (currentAllowance < amount) revert BurnAmountExceedsAllowance();\n            _approve(burner, sender, currentAllowance - amount);\n        }\n        _burn(burner, amount);\n    }\n\n    /// @inheritdoc IAgToken\n    function mint(address account, uint256 amount) external onlyMinter {\n        _mint(account, amount);\n    }\n\n    // ========================== GOVERNANCE ONLY FUNCTIONS ==========================\n\n    /// @inheritdoc IAgToken\n    function addMinter(address minter) external onlyTreasury {\n        isMinter[minter] = true;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function removeMinter(address minter) external {\n        if (msg.sender != address(treasury) && msg.sender != minter) revert InvalidSender();\n        isMinter[minter] = false;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function setTreasury(address _treasury) external virtual onlyTreasury {\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n}\n"
    },
    "contracts/agToken/AgTokenSideChainMultiBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./AgToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title AgTokenSideChainMultiBridge\n/// @author Angle Labs, Inc.\n/// @notice Contract for Angle agTokens on other chains than Ethereum mainnet\n/// @dev This contract supports bridge tokens having a minting right on the stablecoin (also referred to as the canonical\n/// or the native token)\ncontract AgTokenSideChainMultiBridge is AgToken {\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for fee computation\n    uint256 public constant BASE_PARAMS = 1e9;\n\n    // =============================== BRIDGING DATA ===============================\n\n    /// @notice Struct with some data about a specific bridge token\n    struct BridgeDetails {\n        // Limit on the balance of bridge token held by the contract: it is designed\n        // to reduce the exposure of the system to hacks\n        uint256 limit;\n        // Limit on the hourly volume of token minted through this bridge\n        // Technically the limit over a rolling hour is hourlyLimit x2 as hourly limit\n        // is enforced only between x:00 and x+1:00\n        uint256 hourlyLimit;\n        // Fee taken for swapping in and out the token\n        uint64 fee;\n        // Whether the associated token is allowed or not\n        bool allowed;\n        // Whether swapping in and out from the associated token is paused or not\n        bool paused;\n    }\n\n    /// @notice Maps a bridge token to data\n    mapping(address => BridgeDetails) public bridges;\n    /// @notice List of all bridge tokens\n    address[] public bridgeTokensList;\n    /// @notice Maps a bridge token to the associated hourly volume\n    mapping(address => mapping(uint256 => uint256)) public usage;\n    /// @notice Maps an address to whether it is exempt of fees for when it comes to swapping in and out\n    mapping(address => uint256) public isFeeExempt;\n    /// @notice Limit to the amount of tokens that can be sent from that chain to another chain\n    uint256 public chainTotalHourlyLimit;\n    /// @notice Usage per hour on that chain. Maps an hourly timestamp to the total volume swapped out on the chain\n    mapping(uint256 => uint256) public chainTotalUsage;\n    \n    uint256[44] private __gapMultiBridge;\n\n    // =================================== EVENTS ==================================\n\n    event BridgeTokenAdded(address indexed bridgeToken, uint256 limit, uint256 hourlyLimit, uint64 fee, bool paused);\n    event BridgeTokenToggled(address indexed bridgeToken, bool toggleStatus);\n    event BridgeTokenRemoved(address indexed bridgeToken);\n    event BridgeTokenFeeUpdated(address indexed bridgeToken, uint64 fee);\n    event BridgeTokenLimitUpdated(address indexed bridgeToken, uint256 limit);\n    event BridgeTokenHourlyLimitUpdated(address indexed bridgeToken, uint256 hourlyLimit);\n    event HourlyLimitUpdated(uint256 hourlyLimit);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event FeeToggled(address indexed theAddress, uint256 toggleStatus);\n\n    // =================================== ERRORS ==================================\n\n    error AssetStillControlledInReserves();\n    error HourlyLimitExceeded();\n    error InvalidToken();\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error TooBigAmount();\n    error TooHighParameterValue();\n    error ZeroAddress();\n\n    // ================================= MODIFIERS =================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!ITreasury(treasury).isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!ITreasury(treasury).isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    // ===================== EXTERNAL PERMISSIONLESS FUNCTIONS =====================\n\n    /// @notice Returns the list of all supported bridge tokens\n    /// @dev Helpful for UIs\n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridgeTokensList;\n    }\n\n    /// @notice Returns the current volume for a bridge, for the current hour\n    /// @param bridgeToken Bridge used to mint\n    /// @dev Helpful for UIs\n    function currentUsage(address bridgeToken) external view returns (uint256) {\n        return usage[bridgeToken][block.timestamp / 3600];\n    }\n\n    /// @notice Returns the current total volume on the chain for the current hour\n    /// @dev Helpful for UIs\n    function currentTotalUsage() external view returns (uint256) {\n        return chainTotalUsage[block.timestamp / 3600];\n    }\n\n    /// @notice Mints the canonical token from a supported bridge token\n    /// @param bridgeToken Bridge token to use to mint\n    /// @param amount Amount of bridge tokens to send\n    /// @param to Address to which the stablecoin should be sent\n    /// @return Amount of the canonical stablecoin actually minted\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapIn(address bridgeToken, uint256 amount, address to) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n        uint256 balance = IERC20(bridgeToken).balanceOf(address(this));\n        if (balance + amount > bridgeDetails.limit) {\n            // In case someone maliciously sends tokens to this contract\n            // Or the limit changes\n            if (bridgeDetails.limit > balance) amount = bridgeDetails.limit - balance;\n            else {\n                amount = 0;\n            }\n        }\n\n        // Checking requirement on the hourly volume\n        uint256 hour = block.timestamp / 3600;\n        uint256 hourlyUsage = usage[bridgeToken][hour];\n        if (hourlyUsage + amount > bridgeDetails.hourlyLimit) {\n            // Edge case when the hourly limit changes\n            amount = bridgeDetails.hourlyLimit > hourlyUsage ? bridgeDetails.hourlyLimit - hourlyUsage : 0;\n        }\n        usage[bridgeToken][hour] = hourlyUsage + amount;\n\n        IERC20(bridgeToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 canonicalOut = amount;\n        // Computing fees\n        if (isFeeExempt[msg.sender] == 0) {\n            canonicalOut -= (canonicalOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        _mint(to, canonicalOut);\n        return canonicalOut;\n    }\n\n    /// @notice Burns the canonical token in exchange for a bridge token\n    /// @param bridgeToken Bridge token required\n    /// @param amount Amount of canonical tokens to burn\n    /// @param to Address to which the bridge token should be sent\n    /// @return Amount of bridge tokens actually sent back\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapOut(address bridgeToken, uint256 amount, address to) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n\n        uint256 hour = block.timestamp / 3600;\n        uint256 hourlyUsage = chainTotalUsage[hour] + amount;\n        // If the amount being swapped out exceeds the limit, we revert\n        // We don't want to change the amount being swapped out.\n        // The user can decide to send another tx with the correct amount to reach the limit\n        if (hourlyUsage > chainTotalHourlyLimit) revert HourlyLimitExceeded();\n        chainTotalUsage[hour] = hourlyUsage;\n\n        _burn(msg.sender, amount);\n        uint256 bridgeOut = amount;\n        if (isFeeExempt[msg.sender] == 0) {\n            bridgeOut -= (bridgeOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        IERC20(bridgeToken).safeTransfer(to, bridgeOut);\n        return bridgeOut;\n    }\n\n    // ============================ GOVERNANCE FUNCTIONS ===========================\n\n    /// @notice Adds support for a bridge token\n    /// @param bridgeToken Bridge token to add: it should be a version of the stablecoin from another bridge\n    /// @param limit Limit on the balance of bridge token this contract could hold\n    /// @param hourlyLimit Limit on the hourly volume for this bridge\n    /// @param paused Whether swapping for this token should be paused or not\n    /// @param fee Fee taken upon swapping for or against this token\n    function addBridgeToken(\n        address bridgeToken,\n        uint256 limit,\n        uint256 hourlyLimit,\n        uint64 fee,\n        bool paused\n    ) external onlyGovernor {\n        if (bridges[bridgeToken].allowed || bridgeToken == address(0)) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        BridgeDetails memory _bridge;\n        _bridge.limit = limit;\n        _bridge.hourlyLimit = hourlyLimit;\n        _bridge.paused = paused;\n        _bridge.fee = fee;\n        _bridge.allowed = true;\n        bridges[bridgeToken] = _bridge;\n        bridgeTokensList.push(bridgeToken);\n        emit BridgeTokenAdded(bridgeToken, limit, hourlyLimit, fee, paused);\n    }\n\n    /// @notice Removes support for a token\n    /// @param bridgeToken Address of the bridge token to remove support for\n    function removeBridgeToken(address bridgeToken) external onlyGovernor {\n        if (IERC20(bridgeToken).balanceOf(address(this)) != 0) revert AssetStillControlledInReserves();\n        delete bridges[bridgeToken];\n        // Deletion from `bridgeTokensList` loop\n        uint256 bridgeTokensListLength = bridgeTokensList.length;\n        for (uint256 i; i < bridgeTokensListLength - 1; ++i) {\n            if (bridgeTokensList[i] == bridgeToken) {\n                // Replace the `bridgeToken` to remove with the last of the list\n                bridgeTokensList[i] = bridgeTokensList[bridgeTokensListLength - 1];\n                break;\n            }\n        }\n        // Remove last element in array\n        bridgeTokensList.pop();\n        emit BridgeTokenRemoved(bridgeToken);\n    }\n\n    /// @notice Recovers any ERC20 token\n    /// @dev Can be used to withdraw bridge tokens for them to be de-bridged on mainnet\n    function recoverERC20(address tokenAddress, address to, uint256 amountToRecover) external onlyGovernor {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Updates the `limit` amount for `bridgeToken`\n    function setLimit(address bridgeToken, uint256 limit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].limit = limit;\n        emit BridgeTokenLimitUpdated(bridgeToken, limit);\n    }\n\n    /// @notice Updates the `hourlyLimit` amount for `bridgeToken`\n    function setHourlyLimit(address bridgeToken, uint256 hourlyLimit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].hourlyLimit = hourlyLimit;\n        emit BridgeTokenHourlyLimitUpdated(bridgeToken, hourlyLimit);\n    }\n\n    /// @notice Updates the `chainTotalHourlyLimit` amount\n    function setChainTotalHourlyLimit(uint256 hourlyLimit) external onlyGovernorOrGuardian {\n        chainTotalHourlyLimit = hourlyLimit;\n        emit HourlyLimitUpdated(hourlyLimit);\n    }\n\n    /// @notice Updates the `fee` value for `bridgeToken`\n    function setSwapFee(address bridgeToken, uint64 fee) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        bridges[bridgeToken].fee = fee;\n        emit BridgeTokenFeeUpdated(bridgeToken, fee);\n    }\n\n    /// @notice Pauses or unpauses swapping in and out for a token\n    function toggleBridge(address bridgeToken) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bool pausedStatus = bridges[bridgeToken].paused;\n        bridges[bridgeToken].paused = !pausedStatus;\n        emit BridgeTokenToggled(bridgeToken, !pausedStatus);\n    }\n\n    /// @notice Toggles fees for the address `theAddress`\n    function toggleFeesForAddress(address theAddress) external onlyGovernorOrGuardian {\n        uint256 feeExemptStatus = 1 - isFeeExempt[theAddress];\n        isFeeExempt[theAddress] = feeExemptStatus;\n        emit FeeToggled(theAddress, feeExemptStatus);\n    }\n}\n"
    },
    "contracts/agToken/layerZero/LayerZeroBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"./utils/OFTCore.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\n/// @title LayerZeroBridge\n/// @author Angle Labs, Inc., forked from https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/token/oft/OFT.sol\n/// @notice Contract to be deployed on Ethereum for bridging an AgToken using a bridge intermediate token and LayerZero\ncontract LayerZeroBridge is OFTCore, PausableUpgradeable {\n    /// @notice Name of the contract for indexing purposes\n    string public name;\n\n    /// @notice Address of the bridgeable token\n    /// @dev Immutable\n    IERC20 public canonicalToken;\n\n    /// @notice Maps an address to the amount of token bridged but not received\n    mapping(address => uint256) public balanceOf;\n\n    // ================================ CONSTRUCTOR ================================\n    /// @notice Initializes the contract\n    /// @param _name Name of the token corresponding to this contract\n    /// @param _lzEndpoint Layer zero endpoint to pass messages\n    /// @param _treasury Address of the treasury contract used for access control\n    function initialize(string memory _name, address _lzEndpoint, address _treasury) external initializer {\n        __LzAppUpgradeable_init(_lzEndpoint, _treasury);\n        name = _name;\n        canonicalToken = IERC20(address(ITreasury(_treasury).stablecoin()));\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ===================== EXTERNAL PERMISSIONLESS FUNCTIONS =====================\n\n    /// @inheritdoc OFTCore\n    function sendWithPermit(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable override {\n        IERC20Permit(address(canonicalToken)).permit(msg.sender, address(this), _amount, deadline, v, r, s);\n        send(_dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    /// @inheritdoc OFTCore\n    function withdraw(uint256 amount, address recipient) external override returns (uint256) {\n        return _withdraw(amount, msg.sender, recipient);\n    }\n\n    /// @notice Withdraws amount of `token` from the contract and sends it to the recipient\n    /// @param amount Amount to withdraw\n    /// @param recipient Address to withdraw for\n    /// @return The amount of canonical token sent\n    function withdrawFor(uint256 amount, address recipient) external returns (uint256) {\n        return _withdraw(amount, recipient, recipient);\n    }\n\n    // ============================= INTERNAL FUNCTIONS ============================\n\n    /// @notice Withdraws `amount` from the balance of the `from` address and sends these tokens to the `to` address\n    /// @dev It's important to make sure that `from` is either the `msg.sender` or that `from` and `to` are the same\n    /// addresses\n    function _withdraw(uint256 amount, address from, address to) internal whenNotPaused returns (uint256) {\n        balanceOf[from] -= amount; // Will overflow if the amount is too big\n        canonicalToken.transfer(to, amount);\n        return amount;\n    }\n\n    /// @inheritdoc OFTCore\n    function _debitFrom(uint16, bytes memory, uint256 _amount) internal override whenNotPaused returns (uint256) {\n        // No need to use safeTransferFrom as we know this implementation reverts on failure\n        canonicalToken.transferFrom(msg.sender, address(this), _amount);\n        return _amount;\n    }\n\n    /// @inheritdoc OFTCore\n    function _debitCreditFrom(uint16, bytes memory, uint256 _amount) internal override whenNotPaused returns (uint256) {\n        balanceOf[msg.sender] -= _amount;\n        return _amount;\n    }\n\n    /// @inheritdoc OFTCore\n    function _creditTo(uint16, address _toAddress, uint256 _amount) internal override whenNotPaused returns (uint256) {\n        // Should never revert as all the LayerZero bridge tokens come from\n        // this contract\n        uint256 balance = canonicalToken.balanceOf(address(this));\n        if (balance < _amount) {\n            balanceOf[_toAddress] = _amount - balance;\n            if (balance != 0) canonicalToken.transfer(_toAddress, balance);\n        } else {\n            canonicalToken.transfer(_toAddress, _amount);\n        }\n        return _amount;\n    }\n\n    // =============================== VIEW FUNCTIONS ==============================\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // ============================ GOVERNANCE FUNCTIONS ===========================\n\n    /// @notice Pauses bridging through the contract\n    /// @param pause Future pause status\n    function pauseSendTokens(bool pause) external onlyGovernorOrGuardian {\n        pause ? _pause() : _unpause();\n    }\n\n    /// @notice Decreases the balance of an address\n    /// @param amount Amount to withdraw from balance\n    /// @param recipient Address to withdraw from\n    function sweep(uint256 amount, address recipient) external onlyGovernorOrGuardian {\n        balanceOf[recipient] -= amount; // Will overflow if the amount is too big\n    }\n\n    uint256[47] private __gap;\n}\n"
    },
    "contracts/agToken/layerZero/LayerZeroBridgeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"./utils/OFTCore.sol\";\nimport \"../../interfaces/IAgTokenSideChainMultiBridge.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title LayerZeroBridgeToken\n/// @author Angle Labs, Inc., forked from https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/token/oft/OFT.sol\n/// @notice Contract to be deployed on a L2/sidechain for bridging an AgToken using a bridge intermediate token and LayerZero\ncontract LayerZeroBridgeToken is OFTCore, ERC20Upgradeable, PausableUpgradeable {\n    /// @notice Address of the bridgeable token\n    /// @dev Immutable\n    IAgTokenSideChainMultiBridge public canonicalToken;\n\n    // =================================== ERROR ===================================\n\n    error InvalidAllowance();\n\n    // ================================ CONSTRUCTOR ================================\n\n    /// @notice Initializes the contract\n    /// @param _name Name of the token corresponding to this contract\n    /// @param _symbol Symbol of the token corresponding to this contract\n    /// @param _lzEndpoint Layer zero endpoint to pass messages\n    /// @param _treasury Address of the treasury contract used for access control\n    /// @param initialSupply Initial supply to mint to the canonical token address\n    /// @dev The initial supply corresponds to the initial amount that could be bridged using this OFT\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _lzEndpoint,\n        address _treasury,\n        uint256 initialSupply\n    ) external initializer {\n        __ERC20_init_unchained(_name, _symbol);\n        __LzAppUpgradeable_init(_lzEndpoint, _treasury);\n\n        canonicalToken = IAgTokenSideChainMultiBridge(address(ITreasury(_treasury).stablecoin()));\n        _approve(address(this), address(canonicalToken), type(uint256).max);\n        _mint(address(canonicalToken), initialSupply);\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ===================== EXTERNAL PERMISSIONLESS FUNCTIONS =====================\n\n    /// @inheritdoc OFTCore\n    function sendWithPermit(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable override {\n        canonicalToken.permit(msg.sender, address(this), _amount, deadline, v, r, s);\n        send(_dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    /// @inheritdoc OFTCore\n    function withdraw(uint256 amount, address recipient) external override returns (uint256 amountMinted) {\n        // Does not check allowances as transfers from `msg.sender`\n        _transfer(msg.sender, address(this), amount);\n        amountMinted = canonicalToken.swapIn(address(this), amount, recipient);\n        uint256 leftover = balanceOf(address(this));\n        if (leftover != 0) {\n            _transfer(address(this), msg.sender, leftover);\n        }\n    }\n\n    // ============================= INTERNAL FUNCTIONS ============================\n\n    /// @inheritdoc OFTCore\n    function _debitFrom(\n        uint16,\n        bytes memory,\n        uint256 _amount\n    ) internal override whenNotPaused returns (uint256 amountSwapped) {\n        // No need to use safeTransferFrom as we know this implementation reverts on failure\n        canonicalToken.transferFrom(msg.sender, address(this), _amount);\n\n        // Swap canonical for this bridge token. There may be some fees\n        amountSwapped = canonicalToken.swapOut(address(this), _amount, address(this));\n        _burn(address(this), amountSwapped);\n    }\n\n    /// @inheritdoc OFTCore\n    function _debitCreditFrom(uint16, bytes memory, uint256 _amount) internal override whenNotPaused returns (uint256) {\n        _burn(msg.sender, _amount);\n        return _amount;\n    }\n\n    /// @inheritdoc OFTCore\n    function _creditTo(\n        uint16,\n        address _toAddress,\n        uint256 _amount\n    ) internal override whenNotPaused returns (uint256 amountMinted) {\n        _mint(address(this), _amount);\n        amountMinted = canonicalToken.swapIn(address(this), _amount, _toAddress);\n        uint256 leftover = balanceOf(address(this));\n        if (leftover != 0) {\n            _transfer(address(this), _toAddress, leftover);\n        }\n    }\n\n    // =============================== VIEW FUNCTIONS ==============================\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IOFT).interfaceId ||\n            interfaceId == type(IERC20).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    // ============================ GOVERNANCE FUNCTIONS ===========================\n\n    /// @notice Mints the intermediate contract to the `canonicalToken`\n    /// @dev Used to increase the bridging capacity\n    function mint(uint256 amount) external onlyGovernorOrGuardian {\n        _mint(address(canonicalToken), amount);\n    }\n\n    /// @notice Burns the intermediate contract from the `canonicalToken`\n    /// @dev Used to decrease the bridging capacity\n    function burn(uint256 amount) external onlyGovernorOrGuardian {\n        _burn(address(canonicalToken), amount);\n    }\n\n    /// @notice Increases allowance of the `canonicalToken`\n    function setupAllowance() public onlyGovernorOrGuardian {\n        _approve(address(this), address(canonicalToken), type(uint256).max);\n    }\n\n    /// @notice Pauses bridging through the contract\n    /// @param pause Future pause status\n    function pauseSendTokens(bool pause) external onlyGovernorOrGuardian {\n        pause ? _pause() : _unpause();\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/agToken/layerZero/utils/IOFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface of the IOFT core standard\n * @dev Forked from https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/token/oft/IOFTCore.sol\n */\ninterface IOFTCore is IERC165 {\n    /// @notice Estimates send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n    /// @param _dstChainId L0 defined chain id to send tokens too\n    /// @param _toAddress dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n    /// @param _amount amount of the tokens to transfer\n    /// @param _useZro indicates to use zro to pay L0 fees\n    /// @param _adapterParams flexible bytes array to indicate messaging adapter services in L0\n    function estimateSendFee(\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint256 _amount,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\n\n    /// @notice Sends `_amount` amount of token to (`_dstChainId`, `_toAddress`)\n    /// @param _dstChainId the destination chain identifier\n    /// @param _toAddress can be any size depending on the `dstChainId`.\n    /// @param _amount the quantity of tokens in wei\n    /// @param _refundAddress the address LayerZero refunds if too much message fee is sent\n    /// @param _zroPaymentAddress set to address(0x0) if not paying in ZRO (LayerZero Token)\n    /// @param _adapterParams is a flexible bytes array to indicate messaging adapter services\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    /// @notice Sends `_amount` amount of credit to (`_dstChainId`, `_toAddress`)\n    /// @param _dstChainId the destination chain identifier\n    /// @param _toAddress can be any size depending on the `dstChainId`.\n    /// @param _amount the quantity of credit to send in wei\n    /// @param _refundAddress the address LayerZero refunds if too much message fee is sent\n    /// @param _zroPaymentAddress set to address(0x0) if not paying in ZRO (LayerZero Token)\n    /// @param _adapterParams is a flexible bytes array to indicate messaging adapter services\n    function sendCredit(\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    /// @notice Sends `_amount` amount of token to (`_dstChainId`, `_toAddress`)\n    /// @param _dstChainId The destination chain identifier\n    /// @param _toAddress Can be any size depending on the `dstChainId`.\n    /// @param _amount Quantity of tokens in wei\n    /// @param _refundAddress Address LayerZero refunds if too much message fee is sent\n    /// @param _zroPaymentAddress Set to address(0x0) if not paying in ZRO (LayerZero Token)\n    /// @param _adapterParams Flexible bytes array to indicate messaging adapter services\n    /// @param deadline Deadline parameter for the signature to be valid\n    /// @dev The `v`, `r`, and `s` parameters are used as signature data\n    function sendWithPermit(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Withdraws amount of canonical token from the `msg.sender` balance and sends it to the recipient\n    /// @param amount Amount to withdraw\n    /// @param recipient Address to send the canonical token to\n    /// @return The amount of canonical token sent\n    function withdraw(uint256 amount, address recipient) external returns (uint256);\n\n    /// @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n    /// `_nonce` is the outbound nonce\n    event SendToChain(\n        address indexed _sender,\n        uint16 indexed _dstChainId,\n        bytes indexed _toAddress,\n        uint256 _amount,\n        uint64 _nonce\n    );\n\n    /// @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\n    /// `_nonce` is the inbound nonce.\n    event ReceiveFromChain(\n        uint16 indexed _srcChainId,\n        bytes indexed _srcAddress,\n        address indexed _toAddress,\n        uint256 _amount,\n        uint64 _nonce\n    );\n}\n\n/// @dev Interface of the OFT standard\ninterface IOFT is IOFTCore, IERC20 {\n\n}\n"
    },
    "contracts/agToken/layerZero/utils/NonblockingLzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../interfaces/external/layerZero/ILayerZeroReceiver.sol\";\nimport \"../../../interfaces/external/layerZero/ILayerZeroUserApplicationConfig.sol\";\nimport \"../../../interfaces/external/layerZero/ILayerZeroEndpoint.sol\";\nimport \"../../../interfaces/ITreasury.sol\";\n\n/// @title NonblockingLzApp\n/// @author Angle Labs, Inc., forked from https://github.com/LayerZero-Labs/solidity-examples/\n/// @notice Base contract for bridging using LayerZero\nabstract contract NonblockingLzApp is Initializable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    /// @notice Layer Zero endpoint\n    ILayerZeroEndpoint public lzEndpoint;\n\n    /// @notice Maps chainIds to failed messages to retry them\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    /// @notice Maps chainIds to their OFT address\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n\n    /// @notice Reference to the treasury contract to fetch access control\n    address public treasury;\n\n    /// @notice Maps pairs of (`to` chain, `packetType`) to the minimum amount of gas needed on the destination chain\n    mapping(uint16 => mapping(uint16 => uint256)) public minDstGasLookup;\n\n    /// @notice For future LayerZero compatibility\n    address public precrime;\n\n    // ================================== Events ===================================\n\n    event SetTrustedRemote(uint16 _srcChainId, bytes _srcAddress);\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload);\n\n    // =============================== Errors ================================\n\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error InsufficientGas();\n    error InvalidEndpoint();\n    error InvalidSource();\n    error InvalidCaller();\n    error InvalidParams();\n    error InvalidPayload();\n    error ZeroAddress();\n\n    // ============================= Constructor ===================================\n\n    //solhint-disable-next-line\n    function __LzAppUpgradeable_init(address _endpoint, address _treasury) internal {\n        if (_endpoint == address(0) || _treasury == address(0)) revert ZeroAddress();\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        treasury = _treasury;\n    }\n\n    // =============================== Modifiers ===================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!ITreasury(treasury).isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    // ==================== External Permissionless Functions ======================\n\n    /// @notice Receives a message from the LZ endpoint and process it\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        if (msg.sender != address(lzEndpoint)) revert InvalidEndpoint();\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        if (_srcAddress.length != trustedRemote.length || keccak256(_srcAddress) != keccak256(trustedRemote))\n            revert InvalidSource();\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    /// @notice Retries a message that previously failed and was stored\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    function retryMessage(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        if (payloadHash == bytes32(0) || keccak256(_payload) != payloadHash) revert InvalidPayload();\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // ============================= Internal Functions ===================================\n\n    /// @notice Handles message receptions in a non blocking way\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    /// @dev public for the needs of try / catch but effectively internal\n    function nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public virtual {\n        // only internal transaction\n        if (msg.sender != address(this)) revert InvalidCaller();\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    /// @notice Handles message receptions in a non blocking way\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual;\n\n    /// @notice Handles message receptions in a blocking way\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    function _blockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal {\n        // try-catch all errors/exceptions\n        try this.nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload) {\n            // do nothing\n        } catch {\n            // error / exception\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload);\n        }\n    }\n\n    /// @notice Sends a message to the LZ endpoint and process it\n    /// @param _dstChainId L0 defined chain id to send tokens too\n    /// @param _payload Data: recipient address and amount\n    /// @param _refundAddress Address LayerZero refunds if too much message fee is sent\n    /// @param _zroPaymentAddress Set to address(0x0) if not paying in ZRO (LayerZero Token)\n    /// @param _adapterParams Flexible bytes array to indicate messaging adapter services in L0\n    function _lzSend(\n        uint16 _dstChainId,\n        bytes memory _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        if (trustedRemote.length == 0) revert InvalidSource();\n        //solhint-disable-next-line\n        lzEndpoint.send{ value: msg.value }(\n            _dstChainId,\n            trustedRemote,\n            _payload,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    /// @notice Checks the gas limit of a given transaction\n    function _checkGasLimit(\n        uint16 _dstChainId,\n        uint16 _type,\n        bytes memory _adapterParams,\n        uint256 _extraGas\n    ) internal view virtual {\n        uint256 minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        if (minGasLimit == 0 || minGasLimit > _getGasLimit(_adapterParams)) revert InsufficientGas();\n    }\n\n    /// @notice Gets the gas limit from the `_adapterParams` parameter\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint256 gasLimit) {\n        if (_adapterParams.length < 34) revert InvalidParams();\n        // solhint-disable-next-line\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    // ======================= Governance Functions ================================\n\n    /// @notice Sets the corresponding address on an other chain.\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Address on the source chain\n    /// @dev Used for both receiving and sending message\n    /// @dev There can only be one trusted source per chain\n    /// @dev Allows owner to set it multiple times.\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external onlyGovernorOrGuardian {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    /// @notice Fetches the default LZ config\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address,\n        uint256 _configType\n    ) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    /// @notice Overrides the default LZ config\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint256 _configType,\n        bytes calldata _config\n    ) external override onlyGovernorOrGuardian {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    /// @notice Overrides the default LZ config\n    function setSendVersion(uint16 _version) external override onlyGovernorOrGuardian {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    /// @notice Overrides the default LZ config\n    function setReceiveVersion(uint16 _version) external override onlyGovernorOrGuardian {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    /// @notice Unpauses the receive functionalities\n    function forceResumeReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress\n    ) external override onlyGovernorOrGuardian {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    /// @notice Sets the minimum gas parameter for a packet type on a given chain\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint256 _minGas) external onlyGovernorOrGuardian {\n        if (_minGas == 0) revert InvalidParams();\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n    }\n\n    /// @notice Sets the precrime variable\n    function setPrecrime(address _precrime) external onlyGovernorOrGuardian {\n        precrime = _precrime;\n    }\n\n    // ======================= View Functions ================================\n\n    /// @notice Checks if the `_srcAddress` corresponds to the trusted source\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/agToken/layerZero/utils/OFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"./NonblockingLzApp.sol\";\nimport \"./IOFTCore.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\n/// @title OFTCore\n/// @author Forked from https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/token/oft/OFTCore.sol\n/// but with slight modifications from the Angle Labs, Inc. which added return values to the `_creditTo` and `_debitFrom` functions\n/// @notice Base contract for bridging using LayerZero\nabstract contract OFTCore is NonblockingLzApp, ERC165Upgradeable, IOFTCore {\n    /// @notice Amount of additional gas specified\n    uint256 public constant EXTRA_GAS = 200000;\n    /// @notice Packet type for token transfer\n    uint16 public constant PT_SEND = 0;\n\n    /// @notice Whether to use custom parameters in transactions\n    uint8 public useCustomAdapterParams;\n\n    // ==================== External Permissionless Functions ======================\n\n    /// @inheritdoc IOFTCore\n    function sendWithPermit(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable virtual;\n\n    /// @inheritdoc IOFTCore\n    function send(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) public payable virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, EXTRA_GAS);\n        _amount = _debitFrom(_dstChainId, _toAddress, _amount);\n\n        bytes memory payload = abi.encode(_toAddress, _amount);\n        _lzSend(_dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n\n        uint64 nonce = lzEndpoint.getOutboundNonce(_dstChainId, address(this));\n        emit SendToChain(msg.sender, _dstChainId, _toAddress, _amount, nonce);\n    }\n\n    /// @inheritdoc IOFTCore\n    function sendCredit(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) public payable virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, EXTRA_GAS);\n        _amount = _debitCreditFrom(_dstChainId, _toAddress, _amount);\n\n        _send(_dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    /// @inheritdoc IOFTCore\n    function withdraw(uint256 amount, address recipient) external virtual returns (uint256);\n\n    /// @notice Sets whether custom adapter parameters can be used or not\n    function setUseCustomAdapterParams(uint8 _useCustomAdapterParams) public virtual onlyGovernorOrGuardian {\n        useCustomAdapterParams = _useCustomAdapterParams;\n    }\n\n    // =========================== Internal Functions ==============================\n\n    /// @notice Internal function to send `_amount` amount of token to (`_dstChainId`, `_toAddress`)\n    /// @param _dstChainId the destination chain identifier\n    /// @param _toAddress can be any size depending on the `dstChainId`.\n    /// @param _amount the quantity of tokens in wei\n    /// @param _refundAddress the address LayerZero refunds if too much message fee is sent\n    /// @param _zroPaymentAddress set to address(0x0) if not paying in ZRO (LayerZero Token)\n    /// @param _adapterParams is a flexible bytes array to indicate messaging adapter services\n    /// @dev Accounting and checks should be performed beforehand\n    function _send(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) internal {\n        bytes memory payload = abi.encode(_toAddress, _amount);\n        _lzSend(_dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n\n        uint64 nonce = lzEndpoint.getOutboundNonce(_dstChainId, address(this));\n        emit SendToChain(msg.sender, _dstChainId, _toAddress, _amount, nonce);\n    }\n\n    /// @inheritdoc NonblockingLzApp\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        // decode and load the toAddress\n        (bytes memory toAddressBytes, uint256 amount) = abi.decode(_payload, (bytes, uint256));\n        address toAddress;\n        //solhint-disable-next-line\n        assembly {\n            toAddress := mload(add(toAddressBytes, 20))\n        }\n        amount = _creditTo(_srcChainId, toAddress, amount);\n\n        emit ReceiveFromChain(_srcChainId, _srcAddress, toAddress, amount, _nonce);\n    }\n\n    /// @notice Checks the adapter parameters given during the smart contract call\n    function _checkAdapterParams(\n        uint16 _dstChainId,\n        uint16 _pkType,\n        bytes memory _adapterParams,\n        uint256 _extraGas\n    ) internal virtual {\n        if (useCustomAdapterParams > 0) _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        else if (_adapterParams.length != 0) revert InvalidParams();\n    }\n\n    /// @notice Makes accountability when bridging from this contract using canonical token\n    /// @param _dstChainId ChainId of the destination chain - LayerZero standard\n    /// @param _toAddress Recipient on the destination chain\n    /// @param _amount Amount to bridge\n    function _debitFrom(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount\n    ) internal virtual returns (uint256);\n\n    /// @notice Makes accountability when bridging from this contract's credit\n    /// @param _dstChainId ChainId of the destination chain - LayerZero standard\n    /// @param _toAddress Recipient on the destination chain\n    /// @param _amount Amount to bridge\n    function _debitCreditFrom(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount\n    ) internal virtual returns (uint256);\n\n    /// @notice Makes accountability when bridging to this contract\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _toAddress Recipient on this chain\n    /// @param _amount Amount to bridge\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint256 _amount) internal virtual returns (uint256);\n\n    // ========================== View Functions ===================================\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IOFTCore\n    function estimateSendFee(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        bool _useZro,\n        bytes memory _adapterParams\n    ) public view virtual override returns (uint256 nativeFee, uint256 zroFee) {\n        // mock the payload for send()\n        bytes memory payload = abi.encode(_toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/agToken/nameable/AgEURNameable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../AgEUR.sol\";\n\n/// @title AgEURNameable\n/// @author Angle Labs, Inc.\ncontract AgEURNameable is AgEUR {\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!ITreasury(treasury).isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    string internal __name;\n\n    string internal __symbol;\n\n    uint256[48] private __gapNameable;\n\n    /// @inheritdoc ERC20Upgradeable\n    function name() public view override returns (string memory) {\n        return __name;\n    }\n\n    /// @inheritdoc ERC20Upgradeable\n    function symbol() public view override returns (string memory) {\n        return __symbol;\n    }\n\n    /// @notice Updates the name and symbol of the token\n    function setNameAndSymbol(string memory newName, string memory newSymbol) external onlyGovernor {\n        __name = newName;\n        __symbol = newSymbol;\n    }\n}\n"
    },
    "contracts/agToken/nameable/AgTokenNameable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../AgToken.sol\";\n\n/// @title AgTokenNameable\n/// @author Angle Labs, Inc.\ncontract AgTokenNameable is AgToken {\n    error NotGovernor();\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!ITreasury(treasury).isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n    string internal __name;\n\n    string internal __symbol;\n\n    uint256[48] private __gapNameable;\n\n    /// @inheritdoc ERC20Upgradeable\n    function name() public view override returns (string memory) {\n        return __name;\n    }\n\n    /// @inheritdoc ERC20Upgradeable\n    function symbol() public view override returns (string memory) {\n        return __symbol;\n    }\n\n    /// @notice Updates the name and symbol of the token\n    function setNameAndSymbol(string memory newName, string memory newSymbol) external onlyGovernor {\n        __name = newName;\n        __symbol = newSymbol;\n    }\n}\n"
    },
    "contracts/agToken/nameable/AgTokenSideChainMultiBridgeNameable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../AgTokenSideChainMultiBridge.sol\";\n\n/// @title AgTokenSideChainMultiBridgeNameable\n/// @author Angle Labs, Inc.\ncontract AgTokenSideChainMultiBridgeNameable is AgTokenSideChainMultiBridge {\n    string internal __name;\n\n    string internal __symbol;\n\n    uint256[48] private __gapNameable;\n\n    /// @inheritdoc ERC20Upgradeable\n    function name() public view override returns (string memory) {\n        return __name;\n    }\n\n    /// @inheritdoc ERC20Upgradeable\n    function symbol() public view override returns (string memory) {\n        return __symbol;\n    }\n\n    /// @notice Updates the name and symbol of the token\n    function setNameAndSymbol(string memory newName, string memory newSymbol) external onlyGovernor {\n        __name = newName;\n        __symbol = newSymbol;\n    }\n}\n"
    },
    "contracts/agToken/nameable/TokenPolygonUpgradeableNameable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../polygon/TokenPolygonUpgradeable.sol\";\n\n/// @title TokenPolygonUpgradeableNameable\n/// @author Angle Labs, Inc.\ncontract TokenPolygonUpgradeableNameable is TokenPolygonUpgradeable {\n    string internal __name;\n\n    string internal __symbol;\n\n    uint256[48] private __gapNameable;\n\n    /// @inheritdoc ERC20UpgradeableCustom\n    function name() public view override returns (string memory) {\n        return __name;\n    }\n\n    /// @inheritdoc ERC20UpgradeableCustom\n    function symbol() public view override returns (string memory) {\n        return __symbol;\n    }\n\n    /// @notice Updates the name and symbol of the token\n    function setNameAndSymbol(string memory newName, string memory newSymbol) external onlyGovernor {\n        __name = newName;\n        __symbol = newSymbol;\n    }\n}\n"
    },
    "contracts/agToken/polygon/TokenPolygonUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport \"./utils/ERC20UpgradeableCustom.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IAgToken.sol\";\nimport \"../../interfaces/ITreasury.sol\";\n\ninterface IChildToken {\n    function deposit(address user, bytes calldata depositData) external;\n\n    function withdraw(uint256 amount) external;\n}\n\ncontract TokenPolygonUpgradeable is\n    Initializable,\n    ERC20UpgradeableCustom,\n    AccessControlUpgradeable,\n    EIP712Upgradeable,\n    IChildToken\n{\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    /// @dev Emitted when the child chain manager changes\n    event ChildChainManagerAdded(address newAddress);\n    event ChildChainManagerRevoked(address oldAddress);\n\n    constructor() initializer {}\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address childChainManager,\n        address guardian\n    ) public initializer {\n        __ERC20_init(_name, _symbol);\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, guardian);\n        _setupRole(DEPOSITOR_ROLE, childChainManager);\n        __EIP712_init(_name, \"1\");\n    }\n\n    /**\n     * @notice Called when the bridge has tokens to mint\n     * @param user Address to mint the token to\n     * @param depositData Encoded amount to mint\n     */\n    function deposit(address user, bytes calldata depositData) external override {\n        require(hasRole(DEPOSITOR_ROLE, msg.sender));\n        uint256 amount = abi.decode(depositData, (uint256));\n        _mint(user, amount);\n    }\n\n    /**\n     * @notice Called when user wants to withdraw tokens back to root chain\n     * @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\n     * @param amount Amount of tokens to withdraw\n     */\n    function withdraw(uint256 amount) external override {\n        _burn(_msgSender(), amount);\n    }\n\n    // =============================================================================\n    // ======================= New data added for the upgrade ======================\n    // =============================================================================\n\n    mapping(address => bool) public isMinter;\n    /// @notice Reference to the treasury contract which can grant minting rights\n    address public treasury;\n    /// @notice Boolean to check whether the contract has been reinitialized after its upgrade\n    bool public treasuryInitialized;\n\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for fee computation\n    uint256 public constant BASE_PARAMS = 10 ** 9;\n\n    // =============================== Bridging Data ===============================\n\n    /// @notice Struct with some data about a specific bridge token\n    struct BridgeDetails {\n        // Limit on the balance of bridge token held by the contract: it is designed\n        // to reduce the exposure of the system to hacks\n        uint256 limit;\n        // Limit on the hourly volume of token minted through this bridge\n        // Technically the limit over a rolling hour is hourlyLimit x2 as hourly limit\n        // is enforced only between x:00 and x+1:00\n        uint256 hourlyLimit;\n        // Fee taken for swapping in and out the token\n        uint64 fee;\n        // Whether the associated token is allowed or not\n        bool allowed;\n        // Whether swapping in and out from the associated token is paused or not\n        bool paused;\n    }\n\n    /// @notice Maps a bridge token to data\n    mapping(address => BridgeDetails) public bridges;\n    /// @notice List of all bridge tokens\n    address[] public bridgeTokensList;\n    /// @notice Maps a bridge token to the associated hourly volume\n    mapping(address => mapping(uint256 => uint256)) public usage;\n    /// @notice Maps an address to whether it is exempt of fees for when it comes to swapping in and out\n    mapping(address => uint256) public isFeeExempt;\n    /// @notice Limit to the amount of tokens that can be sent from that chain to another chain\n    uint256 public chainTotalHourlyLimit;\n    /// @notice Usage per hour on that chain. Maps an hourly timestamp to the total volume swapped out on the chain\n    mapping(uint256 => uint256) public chainTotalUsage;\n\n    uint256[42] private __gap;\n\n    // ================================== Events ===================================\n\n    event BridgeTokenAdded(address indexed bridgeToken, uint256 limit, uint256 hourlyLimit, uint64 fee, bool paused);\n    event BridgeTokenToggled(address indexed bridgeToken, bool toggleStatus);\n    event BridgeTokenRemoved(address indexed bridgeToken);\n    event BridgeTokenFeeUpdated(address indexed bridgeToken, uint64 fee);\n    event BridgeTokenLimitUpdated(address indexed bridgeToken, uint256 limit);\n    event BridgeTokenHourlyLimitUpdated(address indexed bridgeToken, uint256 hourlyLimit);\n    event HourlyLimitUpdated(uint256 hourlyLimit);\n    event FeeToggled(address indexed theAddress, uint256 toggleStatus);\n    event KeeperToggled(address indexed keeper, bool toggleStatus);\n    event MinterToggled(address indexed minter);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event TreasuryUpdated(address indexed _treasury);\n\n    // ================================== Errors ===================================\n\n    error AssetStillControlledInReserves();\n    error BurnAmountExceedsAllowance();\n    error HourlyLimitExceeded();\n    error InvalidSender();\n    error InvalidToken();\n    error InvalidTreasury();\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error NotMinter();\n    error NotTreasury();\n    error TooBigAmount();\n    error TooHighParameterValue();\n    error TreasuryAlreadyInitialized();\n    error ZeroAddress();\n\n    /// @notice Checks to see if it is the `Treasury` calling this contract\n    /// @dev There is no Access Control here, because it can be handled cheaply through this modifier\n    modifier onlyTreasury() {\n        if (msg.sender != treasury) revert NotTreasury();\n        _;\n    }\n\n    /// @notice Checks whether the sender has the minting right\n    modifier onlyMinter() {\n        if (!isMinter[msg.sender]) revert NotMinter();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!ITreasury(treasury).isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!ITreasury(treasury).isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    /// @notice Sets up the treasury contract on Polygon after the upgrade\n    /// @param _treasury Address of the treasury contract\n    function setUpTreasury(address _treasury) external {\n        // Only governor on Polygon\n        if (msg.sender != 0xdA2D2f638D6fcbE306236583845e5822554c02EA) revert NotGovernor();\n        if (address(ITreasury(_treasury).stablecoin()) != address(this)) revert InvalidTreasury();\n        if (treasuryInitialized) revert TreasuryAlreadyInitialized();\n        treasury = _treasury;\n        treasuryInitialized = true;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // =========================== External Function ===============================\n\n    /// @notice Allows anyone to burn agToken without redeeming collateral back\n    /// @param amount Amount of stablecoins to burn\n    /// @dev This function can typically be called if there is a settlement mechanism to burn stablecoins\n    function burnStablecoin(uint256 amount) external {\n        _burnCustom(msg.sender, amount);\n    }\n\n    // ======================= Minter Role Only Functions ==========================\n\n    function burnSelf(uint256 amount, address burner) external onlyMinter {\n        _burnCustom(burner, amount);\n    }\n\n    function burnFrom(uint256 amount, address burner, address sender) external onlyMinter {\n        _burnFromNoRedeem(amount, burner, sender);\n    }\n\n    function mint(address account, uint256 amount) external onlyMinter {\n        _mint(account, amount);\n    }\n\n    // ======================= Treasury Only Functions =============================\n\n    function addMinter(address minter) external onlyTreasury {\n        isMinter[minter] = true;\n        emit MinterToggled(minter);\n    }\n\n    function removeMinter(address minter) external {\n        if (msg.sender != address(treasury) && msg.sender != minter) revert InvalidSender();\n        isMinter[minter] = false;\n        emit MinterToggled(minter);\n    }\n\n    function setTreasury(address _treasury) external onlyTreasury {\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // ============================ Internal Function ==============================\n\n    /// @notice Internal version of the function `burnFromNoRedeem`\n    /// @param amount Amount to burn\n    /// @dev It is at the level of this function that allowance checks are performed\n    function _burnFromNoRedeem(uint256 amount, address burner, address sender) internal {\n        if (burner != sender) {\n            uint256 currentAllowance = allowance(burner, sender);\n            if (currentAllowance < amount) revert BurnAmountExceedsAllowance();\n            _approve(burner, sender, currentAllowance - amount);\n        }\n        _burnCustom(burner, amount);\n    }\n\n    // ==================== External Permissionless Functions ======================\n\n    /// @notice Returns the list of all supported bridge tokens\n    /// @dev Helpful for UIs\n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridgeTokensList;\n    }\n\n    /// @notice Returns the current volume for a bridge, for the current hour\n    /// @dev Helpful for UIs\n    function currentUsage(address bridge) external view returns (uint256) {\n        return usage[bridge][block.timestamp / 3600];\n    }\n\n    /// @notice Returns the current total volume on the chain for the current hour\n    /// @dev Helpful for UIs\n    function currentTotalUsage() external view returns (uint256) {\n        return chainTotalUsage[block.timestamp / 3600];\n    }\n\n    /// @notice Mints the canonical token from a supported bridge token\n    /// @param bridgeToken Bridge token to use to mint\n    /// @param amount Amount of bridge tokens to send\n    /// @param to Address to which the stablecoin should be sent\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapIn(address bridgeToken, uint256 amount, address to) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n        uint256 balance = IERC20(bridgeToken).balanceOf(address(this));\n        if (balance + amount > bridgeDetails.limit) {\n            // In case someone maliciously sends tokens to this contract\n            // Or the limit changes\n            if (bridgeDetails.limit > balance) amount = bridgeDetails.limit - balance;\n            else {\n                amount = 0;\n            }\n        }\n\n        // Checking requirement on the hourly volume\n        uint256 hour = block.timestamp / 3600;\n        uint256 hourlyUsage = usage[bridgeToken][hour] + amount;\n        if (hourlyUsage > bridgeDetails.hourlyLimit) {\n            // Edge case when the hourly limit changes\n            if (bridgeDetails.hourlyLimit > usage[bridgeToken][hour])\n                amount = bridgeDetails.hourlyLimit - usage[bridgeToken][hour];\n            else {\n                amount = 0;\n            }\n        }\n        usage[bridgeToken][hour] += amount;\n\n        IERC20(bridgeToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 canonicalOut = amount;\n        // Computing fees\n        if (isFeeExempt[msg.sender] == 0) {\n            canonicalOut -= (canonicalOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        _mint(to, canonicalOut);\n        return canonicalOut;\n    }\n\n    /// @notice Burns the canonical token in exchange for a bridge token\n    /// @param bridgeToken Bridge token required\n    /// @param amount Amount of canonical tokens to burn\n    /// @param to Address to which the bridge token should be sent\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapOut(address bridgeToken, uint256 amount, address to) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n\n        uint256 hour = block.timestamp / 3600;\n        uint256 hourlyUsage = chainTotalUsage[hour] + amount;\n        // If the amount being swapped out exceeds the limit, we revert\n        // We don't want to change the amount being swapped out.\n        // The user can decide to send another tx with the correct amount to reach the limit\n        if (hourlyUsage > chainTotalHourlyLimit) revert HourlyLimitExceeded();\n        chainTotalUsage[hour] = hourlyUsage;\n\n        _burnCustom(msg.sender, amount);\n        uint256 bridgeOut = amount;\n        if (isFeeExempt[msg.sender] == 0) {\n            bridgeOut -= (bridgeOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        IERC20(bridgeToken).safeTransfer(to, bridgeOut);\n        return bridgeOut;\n    }\n\n    // ======================= Governance Functions ================================\n\n    /// @notice Adds support for a bridge token\n    /// @param bridgeToken Bridge token to add: it should be a version of the stablecoin from another bridge\n    /// @param limit Limit on the balance of bridge token this contract could hold\n    /// @param hourlyLimit Limit on the hourly volume for this bridge\n    /// @param paused Whether swapping for this token should be paused or not\n    /// @param fee Fee taken upon swapping for or against this token\n    function addBridgeToken(\n        address bridgeToken,\n        uint256 limit,\n        uint256 hourlyLimit,\n        uint64 fee,\n        bool paused\n    ) external onlyGovernor {\n        if (bridges[bridgeToken].allowed || bridgeToken == address(0)) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        BridgeDetails memory _bridge;\n        _bridge.limit = limit;\n        _bridge.hourlyLimit = hourlyLimit;\n        _bridge.paused = paused;\n        _bridge.fee = fee;\n        _bridge.allowed = true;\n        bridges[bridgeToken] = _bridge;\n        bridgeTokensList.push(bridgeToken);\n        emit BridgeTokenAdded(bridgeToken, limit, hourlyLimit, fee, paused);\n    }\n\n    /// @notice Removes support for a token\n    /// @param bridgeToken Address of the bridge token to remove support for\n    function removeBridgeToken(address bridgeToken) external onlyGovernor {\n        if (IERC20(bridgeToken).balanceOf(address(this)) != 0) revert AssetStillControlledInReserves();\n        delete bridges[bridgeToken];\n        // Deletion from `bridgeTokensList` loop\n        uint256 bridgeTokensListLength = bridgeTokensList.length;\n        for (uint256 i; i < bridgeTokensListLength - 1; ++i) {\n            if (bridgeTokensList[i] == bridgeToken) {\n                // Replace the `bridgeToken` to remove with the last of the list\n                bridgeTokensList[i] = bridgeTokensList[bridgeTokensListLength - 1];\n                break;\n            }\n        }\n        // Remove last element in array\n        bridgeTokensList.pop();\n        emit BridgeTokenRemoved(bridgeToken);\n    }\n\n    /// @notice Recovers any ERC20 token\n    /// @dev Can be used to withdraw bridge tokens for them to be de-bridged on mainnet\n    function recoverERC20(address tokenAddress, address to, uint256 amountToRecover) external onlyGovernor {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Updates the `limit` amount for `bridgeToken`\n    function setLimit(address bridgeToken, uint256 limit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].limit = limit;\n        emit BridgeTokenLimitUpdated(bridgeToken, limit);\n    }\n\n    /// @notice Updates the `hourlyLimit` amount for `bridgeToken`\n    function setHourlyLimit(address bridgeToken, uint256 hourlyLimit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].hourlyLimit = hourlyLimit;\n        emit BridgeTokenHourlyLimitUpdated(bridgeToken, hourlyLimit);\n    }\n\n    /// @notice Updates the `chainTotalHourlyLimit` amount\n    function setChainTotalHourlyLimit(uint256 hourlyLimit) external onlyGovernorOrGuardian {\n        chainTotalHourlyLimit = hourlyLimit;\n        emit HourlyLimitUpdated(hourlyLimit);\n    }\n\n    /// @notice Updates the `fee` value for `bridgeToken`\n    function setSwapFee(address bridgeToken, uint64 fee) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        bridges[bridgeToken].fee = fee;\n        emit BridgeTokenFeeUpdated(bridgeToken, fee);\n    }\n\n    /// @notice Pauses or unpauses swapping in and out for a token\n    function toggleBridge(address bridgeToken) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bool pausedStatus = bridges[bridgeToken].paused;\n        bridges[bridgeToken].paused = !pausedStatus;\n        emit BridgeTokenToggled(bridgeToken, !pausedStatus);\n    }\n\n    /// @notice Toggles fees for the address `theAddress`\n    function toggleFeesForAddress(address theAddress) external onlyGovernorOrGuardian {\n        uint256 feeExemptStatus = 1 - isFeeExempt[theAddress];\n        isFeeExempt[theAddress] = feeExemptStatus;\n        emit FeeToggled(theAddress, feeExemptStatus);\n    }\n}\n"
    },
    "contracts/agToken/polygon/utils/ERC20UpgradeableCustom.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface modified by Angle Labs, Inc.\n *\n * This implementation has a custom burn function to avoid having a {Transfer} event to the zero address\n * in some specific burn cases to avoid having Polygon PoS bridge catching this event\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20UpgradeableCustom is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    //solhint-disable-next-line\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    //solhint-disable-next-line\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Contrary to the other `burn` function, the {Transfer} event is not to the zero address\n     * but rather to this address: the reason is that not all burn events should be caught up\n     * by the PoS bridge\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burnCustom(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(this), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of `from`'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of `from`'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of `from`'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of `from`'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/coreBorrow/CoreBorrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n                  *                                                                                \n                *****                                                                            \n                  *                                                                        \n                                   *            ///.                                  \n                                 *****        ////////                                      \n                                   *       /////////////                                         \n                                       //////////////////                                      \n                                  ///////////////////////                                   \n                               ////////////////////////////                                 \n                              /////////////////////////                                \n                            ,//////////////////////////////////////                           \n                          //////////////////////////////////////////                           \n                        ///////////////////////////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////.,//////////////////////////                     \n                       .//////////////////////..,./////////////////////                       \n                        ...////////////////.....,.////////////////                        \n                          ,.,//////////// ........,///////////                          \n                            .,.,//////      ,.......///////                            \n                               ,..//           ........./                               \n                                 ..,                .....,                                 \n                                    .                     ,.,                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                   \n                                                                            \n                                                                          \n                                                            \n*/\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\n/// @title CoreBorrow\n/// @author Angle Labs, Inc.\n/// @notice Core contract of the borrowing module. This contract handles the access control across all contracts\n/// (it is read by all treasury contracts), and manages the `flashLoanModule`. It has no minting rights over the\n/// stablecoin contracts\ncontract CoreBorrow is ICoreBorrow, Initializable, AccessControlEnumerableUpgradeable {\n    /// @notice Role for guardians\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    /// @notice Role for governors\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    /// @notice Role for treasury contract\n    bytes32 public constant FLASHLOANER_TREASURY_ROLE = keccak256(\"FLASHLOANER_TREASURY_ROLE\");\n\n    // ============================= Reference =====================================\n\n    /// @notice Reference to the `flashLoanModule` with minting rights over the different stablecoins of the protocol\n    address public flashLoanModule;\n\n    // =============================== Events ======================================\n\n    event FlashLoanModuleUpdated(address indexed _flashloanModule);\n    event CoreUpdated(address indexed _core);\n\n    // =============================== Errors ======================================\n\n    error InvalidCore();\n    error IncompatibleGovernorAndGuardian();\n    error NotEnoughGovernorsLeft();\n    error ZeroAddress();\n\n    /// @notice Initializes the `CoreBorrow` contract and the access control of the borrowing module\n    /// @param governor Address of the governor of the Angle Protocol\n    /// @param guardian Guardian address of the protocol\n    function initialize(address governor, address guardian) public initializer {\n        if (governor == address(0) || guardian == address(0)) revert ZeroAddress();\n        if (governor == guardian) revert IncompatibleGovernorAndGuardian();\n        _setupRole(GOVERNOR_ROLE, governor);\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setupRole(GUARDIAN_ROLE, governor);\n        _setRoleAdmin(GUARDIAN_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(FLASHLOANER_TREASURY_ROLE, GOVERNOR_ROLE);\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // =========================== View Functions ==================================\n\n    /// @inheritdoc ICoreBorrow\n    function isFlashLoanerTreasury(address treasury) external view returns (bool) {\n        return hasRole(FLASHLOANER_TREASURY_ROLE, treasury);\n    }\n\n    /// @inheritdoc ICoreBorrow\n    function isGovernor(address admin) external view returns (bool) {\n        return hasRole(GOVERNOR_ROLE, admin);\n    }\n\n    /// @inheritdoc ICoreBorrow\n    function isGovernorOrGuardian(address admin) external view returns (bool) {\n        return hasRole(GUARDIAN_ROLE, admin);\n    }\n\n    // =========================== Governor Functions ==============================\n\n    /// @notice Grants the `FLASHLOANER_TREASURY_ROLE` to a `treasury` contract\n    /// @param treasury Contract to grant the role to\n    /// @dev This function can be used to allow flash loans on a stablecoin of the protocol\n    function addFlashLoanerTreasuryRole(address treasury) external {\n        grantRole(FLASHLOANER_TREASURY_ROLE, treasury);\n        address _flashLoanModule = flashLoanModule;\n        if (_flashLoanModule != address(0)) {\n            // This call will revert if `treasury` is the zero address or if it is not linked\n            // to this `CoreBorrow` contract\n            ITreasury(treasury).setFlashLoanModule(_flashLoanModule);\n            IFlashAngle(_flashLoanModule).addStablecoinSupport(treasury);\n        }\n    }\n\n    /// @notice Adds a governor in the protocol\n    /// @param governor Address to grant the role to\n    /// @dev It is necessary to call this function to grant a governor role to make sure\n    /// all governors also have the guardian role\n    function addGovernor(address governor) external {\n        grantRole(GOVERNOR_ROLE, governor);\n        grantRole(GUARDIAN_ROLE, governor);\n    }\n\n    /// @notice Revokes the flash loan ability for a stablecoin\n    /// @param treasury Treasury address associated with the stablecoin for which flash loans\n    /// should no longer be available\n    function removeFlashLoanerTreasuryRole(address treasury) external {\n        revokeRole(FLASHLOANER_TREASURY_ROLE, treasury);\n        ITreasury(treasury).setFlashLoanModule(address(0));\n        address _flashLoanModule = flashLoanModule;\n        if (_flashLoanModule != address(0)) {\n            IFlashAngle(flashLoanModule).removeStablecoinSupport(treasury);\n        }\n    }\n\n    /// @notice Revokes a governor from the protocol\n    /// @param governor Address to remove the role to\n    /// @dev It is necessary to call this function to remove a governor role to make sure\n    /// the address also loses its guardian role\n    function removeGovernor(address governor) external {\n        if (getRoleMemberCount(GOVERNOR_ROLE) <= 1) revert NotEnoughGovernorsLeft();\n        revokeRole(GUARDIAN_ROLE, governor);\n        revokeRole(GOVERNOR_ROLE, governor);\n    }\n\n    /// @notice Changes the `flashLoanModule` of the protocol\n    /// @param _flashLoanModule Address of the new flash loan module\n    function setFlashLoanModule(address _flashLoanModule) external onlyRole(GOVERNOR_ROLE) {\n        if (_flashLoanModule != address(0)) {\n            if (address(IFlashAngle(_flashLoanModule).core()) != address(this)) revert InvalidCore();\n        }\n        uint256 count = getRoleMemberCount(FLASHLOANER_TREASURY_ROLE);\n        for (uint256 i; i < count; ++i) {\n            ITreasury(getRoleMember(FLASHLOANER_TREASURY_ROLE, i)).setFlashLoanModule(_flashLoanModule);\n        }\n        flashLoanModule = _flashLoanModule;\n        emit FlashLoanModuleUpdated(_flashLoanModule);\n    }\n\n    /// @notice Changes the core contract of the protocol\n    /// @param _core New core contract\n    /// @dev This function verifies that all governors of the current core contract are also governors\n    /// of the new core contract. It also notifies the `flashLoanModule` of the change.\n    /// @dev Governance wishing to change the core contract should also make sure to call `setCore`\n    /// in the different treasury contracts\n    function setCore(ICoreBorrow _core) external onlyRole(GOVERNOR_ROLE) {\n        uint256 count = getRoleMemberCount(GOVERNOR_ROLE);\n        bool success;\n        for (uint256 i; i < count; ++i) {\n            success = _core.isGovernor(getRoleMember(GOVERNOR_ROLE, i));\n            if (!success) break;\n        }\n        if (!success) revert InvalidCore();\n        address _flashLoanModule = flashLoanModule;\n        if (_flashLoanModule != address(0)) IFlashAngle(_flashLoanModule).setCore(address(_core));\n        emit CoreUpdated(address(_core));\n    }\n}\n"
    },
    "contracts/deprecated/AgTokenIntermediateUpgrade.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/coreModule/IStableMaster.sol\";\n// OpenZeppelin may update its version of the ERC20PermitUpgradeable token\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\n/// @title AgTokenIntermediateUpgrade\n/// @author Angle Labs, Inc.\n/// @notice Base contract for agToken, that is to say Angle's stablecoins\n/// @dev This contract is used to create and handle the stablecoins of Angle protocol\n/// @dev It is still possible for any address to burn its agTokens without redeeming collateral in exchange\n/// @dev This contract is the upgraded version of the AgToken that was first deployed on Ethereum mainnet and is used to\n/// add other minters as needed by AMOs\ncontract AgTokenIntermediateUpgrade is ERC20PermitUpgradeable {\n    // ========================= References to other contracts =====================\n\n    /// @notice Reference to the `StableMaster` contract associated to this `AgToken`\n    address public stableMaster;\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializes the `AgToken` contract\n    /// @param name_ Name of the token\n    /// @param symbol_ Symbol of the token\n    /// @param stableMaster_ Reference to the `StableMaster` contract associated to this agToken\n    /// @dev By default, agTokens are ERC-20 tokens with 18 decimals\n    function initialize(string memory name_, string memory symbol_, address stableMaster_) external initializer {\n        __ERC20Permit_init(name_);\n        __ERC20_init(name_, symbol_);\n        require(stableMaster_ != address(0), \"0\");\n        stableMaster = stableMaster_;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ======= Added Parameters and Variables from the first implementation ========\n\n    /// @notice Checks whether an address has the right to mint agTokens\n    mapping(address => bool) public isMinter;\n\n    // =============================== Added Events ================================\n\n    event MinterToggled(address indexed minter);\n\n    // =============================== Setup Function ==============================\n\n    /// @notice Sets up the minter role and gives it to the governor\n    /// @dev This function just has to be called once\n    function setUpMinter() external {\n        address governor = 0xdC4e6DFe07EFCa50a197DF15D9200883eF4Eb1c8;\n        require(msg.sender == governor);\n        isMinter[governor] = true;\n        emit MinterToggled(governor);\n    }\n\n    // =============================== Modifiers ===================================\n\n    /// @notice Checks whether the sender has the minting right\n    modifier onlyMinter() {\n        require(isMinter[msg.sender] || msg.sender == stableMaster, \"35\");\n        _;\n    }\n\n    // ========================= External Functions ================================\n    // The following functions allow anyone to burn stablecoins without redeeming collateral\n    // in exchange for that\n\n    /// @notice Destroys `amount` token from the caller without giving collateral back\n    /// @param amount Amount to burn\n    /// @param poolManager Reference to the `PoolManager` contract for which the `stocksUsers` will\n    /// need to be updated\n    /// @dev When calling this function, people should specify the `poolManager` for which they want to decrease\n    /// the `stocksUsers`: this is a way for the protocol to maintain healthy accounting variables\n    function burnNoRedeem(uint256 amount, address poolManager) external {\n        _burn(msg.sender, amount);\n        IStableMaster(stableMaster).updateStocksUsers(amount, poolManager);\n    }\n\n    /// @notice Burns `amount` of agToken on behalf of another account without redeeming collateral back\n    /// @param account Account to burn on behalf of\n    /// @param amount Amount to burn\n    /// @param poolManager Reference to the `PoolManager` contract for which the `stocksUsers` will need to be updated\n    function burnFromNoRedeem(address account, uint256 amount, address poolManager) external {\n        _burnFromNoRedeem(amount, account, msg.sender);\n        IStableMaster(stableMaster).updateStocksUsers(amount, poolManager);\n    }\n\n    // ======================= Minter Role Only Functions ==========================\n\n    /// @notice Burns `amount` tokens from a `burner` address\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @dev This method is to be called by a contract with a minter right on the AgToken after being\n    /// requested to do so by an address willing to burn tokens from its address\n    function burnSelf(uint256 amount, address burner) external onlyMinter {\n        _burn(burner, amount);\n    }\n\n    /// @notice Burns `amount` tokens from a `burner` address after being asked to by `sender`\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @param sender Address which requested the burn from `burner`\n    /// @dev This method is to be called by a contract with the minter right after being requested\n    /// to do so by a `sender` address willing to burn tokens from another `burner` address\n    /// @dev The method checks the allowance between the `sender` and the `burner`\n    function burnFrom(uint256 amount, address burner, address sender) external onlyMinter {\n        _burnFromNoRedeem(amount, burner, sender);\n    }\n\n    /// @notice Lets the `StableMaster` contract or another whitelisted contract mint agTokens\n    /// @param account Address to mint to\n    /// @param amount Amount to mint\n    /// @dev The contracts allowed to issue agTokens are the `StableMaster` contract, `VaultManager` contracts\n    /// associated to this stablecoin as well as the flash loan module (if activated) and potentially contracts\n    /// whitelisted by governance\n    function mint(address account, uint256 amount) external onlyMinter {\n        _mint(account, amount);\n    }\n\n    // ======================= Minter Only Functions ===============================\n\n    /// @notice Adds a minter in the contract\n    /// @param minter Minter address to add\n    function addMinter(address minter) external onlyMinter {\n        isMinter[minter] = true;\n        emit MinterToggled(minter);\n    }\n\n    /// @notice Removes a minter from the contract\n    /// @param minter Minter address to remove\n    /// @dev This function can at the moment only be called by a minter wishing to revoke itself\n    function removeMinter(address minter) external {\n        require(msg.sender == minter && isMinter[msg.sender], \"36\");\n        isMinter[minter] = false;\n        emit MinterToggled(minter);\n    }\n\n    // ============================ Internal Function ==============================\n\n    /// @notice Internal version of the function `burnFromNoRedeem`\n    /// @param amount Amount to burn\n    /// @dev It is at the level of this function that allowance checks are performed\n    function _burnFromNoRedeem(uint256 amount, address burner, address sender) internal {\n        if (burner != sender) {\n            uint256 currentAllowance = allowance(burner, sender);\n            require(currentAllowance >= amount, \"23\");\n            _approve(burner, sender, currentAllowance - amount);\n        }\n        _burn(burner, amount);\n    }\n}\n"
    },
    "contracts/deprecated/layerZero/OldLayerZeroBridgeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"./OldOFTCore.sol\";\nimport \"../../interfaces/IAgTokenSideChainMultiBridge.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title LayerZeroBridgeToken\n/// @author Angle Labs, Inc., forked from https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/token/oft/OFT.sol\n/// @notice Contract to be deployed on a L2/sidechain for bridging an AgToken using a bridge intermediate token and LayerZero\ncontract OldLayerZeroBridgeToken is OldOFTCore, ERC20Upgradeable, PausableUpgradeable {\n    /// @notice Address of the bridgeable token\n    /// @dev Immutable\n    IAgTokenSideChainMultiBridge public canonicalToken;\n\n    // =============================== Errors ================================\n\n    error InvalidAllowance();\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializes the contract\n    /// @param _name Name of the token corresponding to this contract\n    /// @param _symbol Symbol of the token corresponding to this contract\n    /// @param _lzEndpoint Layer zero endpoint to pass messages\n    /// @param _treasury Address of the treasury contract used for access control\n    /// @param initialSupply Initial supply to mint to the canonical token address\n    /// @dev The initial supply corresponds to the initial amount that could be bridged using this OFT\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _lzEndpoint,\n        address _treasury,\n        uint256 initialSupply\n    ) external initializer {\n        __ERC20_init_unchained(_name, _symbol);\n        __LzAppUpgradeable_init(_lzEndpoint, _treasury);\n\n        canonicalToken = IAgTokenSideChainMultiBridge(address(ITreasury(_treasury).stablecoin()));\n        _approve(address(this), address(canonicalToken), type(uint256).max);\n        _mint(address(canonicalToken), initialSupply);\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ==================== External Permissionless Functions ======================\n\n    function sendWithPermit(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable override {\n        canonicalToken.permit(msg.sender, address(this), _amount, deadline, v, r, s);\n        send(_dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function withdraw(uint256 amount, address recipient) external override returns (uint256 amountMinted) {\n        // Does not check allowances as transfers from `msg.sender`\n        _transfer(msg.sender, address(this), amount);\n        amountMinted = canonicalToken.swapIn(address(this), amount, recipient);\n        uint256 leftover = balanceOf(address(this));\n        if (leftover != 0) {\n            _transfer(address(this), msg.sender, leftover);\n        }\n    }\n\n    // ============================= Internal Functions ===================================\n\n    function _debitFrom(\n        uint16,\n        bytes memory,\n        uint256 _amount\n    ) internal override whenNotPaused returns (uint256 amountSwapped) {\n        // No need to use safeTransferFrom as we know this implementation reverts on failure\n        canonicalToken.transferFrom(msg.sender, address(this), _amount);\n\n        // Swap canonical for this bridge token. There may be some fees\n        amountSwapped = canonicalToken.swapOut(address(this), _amount, address(this));\n        _burn(address(this), amountSwapped);\n    }\n\n    function _debitCreditFrom(uint16, bytes memory, uint256 _amount) internal override whenNotPaused returns (uint256) {\n        _burn(msg.sender, _amount);\n        return _amount;\n    }\n\n    function _creditTo(\n        uint16,\n        address _toAddress,\n        uint256 _amount\n    ) internal override whenNotPaused returns (uint256 amountMinted) {\n        _mint(address(this), _amount);\n        amountMinted = canonicalToken.swapIn(address(this), _amount, _toAddress);\n        uint256 leftover = balanceOf(address(this));\n        if (leftover != 0) {\n            _transfer(address(this), _toAddress, leftover);\n        }\n    }\n\n    // ======================= View Functions ================================\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IOFT).interfaceId ||\n            interfaceId == type(IERC20).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    // ======================= Governance Functions ================================\n\n    /// @notice Mints the intermediate contract to the `canonicalToken`\n    /// @dev Used to increase the bridging capacity\n    function mint(uint256 amount) external onlyGovernorOrGuardian {\n        _mint(address(canonicalToken), amount);\n    }\n\n    /// @notice Burns the intermediate contract from the `canonicalToken`\n    /// @dev Used to decrease the bridging capacity\n    function burn(uint256 amount) external onlyGovernorOrGuardian {\n        _burn(address(canonicalToken), amount);\n    }\n\n    /// @notice Increases allowance of the `canonicalToken`\n    function setupAllowance() public onlyGovernorOrGuardian {\n        _approve(address(this), address(canonicalToken), type(uint256).max);\n    }\n\n    /// @notice Pauses bridging through the contract\n    /// @param pause Future pause status\n    function pauseSendTokens(bool pause) external onlyGovernorOrGuardian {\n        pause ? _pause() : _unpause();\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/deprecated/layerZero/OldNonblockingLzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/external/layerZero/ILayerZeroReceiver.sol\";\nimport \"../../interfaces/external/layerZero/ILayerZeroUserApplicationConfig.sol\";\nimport \"../../interfaces/external/layerZero/ILayerZeroEndpoint.sol\";\nimport \"../../interfaces/ITreasury.sol\";\n\n/// @title OldNonblockingLzApp\n/// @author Angle Labs, Inc., forked from https://github.com/LayerZero-Labs/solidity-examples/\n/// @notice Base contract for bridging using LayerZero\nabstract contract OldNonblockingLzApp is Initializable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    /// @notice Layer Zero endpoint\n    ILayerZeroEndpoint public lzEndpoint;\n\n    /// @notice Maps chainIds to failed messages to retry them\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    /// @notice Maps chainIds to their OFT address\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n\n    /// @notice Reference to the treasury contract to fetch access control\n    address public treasury;\n\n    // ================================== Events ===================================\n\n    event SetTrustedRemote(uint16 _srcChainId, bytes _srcAddress);\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload);\n\n    // =============================== Errors ================================\n\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error InsufficientGas();\n    error InvalidEndpoint();\n    error InvalidSource();\n    error InvalidCaller();\n    error InvalidParams();\n    error InvalidPayload();\n    error ZeroAddress();\n\n    // ============================= Constructor ===================================\n\n    //solhint-disable-next-line\n    function __LzAppUpgradeable_init(address _endpoint, address _treasury) internal {\n        if (_endpoint == address(0) || _treasury == address(0)) revert ZeroAddress();\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        treasury = _treasury;\n    }\n\n    // =============================== Modifiers ===================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!ITreasury(treasury).isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    // ==================== External Permissionless Functions ======================\n\n    /// @notice Receives a message from the LZ endpoint and process it\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        if (msg.sender != address(lzEndpoint)) revert InvalidEndpoint();\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        if (_srcAddress.length != trustedRemote.length || keccak256(_srcAddress) != keccak256(trustedRemote))\n            revert InvalidSource();\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    /// @notice Retries a message that previously failed and was stored\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    function retryMessage(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        if (payloadHash == bytes32(0) || keccak256(_payload) != payloadHash) revert InvalidPayload();\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // ============================= Internal Functions ===================================\n\n    /// @notice Handles message receptions in a non blocking way\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    /// @dev public for the needs of try / catch but effectively internal\n    function nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public virtual {\n        // only internal transaction\n        if (msg.sender != address(this)) revert InvalidCaller();\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    /// @notice Handles message receptions in a non blocking way\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual;\n\n    /// @notice Handles message receptions in a blocking way\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Sender of the source chain\n    /// @param _nonce Nounce of the message\n    /// @param _payload Data: recipient address and amount\n    function _blockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal {\n        // try-catch all errors/exceptions\n        try this.nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload) {\n            // do nothing\n        } catch {\n            // error / exception\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload);\n        }\n    }\n\n    /// @notice Sends a message to the LZ endpoint and process it\n    /// @param _dstChainId L0 defined chain id to send tokens too\n    /// @param _payload Data: recipient address and amount\n    /// @param _refundAddress Address LayerZero refunds if too much message fee is sent\n    /// @param _zroPaymentAddress Set to address(0x0) if not paying in ZRO (LayerZero Token)\n    /// @param _adapterParams Flexible bytes array to indicate messaging adapter services in L0\n    function _lzSend(\n        uint16 _dstChainId,\n        bytes memory _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        if (trustedRemote.length == 0) revert InvalidSource();\n        //solhint-disable-next-line\n        lzEndpoint.send{ value: msg.value }(\n            _dstChainId,\n            trustedRemote,\n            _payload,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    // ======================= Governance Functions ================================\n\n    /// @notice Sets the corresponding address on an other chain.\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _srcAddress Address on the source chain\n    /// @dev Used for both receiving and sending message\n    /// @dev There can only be one trusted source per chain\n    /// @dev Allows owner to set it multiple times.\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external onlyGovernorOrGuardian {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    /// @notice Fetches the default LZ config\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address,\n        uint256 _configType\n    ) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    /// @notice Overrides the default LZ config\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint256 _configType,\n        bytes calldata _config\n    ) external override onlyGovernorOrGuardian {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    /// @notice Overrides the default LZ config\n    function setSendVersion(uint16 _version) external override onlyGovernorOrGuardian {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    /// @notice Overrides the default LZ config\n    function setReceiveVersion(uint16 _version) external override onlyGovernorOrGuardian {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    /// @notice Unpauses the receive functionalities\n    function forceResumeReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress\n    ) external override onlyGovernorOrGuardian {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // ======================= View Functions ================================\n\n    /// @notice Checks if the `_srcAddress` corresponds to the trusted source\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/deprecated/layerZero/OldOFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"./OldNonblockingLzApp.sol\";\nimport \"../../agToken/layerZero/utils/IOFTCore.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\n/// @title OFTCore\n/// @author Forked from https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/token/oft/OFTCore.sol\n/// but with slight modifications from the Angle Labs, Inc. which added return values to the `_creditTo` and `_debitFrom` functions\n/// @notice Base contract for bridging using LayerZero\nabstract contract OldOFTCore is OldNonblockingLzApp, ERC165Upgradeable, IOFTCore {\n    // ==================== External Permissionless Functions ======================\n\n    /// @inheritdoc IOFTCore\n    function sendWithPermit(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable virtual;\n\n    /// @inheritdoc IOFTCore\n    function send(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) public payable virtual {\n        _amount = _debitFrom(_dstChainId, _toAddress, _amount);\n\n        bytes memory payload = abi.encode(_toAddress, _amount);\n        _lzSend(_dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n\n        uint64 nonce = lzEndpoint.getOutboundNonce(_dstChainId, address(this));\n        emit SendToChain(msg.sender, _dstChainId, _toAddress, _amount, nonce);\n    }\n\n    /// @inheritdoc IOFTCore\n    function sendCredit(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) public payable virtual {\n        _amount = _debitCreditFrom(_dstChainId, _toAddress, _amount);\n\n        _send(_dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    /// @inheritdoc IOFTCore\n    function withdraw(uint256 amount, address recipient) external virtual returns (uint256);\n\n    // =========================== Internal Functions ==============================\n\n    /// @notice Internal function to send `_amount` amount of token to (`_dstChainId`, `_toAddress`)\n    /// @param _dstChainId the destination chain identifier\n    /// @param _toAddress can be any size depending on the `dstChainId`.\n    /// @param _amount the quantity of tokens in wei\n    /// @param _refundAddress the address LayerZero refunds if too much message fee is sent\n    /// @param _zroPaymentAddress set to address(0x0) if not paying in ZRO (LayerZero Token)\n    /// @param _adapterParams is a flexible bytes array to indicate messaging adapter services\n    /// @dev Accounting and checks should be performed beforehand\n    function _send(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) internal {\n        bytes memory payload = abi.encode(_toAddress, _amount);\n        _lzSend(_dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n\n        uint64 nonce = lzEndpoint.getOutboundNonce(_dstChainId, address(this));\n        emit SendToChain(msg.sender, _dstChainId, _toAddress, _amount, nonce);\n    }\n\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        // decode and load the toAddress\n        (bytes memory toAddressBytes, uint256 amount) = abi.decode(_payload, (bytes, uint256));\n        address toAddress;\n        //solhint-disable-next-line\n        assembly {\n            toAddress := mload(add(toAddressBytes, 20))\n        }\n        amount = _creditTo(_srcChainId, toAddress, amount);\n\n        emit ReceiveFromChain(_srcChainId, _srcAddress, toAddress, amount, _nonce);\n    }\n\n    /// @notice Makes accountability when bridging from this contract using canonical token\n    /// @param _dstChainId ChainId of the destination chain - LayerZero standard\n    /// @param _toAddress Recipient on the destination chain\n    /// @param _amount Amount to bridge\n    function _debitFrom(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount\n    ) internal virtual returns (uint256);\n\n    /// @notice Makes accountability when bridging from this contract's credit\n    /// @param _dstChainId ChainId of the destination chain - LayerZero standard\n    /// @param _toAddress Recipient on the destination chain\n    /// @param _amount Amount to bridge\n    function _debitCreditFrom(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount\n    ) internal virtual returns (uint256);\n\n    /// @notice Makes accountability when bridging to this contract\n    /// @param _srcChainId ChainId of the source chain - LayerZero standard\n    /// @param _toAddress Recipient on this chain\n    /// @param _amount Amount to bridge\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint256 _amount) internal virtual returns (uint256);\n\n    // ========================== View Functions ===================================\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IOFTCore\n    function estimateSendFee(\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint256 _amount,\n        bool _useZro,\n        bytes memory _adapterParams\n    ) public view virtual override returns (uint256 nativeFee, uint256 zroFee) {\n        // mock the payload for send()\n        bytes memory payload = abi.encode(_toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/deprecated/OldAgEUR.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/coreModule/IStableMaster.sol\";\nimport \"../interfaces/ITreasury.sol\";\n// OpenZeppelin may update its version of the ERC20PermitUpgradeable token\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\n/// @title AgToken\n/// @author Angle Labs, Inc.\n/// @notice Base contract for agToken, that is to say Angle's stablecoins\n/// @dev This contract is used to create and handle the stablecoins of Angle protocol\n/// @dev It is still possible for any address to burn its agTokens without redeeming collateral in exchange\n/// @dev This contract is the upgraded version of the AgToken that was first deployed on Ethereum mainnet\ncontract OldAgEUR is IAgToken, ERC20PermitUpgradeable {\n    // ========================= References to other contracts =====================\n\n    /// @notice Reference to the `StableMaster` contract associated to this `AgToken`\n    address public stableMaster;\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializes the `AgToken` contract\n    /// @param name_ Name of the token\n    /// @param symbol_ Symbol of the token\n    /// @param stableMaster_ Reference to the `StableMaster` contract associated to this agToken\n    /// @dev By default, agTokens are ERC-20 tokens with 18 decimals\n    function initialize(string memory name_, string memory symbol_, address stableMaster_) external initializer {\n        __ERC20Permit_init(name_);\n        __ERC20_init(name_, symbol_);\n        require(stableMaster_ != address(0), \"0\");\n        stableMaster = stableMaster_;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ======= Added Parameters and Variables from the first implementation ========\n\n    /// @inheritdoc IAgToken\n    mapping(address => bool) public isMinter;\n    /// @notice Reference to the treasury contract which can grant minting rights\n    address public treasury;\n    /// @notice Boolean to check whether the contract has been reinitialized after its upgrade\n    bool public treasuryInitialized;\n\n    // =============================== Added Events ================================\n\n    event TreasuryUpdated(address indexed _treasury);\n    event MinterToggled(address indexed minter);\n\n    // =============================== Added Errors ================================\n\n    error BurnAmountExceedsAllowance();\n    error InvalidSender();\n    error InvalidTreasury();\n    error NotGovernor();\n    error NotMinter();\n    error NotTreasury();\n    error TreasuryAlreadyInitialized();\n\n    // =============================== Setup Function ==============================\n\n    /// @notice Sets up the treasury contract in this AgToken contract\n    /// @param _treasury Treasury contract to add\n    /// @dev The address calling this function has to be hard-coded in the contract\n    /// @dev Can be called only once\n    function setUpTreasury(address _treasury) external {\n        // Only governor\n        if (msg.sender != 0xdC4e6DFe07EFCa50a197DF15D9200883eF4Eb1c8) revert NotGovernor();\n        if (address(ITreasury(_treasury).stablecoin()) != address(this)) revert InvalidTreasury();\n        if (treasuryInitialized) revert TreasuryAlreadyInitialized();\n        treasury = _treasury;\n        treasuryInitialized = true;\n        isMinter[stableMaster] = true;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // =============================== Modifiers ===================================\n\n    /// @notice Checks to see if it is the `Treasury` calling this contract\n    /// @dev There is no Access Control here, because it can be handled cheaply through this modifier\n    modifier onlyTreasury() {\n        if (msg.sender != treasury) revert NotTreasury();\n        _;\n    }\n\n    /// @notice Checks whether the sender has the minting right\n    modifier onlyMinter() {\n        if (!isMinter[msg.sender]) revert NotMinter();\n        _;\n    }\n\n    // ========================= External Functions ================================\n    // The following functions allow anyone to burn stablecoins without redeeming collateral\n    // in exchange for that\n\n    /// @notice Destroys `amount` token from the caller without giving collateral back\n    /// @param amount Amount to burn\n    /// @param poolManager Reference to the `PoolManager` contract for which the `stocksUsers` will\n    /// need to be updated\n    /// @dev When calling this function, people should specify the `poolManager` for which they want to decrease\n    /// the `stocksUsers`: this is a way for the protocol to maintain healthy accounting variables\n    function burnNoRedeem(uint256 amount, address poolManager) external {\n        _burn(msg.sender, amount);\n        IStableMaster(stableMaster).updateStocksUsers(amount, poolManager);\n    }\n\n    /// @notice Burns `amount` of agToken on behalf of another account without redeeming collateral back\n    /// @param account Account to burn on behalf of\n    /// @param amount Amount to burn\n    /// @param poolManager Reference to the `PoolManager` contract for which the `stocksUsers` will need to be updated\n    function burnFromNoRedeem(address account, uint256 amount, address poolManager) external {\n        _burnFromNoRedeem(amount, account, msg.sender);\n        IStableMaster(stableMaster).updateStocksUsers(amount, poolManager);\n    }\n\n    /// @notice Allows anyone to burn agToken without redeeming collateral back\n    /// @param amount Amount of stablecoins to burn\n    /// @dev This function can typically be called if there is a settlement mechanism to burn stablecoins\n    function burnStablecoin(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    // ======================= Minter Role Only Functions ==========================\n\n    /// @inheritdoc IAgToken\n    function burnSelf(uint256 amount, address burner) external onlyMinter {\n        _burn(burner, amount);\n    }\n\n    /// @inheritdoc IAgToken\n    function burnFrom(uint256 amount, address burner, address sender) external onlyMinter {\n        _burnFromNoRedeem(amount, burner, sender);\n    }\n\n    /// @inheritdoc IAgToken\n    function mint(address account, uint256 amount) external onlyMinter {\n        _mint(account, amount);\n    }\n\n    // ======================= Treasury Only Functions =============================\n\n    /// @inheritdoc IAgToken\n    function addMinter(address minter) external onlyTreasury {\n        isMinter[minter] = true;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function removeMinter(address minter) external {\n        // The `treasury` contract cannot remove the `stableMaster`\n        if (msg.sender != minter && (msg.sender != address(treasury) || minter == stableMaster)) revert InvalidSender();\n        isMinter[minter] = false;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function setTreasury(address _treasury) external onlyTreasury {\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // ============================ Internal Function ==============================\n\n    /// @notice Internal version of the function `burnFromNoRedeem`\n    /// @param amount Amount to burn\n    /// @dev It is at the level of this function that allowance checks are performed\n    function _burnFromNoRedeem(uint256 amount, address burner, address sender) internal {\n        if (burner != sender) {\n            uint256 currentAllowance = allowance(burner, sender);\n            if (currentAllowance < amount) revert BurnAmountExceedsAllowance();\n            _approve(burner, sender, currentAllowance - amount);\n        }\n        _burn(burner, amount);\n    }\n}\n"
    },
    "contracts/deprecated/OldAngleHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\nimport \"../interfaces/IAngleRouter.sol\";\nimport \"../interfaces/coreModule/IAgTokenMainnet.sol\";\nimport \"../interfaces/coreModule/ICore.sol\";\nimport \"../interfaces/coreModule/IOracleCore.sol\";\nimport \"../interfaces/coreModule/IPerpetualManager.sol\";\nimport \"../interfaces/coreModule/IPoolManager.sol\";\nimport \"../interfaces/coreModule/IStableMaster.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../interfaces/IVaultManager.sol\";\n\npragma solidity ^0.8.12;\n\nstruct Parameters {\n    SLPData slpData;\n    MintBurnData feeData;\n    PerpetualManagerFeeData perpFeeData;\n    PerpetualManagerParamData perpParam;\n}\n\nstruct PerpetualManagerFeeData {\n    uint64[] xHAFeesDeposit;\n    uint64[] yHAFeesDeposit;\n    uint64[] xHAFeesWithdraw;\n    uint64[] yHAFeesWithdraw;\n    uint64 haBonusMalusDeposit;\n    uint64 haBonusMalusWithdraw;\n}\n\nstruct PerpetualManagerParamData {\n    uint64 maintenanceMargin;\n    uint64 maxLeverage;\n    uint64 targetHAHedge;\n    uint64 limitHAHedge;\n    uint64 lockTime;\n}\n\nstruct CollateralAddresses {\n    address stableMaster;\n    address poolManager;\n    address perpetualManager;\n    address sanToken;\n    address oracle;\n    address gauge;\n    address feeManager;\n    address[] strategies;\n}\n\n/// @title AngleHelpers\n/// @author Angle Labs, Inc.\n/// @notice Contract with view functions designed to facilitate integrations on the Core module of the Angle Protocol\n/// @dev This contract only contains view functions to be queried off-chain. It was thus not optimized for gas consumption\ncontract OldAngleHelpers is Initializable {\n    // ======================== Helper View Functions ==============================\n\n    /// @notice Gives the amount of `agToken` you'd be getting if you were executing in the same block a mint transaction\n    /// with `amount` of `collateral` in the Core module of the Angle protocol as well as the value of the fees\n    /// (in `BASE_PARAMS`) that would be applied during the mint\n    /// @return Amount of `agToken` that would be obtained with a mint transaction in the same block\n    /// @return Percentage of fees that would be taken during a mint transaction in the same block\n    /// @dev This function reverts if the mint transaction was to revert in the same conditions (without taking into account\n    /// potential approval problems to the `StableMaster` contract)\n    function previewMintAndFees(\n        uint256 amount,\n        address agToken,\n        address collateral\n    ) external view returns (uint256, uint256) {\n        return _previewMintAndFees(amount, agToken, collateral);\n    }\n\n    /// @notice Gives the amount of `collateral` you'd be getting if you were executing in the same block a burn transaction\n    ///  with `amount` of `agToken` in the Core module of the Angle protocol as well as the value of the fees\n    /// (in `BASE_PARAMS`) that would be applied during the burn\n    /// @return Amount of `collateral` that would be obtained with a burn transaction in the same block\n    /// @return Percentage of fees that would be taken during a burn transaction in the same block\n    /// @dev This function reverts if the burn transaction was to revert in the same conditions (without taking into account\n    /// potential approval problems to the `StableMaster` contract or agToken balance prior to the call)\n    function previewBurnAndFees(\n        uint256 amount,\n        address agToken,\n        address collateral\n    ) external view returns (uint256, uint256) {\n        return _previewBurnAndFees(amount, agToken, collateral);\n    }\n\n    /// @notice Returns all the addresses associated to the (`agToken`,`collateral`) pair given\n    /// @return addresses A struct with all the addresses associated in the Core module\n    function getCollateralAddresses(\n        address agToken,\n        address collateral\n    ) external view returns (CollateralAddresses memory addresses) {\n        address stableMaster = IAgTokenMainnet(agToken).stableMaster();\n        (address poolManager, address perpetualManager, address sanToken, address gauge) = ROUTER.mapPoolManagers(\n            stableMaster,\n            collateral\n        );\n        (, , , IOracleCore oracle, , , , , ) = IStableMaster(stableMaster).collateralMap(poolManager);\n        addresses.stableMaster = stableMaster;\n        addresses.poolManager = poolManager;\n        addresses.perpetualManager = perpetualManager;\n        addresses.sanToken = sanToken;\n        addresses.gauge = gauge;\n        addresses.oracle = address(oracle);\n        addresses.feeManager = IPoolManager(poolManager).feeManager();\n\n        uint256 length = 0;\n        while (true) {\n            try IPoolManager(poolManager).strategyList(length) returns (address) {\n                length += 1;\n            } catch {\n                break;\n            }\n        }\n        address[] memory strategies = new address[](length);\n        for (uint256 i; i < length; ++i) {\n            strategies[i] = IPoolManager(poolManager).strategyList(i);\n        }\n        addresses.strategies = strategies;\n    }\n\n    /// @notice Gets the addresses of all the `StableMaster` contracts and their associated `AgToken` addresses\n    /// @return List of the `StableMaster` addresses of the Angle protocol\n    /// @return List of the `AgToken` addresses of the protocol\n    /// @dev The place of an agToken address in the list is the same as the corresponding `StableMaster` address\n    function getStablecoinAddresses() external view returns (address[] memory, address[] memory) {\n        address[] memory stableMasterAddresses = CORE.stablecoinList();\n        address[] memory agTokenAddresses = new address[](stableMasterAddresses.length);\n        for (uint256 i; i < stableMasterAddresses.length; ++i) {\n            agTokenAddresses[i] = IStableMaster(stableMasterAddresses[i]).agToken();\n        }\n        return (stableMasterAddresses, agTokenAddresses);\n    }\n\n    /// @notice Returns most of the governance parameters associated to the (`agToken`,`collateral`) pair given\n    /// @return params Struct with most of the parameters in the `StableMaster` and `PerpetualManager` contracts\n    /// @dev Check out the struct `Parameters` for the meaning of the return values\n    function getCollateralParameters(\n        address agToken,\n        address collateral\n    ) external view returns (Parameters memory params) {\n        (address stableMaster, address poolManager) = _getStableMasterAndPoolManager(agToken, collateral);\n        (\n            ,\n            ,\n            IPerpetualManager perpetualManager,\n            ,\n            ,\n            ,\n            ,\n            SLPData memory slpData,\n            MintBurnData memory feeData\n        ) = IStableMaster(stableMaster).collateralMap(poolManager);\n\n        params.slpData = slpData;\n        params.feeData = feeData;\n        params.perpParam.maintenanceMargin = perpetualManager.maintenanceMargin();\n        params.perpParam.maxLeverage = perpetualManager.maxLeverage();\n        params.perpParam.targetHAHedge = perpetualManager.targetHAHedge();\n        params.perpParam.limitHAHedge = perpetualManager.limitHAHedge();\n        params.perpParam.lockTime = perpetualManager.lockTime();\n\n        params.perpFeeData.haBonusMalusDeposit = perpetualManager.haBonusMalusDeposit();\n        params.perpFeeData.haBonusMalusWithdraw = perpetualManager.haBonusMalusWithdraw();\n\n        uint256 length = 0;\n        while (true) {\n            try perpetualManager.xHAFeesDeposit(length) returns (uint64) {\n                length += 1;\n            } catch {\n                break;\n            }\n        }\n        uint64[] memory data = new uint64[](length);\n        uint64[] memory data2 = new uint64[](length);\n        for (uint256 i; i < length; ++i) {\n            data[i] = perpetualManager.xHAFeesDeposit(i);\n            data2[i] = perpetualManager.yHAFeesDeposit(i);\n        }\n        params.perpFeeData.xHAFeesDeposit = data;\n        params.perpFeeData.yHAFeesDeposit = data2;\n\n        length = 0;\n        while (true) {\n            try perpetualManager.xHAFeesWithdraw(length) returns (uint64) {\n                length += 1;\n            } catch {\n                break;\n            }\n        }\n        data = new uint64[](length);\n        data2 = new uint64[](length);\n        for (uint256 i; i < length; ++i) {\n            data[i] = perpetualManager.xHAFeesWithdraw(i);\n            data2[i] = perpetualManager.yHAFeesWithdraw(i);\n        }\n        params.perpFeeData.xHAFeesWithdraw = data;\n        params.perpFeeData.yHAFeesWithdraw = data2;\n    }\n\n    /// @notice Returns the address of the poolManager associated to an (`agToken`, `collateral`) pair\n    /// in the Core module of the protocol\n    function getPoolManager(address agToken, address collateral) public view returns (address poolManager) {\n        (, poolManager) = _getStableMasterAndPoolManager(agToken, collateral);\n    }\n\n    // ======================== Replica Functions ==================================\n    // These replicate what is done in the other contracts of the protocol\n\n    function _previewBurnAndFees(\n        uint256 amount,\n        address agToken,\n        address collateral\n    ) internal view returns (uint256 amountForUserInCollat, uint256 feePercent) {\n        (address stableMaster, address poolManager) = _getStableMasterAndPoolManager(agToken, collateral);\n        (\n            address token,\n            ,\n            IPerpetualManager perpetualManager,\n            IOracleCore oracle,\n            uint256 stocksUsers,\n            ,\n            uint256 collatBase,\n            ,\n            MintBurnData memory feeData\n        ) = IStableMaster(stableMaster).collateralMap(poolManager);\n        if (token == address(0) || IStableMaster(stableMaster).paused(keccak256(abi.encodePacked(STABLE, poolManager))))\n            revert NotInitialized();\n        if (amount > stocksUsers) revert InvalidAmount();\n\n        if (feeData.xFeeBurn.length == 1) {\n            feePercent = feeData.yFeeBurn[0];\n        } else {\n            bytes memory data = abi.encode(address(perpetualManager), feeData.targetHAHedge);\n            uint64 hedgeRatio = _computeHedgeRatio(stocksUsers - amount, data);\n            feePercent = _piecewiseLinear(hedgeRatio, feeData.xFeeBurn, feeData.yFeeBurn);\n        }\n        feePercent = (feePercent * feeData.bonusMalusBurn) / BASE_PARAMS;\n\n        amountForUserInCollat = (amount * (BASE_PARAMS - feePercent) * collatBase) / (oracle.readUpper() * BASE_PARAMS);\n    }\n\n    function _previewMintAndFees(\n        uint256 amount,\n        address agToken,\n        address collateral\n    ) internal view returns (uint256 amountForUserInStable, uint256 feePercent) {\n        (address stableMaster, address poolManager) = _getStableMasterAndPoolManager(agToken, collateral);\n        (\n            address token,\n            ,\n            IPerpetualManager perpetualManager,\n            IOracleCore oracle,\n            uint256 stocksUsers,\n            ,\n            ,\n            ,\n            MintBurnData memory feeData\n        ) = IStableMaster(stableMaster).collateralMap(poolManager);\n        if (token == address(0) || IStableMaster(stableMaster).paused(keccak256(abi.encodePacked(STABLE, poolManager))))\n            revert NotInitialized();\n\n        amountForUserInStable = oracle.readQuoteLower(amount);\n\n        if (feeData.xFeeMint.length == 1) feePercent = feeData.yFeeMint[0];\n        else {\n            bytes memory data = abi.encode(address(perpetualManager), feeData.targetHAHedge);\n            uint64 hedgeRatio = _computeHedgeRatio(amountForUserInStable + stocksUsers, data);\n            feePercent = _piecewiseLinear(hedgeRatio, feeData.xFeeMint, feeData.yFeeMint);\n        }\n        feePercent = (feePercent * feeData.bonusMalusMint) / BASE_PARAMS;\n\n        amountForUserInStable = (amountForUserInStable * (BASE_PARAMS - feePercent)) / BASE_PARAMS;\n        if (stocksUsers + amountForUserInStable > feeData.capOnStableMinted) revert InvalidAmount();\n    }\n\n    // ======================== Utility Functions ==================================\n    // These utility functions are taken from other contracts of the protocol\n\n    function _computeHedgeRatio(uint256 newStocksUsers, bytes memory data) internal view returns (uint64 ratio) {\n        (address perpetualManager, uint64 targetHAHedge) = abi.decode(data, (address, uint64));\n        uint256 totalHedgeAmount = IPerpetualManager(perpetualManager).totalHedgeAmount();\n        newStocksUsers = (targetHAHedge * newStocksUsers) / BASE_PARAMS;\n        if (newStocksUsers > totalHedgeAmount) ratio = uint64((totalHedgeAmount * BASE_PARAMS) / newStocksUsers);\n        else ratio = uint64(BASE_PARAMS);\n    }\n\n    function _piecewiseLinear(uint64 x, uint64[] memory xArray, uint64[] memory yArray) internal pure returns (uint64) {\n        if (x >= xArray[xArray.length - 1]) {\n            return yArray[xArray.length - 1];\n        } else if (x <= xArray[0]) {\n            return yArray[0];\n        } else {\n            uint256 lower;\n            uint256 upper = xArray.length - 1;\n            uint256 mid;\n            while (upper - lower > 1) {\n                mid = lower + (upper - lower) / 2;\n                if (xArray[mid] <= x) {\n                    lower = mid;\n                } else {\n                    upper = mid;\n                }\n            }\n            if (yArray[upper] > yArray[lower]) {\n                return\n                    yArray[lower] +\n                    ((yArray[upper] - yArray[lower]) * (x - xArray[lower])) /\n                    (xArray[upper] - xArray[lower]);\n            } else {\n                return\n                    yArray[lower] -\n                    ((yArray[lower] - yArray[upper]) * (x - xArray[lower])) /\n                    (xArray[upper] - xArray[lower]);\n            }\n        }\n    }\n\n    function _getStableMasterAndPoolManager(\n        address agToken,\n        address collateral\n    ) internal view returns (address stableMaster, address poolManager) {\n        stableMaster = IAgTokenMainnet(agToken).stableMaster();\n        (poolManager, , , ) = ROUTER.mapPoolManagers(stableMaster, collateral);\n    }\n\n    // ====================== Constants and Initializers ===========================\n\n    IAngleRouter public constant ROUTER = IAngleRouter(0xBB755240596530be0c1DE5DFD77ec6398471561d);\n    ICore public constant CORE = ICore(0x61ed74de9Ca5796cF2F8fD60D54160D47E30B7c3);\n\n    bytes32 public constant STABLE = keccak256(\"STABLE\");\n    uint256 public constant BASE_PARAMS = 10 ** 9;\n\n    error NotInitialized();\n    error InvalidAmount();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n}\n"
    },
    "contracts/deprecated/vaultManager/OldVaultManagerERC721.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./OldVaultManagerStorage.sol\";\n\n/// @title VaultManagerERC721\n/// @author Angle Labs, Inc.\n/// @dev Base ERC721 Implementation of VaultManager\nabstract contract OldVaultManagerERC721 is IERC721MetadataUpgradeable, OldVaultManagerStorage {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// @inheritdoc IERC721MetadataUpgradeable\n    string public name;\n    /// @inheritdoc IERC721MetadataUpgradeable\n    string public symbol;\n\n    // ================================= MODIFIERS =================================\n\n    /// @notice Checks if the person interacting with the vault with `vaultID` is approved\n    /// @param caller Address of the person seeking to interact with the vault\n    /// @param vaultID ID of the concerned vault\n    modifier onlyApprovedOrOwner(address caller, uint256 vaultID) {\n        if (!_isApprovedOrOwner(caller, vaultID)) revert NotApproved();\n        _;\n    }\n\n    // ================================ ERC721 LOGIC ===============================\n\n    /// @notice Checks whether a given address is approved for a vault or owns this vault\n    /// @param spender Address for which vault ownership should be checked\n    /// @param vaultID ID of the vault to check\n    /// @return Whether the `spender` address owns or is approved for `vaultID`\n    function isApprovedOrOwner(address spender, uint256 vaultID) external view returns (bool) {\n        return _isApprovedOrOwner(spender, vaultID);\n    }\n\n    /// @inheritdoc IERC721MetadataUpgradeable\n    function tokenURI(uint256 vaultID) external view returns (string memory) {\n        if (!_exists(vaultID)) revert NonexistentVault();\n        // There is no vault with `vaultID` equal to 0, so the following variable is\n        // always greater than zero\n        uint256 temp = vaultID;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (vaultID != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(vaultID % 10)));\n            vaultID /= 10;\n        }\n        return bytes(_baseURI).length > 0 ? string(abi.encodePacked(_baseURI, string(buffer))) : \"\";\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function balanceOf(address owner) external view returns (uint256) {\n        if (owner == address(0)) revert ZeroAddress();\n        return _balances[owner];\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function ownerOf(uint256 vaultID) external view returns (address) {\n        return _ownerOf(vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function approve(address to, uint256 vaultID) external {\n        address owner = _ownerOf(vaultID);\n        if (to == owner) revert ApprovalToOwner();\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert NotApproved();\n\n        _approve(to, vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function getApproved(uint256 vaultID) external view returns (address) {\n        if (!_exists(vaultID)) revert NonexistentVault();\n        return _getApproved(vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator] == 1;\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function transferFrom(address from, address to, uint256 vaultID) external onlyApprovedOrOwner(msg.sender, vaultID) {\n        _transfer(from, to, vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function safeTransferFrom(address from, address to, uint256 vaultID) external {\n        safeTransferFrom(from, to, vaultID, \"\");\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 vaultID,\n        bytes memory _data\n    ) public onlyApprovedOrOwner(msg.sender, vaultID) {\n        _safeTransfer(from, to, vaultID, _data);\n    }\n\n    // ================================ ERC165 LOGIC ===============================\n\n    /// @inheritdoc IERC165Upgradeable\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IVaultManager).interfaceId ||\n            interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    // ================== INTERNAL FUNCTIONS FOR THE ERC721 LOGIC ==================\n\n    /// @notice Internal version of the `ownerOf` function\n    function _ownerOf(uint256 vaultID) internal view returns (address owner) {\n        owner = _owners[vaultID];\n        if (owner == address(0)) revert NonexistentVault();\n    }\n\n    /// @notice Internal version of the `getApproved` function\n    function _getApproved(uint256 vaultID) internal view returns (address) {\n        return _vaultApprovals[vaultID];\n    }\n\n    /// @notice Internal version of the `safeTransferFrom` function (with the data parameter)\n    function _safeTransfer(address from, address to, uint256 vaultID, bytes memory _data) internal {\n        _transfer(from, to, vaultID);\n        if (!_checkOnERC721Received(from, to, vaultID, _data)) revert NonERC721Receiver();\n    }\n\n    /// @notice Checks whether a vault exists\n    /// @param vaultID ID of the vault to check\n    /// @return Whether `vaultID` has been created\n    function _exists(uint256 vaultID) internal view returns (bool) {\n        return _owners[vaultID] != address(0);\n    }\n\n    /// @notice Internal version of the `isApprovedOrOwner` function\n    function _isApprovedOrOwner(address spender, uint256 vaultID) internal view returns (bool) {\n        // The following checks if the vault exists\n        address owner = _ownerOf(vaultID);\n        return (spender == owner || _getApproved(vaultID) == spender || _operatorApprovals[owner][spender] == 1);\n    }\n\n    /// @notice Internal version of the `createVault` function\n    /// Mints `vaultID` and transfers it to `to`\n    /// @dev This method is equivalent to the `_safeMint` method used in OpenZeppelin ERC721 contract\n    /// @dev Emits a {Transfer} event\n    function _mint(address to) internal returns (uint256 vaultID) {\n        if (whitelistingActivated && (isWhitelisted[to] != 1 || isWhitelisted[msg.sender] != 1))\n            revert NotWhitelisted();\n        if (to == address(0)) revert ZeroAddress();\n\n        unchecked {\n            vaultIDCount += 1;\n        }\n\n        vaultID = vaultIDCount;\n        _beforeTokenTransfer(address(0), to, vaultID);\n\n        unchecked {\n            _balances[to] += 1;\n        }\n\n        _owners[vaultID] = to;\n        emit Transfer(address(0), to, vaultID);\n        if (!_checkOnERC721Received(address(0), to, vaultID, \"\")) revert NonERC721Receiver();\n    }\n\n    /// @notice Destroys `vaultID`\n    /// @dev `vaultID` must exist\n    /// @dev Emits a {Transfer} event\n    function _burn(uint256 vaultID) internal {\n        address owner = _ownerOf(vaultID);\n\n        _beforeTokenTransfer(owner, address(0), vaultID);\n        // Clear approvals\n        _approve(address(0), vaultID);\n        // The following line cannot underflow as the owner's balance is necessarily\n        // greater than 1\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[vaultID];\n        delete vaultData[vaultID];\n\n        emit Transfer(owner, address(0), vaultID);\n    }\n\n    /// @notice Transfers `vaultID` from `from` to `to` as opposed to {transferFrom},\n    /// this imposes no restrictions on msg.sender\n    /// @dev `to` cannot be the zero address and `perpetualID` must be owned by `from`\n    /// @dev Emits a {Transfer} event\n    /// @dev A whitelist check is performed if necessary on the `to` address\n    function _transfer(address from, address to, uint256 vaultID) internal {\n        if (_ownerOf(vaultID) != from) revert NotApproved();\n        if (to == address(0)) revert ZeroAddress();\n        if (whitelistingActivated && isWhitelisted[to] != 1) revert NotWhitelisted();\n\n        _beforeTokenTransfer(from, to, vaultID);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), vaultID);\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[vaultID] = to;\n\n        emit Transfer(from, to, vaultID);\n    }\n\n    /// @notice Approves `to` to operate on `vaultID`\n    function _approve(address to, uint256 vaultID) internal {\n        _vaultApprovals[vaultID] = to;\n        emit Approval(_ownerOf(vaultID), to, vaultID);\n    }\n\n    /// @notice Internal version of the `setApprovalForAll` function\n    /// @dev It contains an `approver` field to be used in case someone signs a permit for a particular\n    /// address, and this signature is given to the contract by another address (like a router)\n    function _setApprovalForAll(address approver, address operator, bool approved) internal {\n        if (operator == approver) revert ApprovalToCaller();\n        uint256 approval = approved ? 1 : 0;\n        _operatorApprovals[approver][operator] = approval;\n        emit ApprovalForAll(approver, operator, approved);\n    }\n\n    /// @notice Internal function to invoke {IERC721Receiver-onERC721Received} on a target address\n    /// The call is not executed if the target address is not a contract\n    /// @param from Address representing the previous owner of the given token ID\n    /// @param to Target address that will receive the tokens\n    /// @param vaultID ID of the token to be transferred\n    /// @param _data Bytes optional data to send along with the call\n    /// @return Bool whether the call correctly returned the expected value\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 vaultID,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(msg.sender, from, vaultID, _data) returns (\n                bytes4 retval\n            ) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert NonERC721Receiver();\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /// @notice Hook that is called before any token transfer. This includes minting and burning.\n    ///  Calling conditions:\n    ///\n    ///  - When `from` and `to` are both non-zero, `from`'s `vaultID` will be\n    ///  transferred to `to`.\n    ///  - When `from` is zero, `vaultID` will be minted for `to`.\n    ///  - When `to` is zero, `from`'s `vaultID` will be burned.\n    ///  - `from` and `to` are never both zero.\n    function _beforeTokenTransfer(address from, address to, uint256 vaultID) internal virtual {}\n}\n"
    },
    "contracts/deprecated/vaultManager/OldVaultManagerPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./OldVaultManagerERC721.sol\";\nimport \"../../interfaces/external/IERC1271.sol\";\n\n/// @title VaultManagerPermit\n/// @author Angle Labs, Inc.\n/// @dev Base Implementation of permit functions for the `VaultManager` contract\nabstract contract OldVaultManagerPermit is Initializable, OldVaultManagerERC721 {\n    using Address for address;\n\n    mapping(address => uint256) private _nonces;\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private _PERMIT_TYPEHASH;\n    /* solhint-enable var-name-mixedcase */\n\n    error ExpiredDeadline();\n    error InvalidSignature();\n\n    //solhint-disable-next-line\n    function __ERC721Permit_init(string memory _name) internal onlyInitializing {\n        _PERMIT_TYPEHASH = keccak256(\n            \"Permit(address owner,address spender,bool approved,uint256 nonce,uint256 deadline)\"\n        );\n        _HASHED_NAME = keccak256(bytes(_name));\n        _HASHED_VERSION = keccak256(bytes(\"1\"));\n    }\n\n    /// @notice Allows an address to give or revoke approval for all its vaults to another address\n    /// @param owner Address signing the permit and giving (or revoking) its approval for all the controlled vaults\n    /// @param spender Address to give approval to\n    /// @param approved Whether to give or revoke the approval\n    /// @param deadline Deadline parameter for the signature to be valid\n    /// @dev The `v`, `r`, and `s` parameters are used as signature data\n    function permit(\n        address owner,\n        address spender,\n        bool approved,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        if (block.timestamp > deadline) revert ExpiredDeadline();\n        // Additional signature checks performed in the `ECDSAUpgradeable.recover` function\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0 || (v != 27 && v != 28))\n            revert InvalidSignature();\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                _domainSeparatorV4(),\n                keccak256(\n                    abi.encode(\n                        _PERMIT_TYPEHASH,\n                        // 0x3f43a9c6bafb5c7aab4e0cfe239dc5d4c15caf0381c6104188191f78a6640bd8,\n                        owner,\n                        spender,\n                        approved,\n                        _useNonce(owner),\n                        deadline\n                    )\n                )\n            )\n        );\n        if (owner.isContract()) {\n            if (IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) != 0x1626ba7e)\n                revert InvalidSignature();\n        } else {\n            address signer = ecrecover(digest, v, r, s);\n            if (signer != owner || signer == address(0)) revert InvalidSignature();\n        }\n\n        _setApprovalForAll(owner, spender, approved);\n    }\n\n    /// @notice Returns the current nonce for an `owner` address\n    function nonces(address owner) public view returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /// @notice Returns the domain separator for the current chain.\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /// @notice Internal version of the `DOMAIN_SEPARATOR` function\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                    _HASHED_NAME,\n                    _HASHED_VERSION,\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /// @notice Consumes a nonce for an address: returns the current value and increments it\n    function _useNonce(address owner) internal returns (uint256 current) {\n        current = _nonces[owner];\n        _nonces[owner] = current + 1;\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/deprecated/vaultManager/OldVaultManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IAgToken.sol\";\nimport \"../../interfaces/IOracle.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"../../interfaces/ITreasury.sol\";\nimport \"../../interfaces/IVaultManager.sol\";\nimport \"../../interfaces/governance/IVeBoostProxy.sol\";\n\n/// @title VaultManagerStorage\n/// @author Angle Labs, Inc.\n/// @dev Variables, references, parameters and events needed in the `VaultManager` contract\n// solhint-disable-next-line max-states-count\ncontract OldVaultManagerStorage is IVaultManagerStorage, Initializable, ReentrancyGuardUpgradeable {\n    /// @notice Base used for parameter computation: almost all the parameters of this contract are set in `BASE_PARAMS`\n    uint256 public constant BASE_PARAMS = 10 ** 9;\n    /// @notice Base used for interest rate computation\n    uint256 public constant BASE_INTEREST = 10 ** 27;\n    /// @notice Used for interest rate computation\n    uint256 public constant HALF_BASE_INTEREST = 10 ** 27 / 2;\n\n    // ================================= REFERENCES ================================\n\n    /// @inheritdoc IVaultManagerStorage\n    ITreasury public treasury;\n    /// @inheritdoc IVaultManagerStorage\n    IERC20 public collateral;\n    /// @inheritdoc IVaultManagerStorage\n    IAgToken public stablecoin;\n    /// @inheritdoc IVaultManagerStorage\n    IOracle public oracle;\n    /// @notice Reference to the contract which computes adjusted veANGLE balances for liquidators boosts\n    IVeBoostProxy public veBoostProxy;\n    /// @notice Base of the collateral\n    uint256 internal _collatBase;\n\n    // ================================= PARAMETERS ================================\n    // Unless specified otherwise, parameters of this contract are expressed in `BASE_PARAMS`\n\n    /// @notice Maximum amount of stablecoins that can be issued with this contract (in `BASE_TOKENS`). This parameter should\n    /// not be bigger than `type(uint256).max / BASE_INTEREST` otherwise there may be some overflows in the `increaseDebt` function\n    uint256 public debtCeiling;\n    /// @notice Threshold veANGLE balance values for the computation of the boost for liquidators: the length of this array\n    /// should normally be 2. The base of the x-values in this array should be `BASE_TOKENS`\n    uint256[] public xLiquidationBoost;\n    /// @notice Values of the liquidation boost at the threshold values of x\n    uint256[] public yLiquidationBoost;\n    /// @inheritdoc IVaultManagerStorage\n    uint64 public collateralFactor;\n    /// @notice Maximum Health factor at which a vault can end up after a liquidation (unless it's fully liquidated)\n    uint64 public targetHealthFactor;\n    /// @notice Upfront fee taken when borrowing stablecoins: this fee is optional and should in practice not be used\n    uint64 public borrowFee;\n    /// @notice Upfront fee taken when repaying stablecoins: this fee is optional as well. It should be smaller\n    /// than the liquidation surcharge (cf below) to avoid exploits where people voluntarily get liquidated at a 0\n    /// discount to pay smaller repaying fees\n    uint64 public repayFee;\n    /// @notice Per second interest taken to borrowers taking agToken loans. Contrarily to other parameters, it is set in `BASE_INTEREST`\n    /// that is to say in base 10**27\n    uint64 public interestRate;\n    /// @notice Fee taken by the protocol during a liquidation. Technically, this value is not the fee per se, it's 1 - fee.\n    /// For instance for a 2% fee, `liquidationSurcharge` should be 98%\n    uint64 public liquidationSurcharge;\n    /// @notice Maximum discount given to liquidators\n    uint64 public maxLiquidationDiscount;\n    /// @notice Whether whitelisting is required to own a vault or not\n    bool public whitelistingActivated;\n    /// @notice Whether the contract is paused or not\n    bool public paused;\n\n    // ================================= VARIABLES =================================\n\n    /// @notice Timestamp at which the `interestAccumulator` was updated\n    uint256 public lastInterestAccumulatorUpdated;\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public interestAccumulator;\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public totalNormalizedDebt;\n    /// @notice Surplus accumulated by the contract: surplus is always in stablecoins, and is then reset\n    /// when the value is communicated to the treasury contract\n    uint256 public surplus;\n    /// @notice Bad debt made from liquidated vaults which ended up having no collateral and a positive amount\n    /// of stablecoins\n    uint256 public badDebt;\n\n    // ================================== MAPPINGS =================================\n\n    /// @inheritdoc IVaultManagerStorage\n    mapping(uint256 => Vault) public vaultData;\n    /// @notice Maps an address to 1 if it's whitelisted and can open or own a vault\n    mapping(address => uint256) public isWhitelisted;\n\n    // ================================ ERC721 DATA ================================\n\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public vaultIDCount;\n\n    /// @notice URI\n    string internal _baseURI;\n\n    // Mapping from `vaultID` to owner address\n    mapping(uint256 => address) internal _owners;\n\n    // Mapping from owner address to vault owned count\n    mapping(address => uint256) internal _balances;\n\n    // Mapping from `vaultID` to approved address\n    mapping(uint256 => address) internal _vaultApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => uint256)) internal _operatorApprovals;\n\n    uint256[50] private __gap;\n\n    // =================================== EVENTS ==================================\n\n    event AccruedToTreasury(uint256 surplusEndValue, uint256 badDebtEndValue);\n    event CollateralAmountUpdated(uint256 vaultID, uint256 collateralAmount, uint8 isIncrease);\n    event InterestAccumulatorUpdated(uint256 value, uint256 timestamp);\n    event InternalDebtUpdated(uint256 vaultID, uint256 internalAmount, uint8 isIncrease);\n    event FiledUint64(uint64 param, bytes32 what);\n    event DebtCeilingUpdated(uint256 debtCeiling);\n    event LiquidationBoostParametersUpdated(address indexed _veBoostProxy, uint256[] xBoost, uint256[] yBoost);\n    event LiquidatedVaults(uint256[] vaultIDs);\n    event DebtTransferred(uint256 srcVaultID, uint256 dstVaultID, address dstVaultManager, uint256 amount);\n\n    // =================================== ERRORS ==================================\n\n    error ApprovalToOwner();\n    error ApprovalToCaller();\n    error DustyLeftoverAmount();\n    error DebtCeilingExceeded();\n    error HealthyVault();\n    error IncompatibleLengths();\n    error InsolventVault();\n    error InvalidParameterValue();\n    error InvalidParameterType();\n    error InvalidSetOfParameters();\n    error InvalidTreasury();\n    error NonERC721Receiver();\n    error NonexistentVault();\n    error NotApproved();\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error NotTreasury();\n    error NotWhitelisted();\n    error NotVaultManager();\n    error Paused();\n    error TooHighParameterValue();\n    error TooSmallParameterValue();\n    error ZeroAddress();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n}\n"
    },
    "contracts/external/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n * This contract was fully forked from OpenZeppelin `ProxyAdmin`\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{ value: msg.value }(implementation, data);\n    }\n}\n"
    },
    "contracts/external/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin. It is fully forked from OpenZeppelin\n * `TransparentUpgradeableProxy`\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/flashloan/FlashAngle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\n/// @title FlashAngle\n/// @author Angle Labs, Inc.\n/// @notice Contract to take flash loans on top of several AgToken contracts\ncontract FlashAngle is IERC3156FlashLender, IFlashAngle, Initializable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_PARAMS = 10 ** 9;\n    /// @notice Success message received when calling a `FlashBorrower` contract\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// @notice Struct encoding for a given stablecoin the parameters\n    struct StablecoinData {\n        // Maximum amount borrowable for this stablecoin\n        uint256 maxBorrowable;\n        // Flash loan fee taken by the protocol for a flash loan on this stablecoin\n        uint64 flashLoanFee;\n        // Treasury address responsible of the stablecoin\n        address treasury;\n    }\n\n    // ======================= Parameters and References ===========================\n\n    /// @notice Maps a stablecoin to the data and parameters for flash loans\n    mapping(IAgToken => StablecoinData) public stablecoinMap;\n    /// @inheritdoc IFlashAngle\n    ICoreBorrow public core;\n\n    // =============================== Event =======================================\n\n    event FlashLoan(address indexed stablecoin, uint256 amount, IERC3156FlashBorrower indexed receiver);\n    event FlashLoanParametersUpdated(IAgToken indexed stablecoin, uint64 _flashLoanFee, uint256 _maxBorrowable);\n\n    // =============================== Errors ======================================\n\n    error InvalidReturnMessage();\n    error NotCore();\n    error NotGovernorOrGuardian();\n    error NotTreasury();\n    error TooBigAmount();\n    error TooHighParameterValue();\n    error UnsupportedStablecoin();\n    error ZeroAddress();\n\n    /// @notice Initializes the contract\n    /// @param _core Core address handling this module\n    function initialize(ICoreBorrow _core) public initializer {\n        if (address(_core) == address(0)) revert ZeroAddress();\n        core = _core;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // =================================== Modifiers ===============================\n\n    /// @notice Checks whether the sender is the core contract\n    modifier onlyCore() {\n        if (msg.sender != address(core)) revert NotCore();\n        _;\n    }\n\n    /// @notice Checks whether a given stablecoin has been initialized in this contract\n    /// @param stablecoin Stablecoin to check\n    /// @dev To check whether a stablecoin has been initialized, we just need to check whether its associated\n    /// `treasury` address is not null in the `stablecoinMap`. This is what's checked in the `CoreBorrow` contract\n    /// when adding support for a stablecoin\n    modifier onlyExistingStablecoin(IAgToken stablecoin) {\n        if (stablecoinMap[stablecoin].treasury == address(0)) revert UnsupportedStablecoin();\n        _;\n    }\n\n    // ================================ ERC3156 Spec ===============================\n\n    /// @inheritdoc IERC3156FlashLender\n    function flashFee(address token, uint256 amount) external view returns (uint256) {\n        return _flashFee(token, amount);\n    }\n\n    /// @inheritdoc IERC3156FlashLender\n    function maxFlashLoan(address token) external view returns (uint256) {\n        // It will be 0 anyway if the token was not added\n        return stablecoinMap[IAgToken(token)].maxBorrowable;\n    }\n\n    /// @inheritdoc IERC3156FlashLender\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external nonReentrant returns (bool) {\n        uint256 fee = _flashFee(token, amount);\n        if (amount > stablecoinMap[IAgToken(token)].maxBorrowable) revert TooBigAmount();\n        IAgToken(token).mint(address(receiver), amount);\n        if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS)\n            revert InvalidReturnMessage();\n        // Token must be an agToken here so normally no need to use `safeTransferFrom`, but out of safety\n        // and in case governance whitelists an agToken which does not have a correct implementation, we prefer\n        // to use `safeTransferFrom` here\n        IERC20(token).safeTransferFrom(address(receiver), address(this), amount + fee);\n        IAgToken(token).burnSelf(amount, address(this));\n        emit FlashLoan(token, amount, receiver);\n        return true;\n    }\n\n    /// @notice Internal function to compute the fee induced for taking a flash loan of `amount` of `token`\n    /// @param token The loan currency\n    /// @param amount The amount of tokens lent\n    /// @dev This function will revert if the `token` requested is not whitelisted here\n    function _flashFee(\n        address token,\n        uint256 amount\n    ) internal view onlyExistingStablecoin(IAgToken(token)) returns (uint256) {\n        return (amount * stablecoinMap[IAgToken(token)].flashLoanFee) / BASE_PARAMS;\n    }\n\n    // ============================ Treasury Only Function =========================\n\n    /// @inheritdoc IFlashAngle\n    function accrueInterestToTreasury(IAgToken stablecoin) external returns (uint256 balance) {\n        address treasury = stablecoinMap[stablecoin].treasury;\n        if (msg.sender != treasury) revert NotTreasury();\n        balance = stablecoin.balanceOf(address(this));\n        IERC20(address(stablecoin)).safeTransfer(treasury, balance);\n    }\n\n    // =========================== Governance Only Function ========================\n\n    /// @notice Sets the parameters for a given stablecoin\n    /// @param stablecoin Stablecoin to change the parameters for\n    /// @param _flashLoanFee New flash loan fee for this stablecoin\n    /// @param _maxBorrowable Maximum amount that can be borrowed in a single flash loan\n    /// @dev Setting a `maxBorrowable` parameter equal to 0 is a way to pause the functionality\n    /// @dev Parameters can only be modified for whitelisted stablecoins\n    function setFlashLoanParameters(\n        IAgToken stablecoin,\n        uint64 _flashLoanFee,\n        uint256 _maxBorrowable\n    ) external onlyExistingStablecoin(stablecoin) {\n        if (!core.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        if (_flashLoanFee > BASE_PARAMS) revert TooHighParameterValue();\n        stablecoinMap[stablecoin].flashLoanFee = _flashLoanFee;\n        stablecoinMap[stablecoin].maxBorrowable = _maxBorrowable;\n        emit FlashLoanParametersUpdated(stablecoin, _flashLoanFee, _maxBorrowable);\n    }\n\n    // =========================== CoreBorrow Only Functions =======================\n\n    /// @inheritdoc IFlashAngle\n    function addStablecoinSupport(address _treasury) external onlyCore {\n        stablecoinMap[IAgToken(ITreasury(_treasury).stablecoin())].treasury = _treasury;\n    }\n\n    /// @inheritdoc IFlashAngle\n    function removeStablecoinSupport(address _treasury) external onlyCore {\n        delete stablecoinMap[IAgToken(ITreasury(_treasury).stablecoin())];\n    }\n\n    /// @inheritdoc IFlashAngle\n    function setCore(address _core) external onlyCore {\n        core = ICoreBorrow(_core);\n    }\n}\n"
    },
    "contracts/interfaces/coreModule/IAgTokenMainnet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title IAgTokenMainnet\n/// @author Angle Labs, Inc.\ninterface IAgTokenMainnet {\n    function stableMaster() external view returns (address);\n}\n"
    },
    "contracts/interfaces/coreModule/ICore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title ICore\n/// @author Angle Labs, Inc.\ninterface ICore {\n    function stablecoinList() external view returns (address[] memory);\n}\n"
    },
    "contracts/interfaces/coreModule/ILiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface ILiquidityGauge {\n    function deposit(\n        uint256 _value,\n        address _addr,\n        // solhint-disable-next-line\n        bool _claim_rewards\n    ) external;\n\n    function withdraw(\n        uint256 _value,\n        // solhint-disable-next-line\n        bool _claim_rewards\n    ) external;\n\n    // solhint-disable-next-line\n    function claim_rewards(address _addr, address _receiver) external;\n\n    // solhint-disable-next-line\n    function claimable_reward(address _addr, address _reward_token) external view returns (uint256 amount);\n}\n"
    },
    "contracts/interfaces/coreModule/IOracleCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title IOracleCore\n/// @author Angle Labs, Inc.\ninterface IOracleCore {\n    function readUpper() external view returns (uint256);\n\n    function readQuoteLower(uint256 baseAmount) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/coreModule/IPerpetualManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title IPerpetualManager\n/// @author Angle Labs, Inc.\ninterface IPerpetualManager {\n    function totalHedgeAmount() external view returns (uint256);\n\n    function maintenanceMargin() external view returns (uint64);\n\n    function maxLeverage() external view returns (uint64);\n\n    function targetHAHedge() external view returns (uint64);\n\n    function limitHAHedge() external view returns (uint64);\n\n    function lockTime() external view returns (uint64);\n\n    function haBonusMalusDeposit() external view returns (uint64);\n\n    function haBonusMalusWithdraw() external view returns (uint64);\n\n    function xHAFeesDeposit(uint256) external view returns (uint64);\n\n    function yHAFeesDeposit(uint256) external view returns (uint64);\n\n    function xHAFeesWithdraw(uint256) external view returns (uint64);\n\n    function yHAFeesWithdraw(uint256) external view returns (uint64);\n}\n"
    },
    "contracts/interfaces/coreModule/IPoolManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title IPoolManager\n/// @author Angle Labs, Inc.\ninterface IPoolManager {\n    function feeManager() external view returns (address);\n\n    function strategyList(uint256) external view returns (address);\n}\n"
    },
    "contracts/interfaces/coreModule/IStableMaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./IPerpetualManager.sol\";\nimport \"./IOracleCore.sol\";\n\n// Struct to handle all the parameters to manage the fees\n// related to a given collateral pool (associated to the stablecoin)\nstruct MintBurnData {\n    // Values of the thresholds to compute the minting fees\n    // depending on HA hedge (scaled by `BASE_PARAMS`)\n    uint64[] xFeeMint;\n    // Values of the fees at thresholds (scaled by `BASE_PARAMS`)\n    uint64[] yFeeMint;\n    // Values of the thresholds to compute the burning fees\n    // depending on HA hedge (scaled by `BASE_PARAMS`)\n    uint64[] xFeeBurn;\n    // Values of the fees at thresholds (scaled by `BASE_PARAMS`)\n    uint64[] yFeeBurn;\n    // Max proportion of collateral from users that can be covered by HAs\n    // It is exactly the same as the parameter of the same name in `PerpetualManager`, whenever one is updated\n    // the other changes accordingly\n    uint64 targetHAHedge;\n    // Minting fees correction set by the `FeeManager` contract: they are going to be multiplied\n    // to the value of the fees computed using the hedge curve\n    // Scaled by `BASE_PARAMS`\n    uint64 bonusMalusMint;\n    // Burning fees correction set by the `FeeManager` contract: they are going to be multiplied\n    // to the value of the fees computed using the hedge curve\n    // Scaled by `BASE_PARAMS`\n    uint64 bonusMalusBurn;\n    // Parameter used to limit the number of stablecoins that can be issued using the concerned collateral\n    uint256 capOnStableMinted;\n}\n\n// Struct to handle all the variables and parameters to handle SLPs in the protocol\n// including the fraction of interests they receive or the fees to be distributed to\n// them\nstruct SLPData {\n    // Last timestamp at which the `sanRate` has been updated for SLPs\n    uint256 lastBlockUpdated;\n    // Fees accumulated from previous blocks and to be distributed to SLPs\n    uint256 lockedInterests;\n    // Max interests used to update the `sanRate` in a single block\n    // Should be in collateral token base\n    uint256 maxInterestsDistributed;\n    // Amount of fees left aside for SLPs and that will be distributed\n    // when the protocol is collateralized back again\n    uint256 feesAside;\n    // Part of the fees normally going to SLPs that is left aside\n    // before the protocol is collateralized back again (depends on collateral ratio)\n    // Updated by keepers and scaled by `BASE_PARAMS`\n    uint64 slippageFee;\n    // Portion of the fees from users minting and burning\n    // that goes to SLPs (the rest goes to surplus)\n    uint64 feesForSLPs;\n    // Slippage factor that's applied to SLPs exiting (depends on collateral ratio)\n    // If `slippage = BASE_PARAMS`, SLPs can get nothing, if `slippage = 0` they get their full claim\n    // Updated by keepers and scaled by `BASE_PARAMS`\n    uint64 slippage;\n    // Portion of the interests from lending\n    // that goes to SLPs (the rest goes to surplus)\n    uint64 interestsForSLPs;\n}\n\n/// @title IStableMaster\n/// @author Angle Labs, Inc.\ninterface IStableMaster {\n    function agToken() external view returns (address);\n\n    function updateStocksUsers(uint256 amount, address poolManager) external;\n\n    function collateralMap(\n        address poolManager\n    )\n        external\n        view\n        returns (\n            address token,\n            address sanToken,\n            IPerpetualManager perpetualManager,\n            IOracleCore oracle,\n            uint256 stocksUsers,\n            uint256 sanRate,\n            uint256 collatBase,\n            SLPData memory slpData,\n            MintBurnData memory feeData\n        );\n\n    function paused(bytes32) external view returns (bool);\n\n    function deposit(uint256 amount, address user, address poolManager) external;\n\n    function withdraw(uint256 amount, address burner, address dest, address poolManager) external;\n}\n"
    },
    "contracts/interfaces/external/create2/ImmutableCreate2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface ImmutableCreate2Factory {\n    function safeCreate2(bytes32 salt, bytes memory initCode) external payable returns (address deploymentAddress);\n\n    function findCreate2Address(\n        bytes32 salt,\n        bytes calldata initCode\n    ) external view returns (address deploymentAddress);\n\n    function findCreate2AddressViaHash(\n        bytes32 salt,\n        bytes32 initCodeHash\n    ) external view returns (address deploymentAddress);\n}\n"
    },
    "contracts/interfaces/external/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.12;\n\n/// @title Interface for verifying contract-based account signatures\n/// @notice Interface that verifies provided signature for the data\n/// @dev Interface defined by EIP-1271\ninterface IERC1271 {\n    /// @notice Returns whether the provided signature is valid for the provided data\n    /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\n    /// MUST allow external calls.\n    /// @param hash Hash of the data to be signed\n    /// @param signature Signature byte array associated with _data\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "contracts/interfaces/external/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice Minimal IERC4646 tokenized Vault interface.\n/// @author Forked from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @dev Do not use in production! ERC-4626 is still in the review stage and is subject to change.\ninterface IERC4626 {\n    event Deposit(address indexed from, address indexed to, uint256 amount, uint256 shares);\n    event Withdraw(address indexed from, address indexed to, uint256 amount, uint256 shares);\n\n    /// @notice Transfers a given amount of asset to the reactor and mint shares accordingly\n    /// @param amount Given amount of asset\n    /// @param to Address to mint shares to\n    /// @return shares Amount of shares minted to `to`\n    function deposit(uint256 amount, address to) external returns (uint256 shares);\n\n    /// @notice Mints a given amount of shares to the reactor and transfer assets accordingly\n    /// @param shares Given amount of shares\n    /// @param to Address to mint shares to\n    /// @return amount Amount of `asset` taken to the `msg.sender` to mint `shares`\n    function mint(uint256 shares, address to) external returns (uint256 amount);\n\n    /// @notice Transfers a given amount of asset from the reactor and burn shares accordingly\n    /// @param amount Given amount of asset\n    /// @param to Address to transfer assets to\n    /// @param from Address to burn shares from\n    /// @return shares Amount of shares burnt in the operation\n    function withdraw(uint256 amount, address to, address from) external returns (uint256 shares);\n\n    /// @notice Burns a given amount of shares to the reactor and transfer assets accordingly\n    /// @param shares Given amount of shares\n    /// @param to Address to transfer assets to\n    /// @param from Address to burn shares from\n    /// @return amount Amount of assets redeemed in the operation\n    function redeem(uint256 shares, address to, address from) external returns (uint256 amount);\n\n    /// @notice Returns the total assets managed by this reactor\n    function totalAssets() external view returns (uint256);\n\n    /// @notice Converts an amount of assets to the corresponding amount of reactor shares\n    /// @param assets Amount of asset to convert\n    /// @return Shares corresponding to the amount of assets obtained\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    /// @notice Converts an amount of shares to its current value in asset\n    /// @param shares Amount of shares to convert\n    /// @return Amount of assets corresponding to the amount of assets given\n    function convertToAssets(uint256 shares) external view returns (uint256);\n\n    /// @notice Computes how many shares one would get by depositing `assets`\n    /// @param assets Amount of asset to convert\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    /// @notice Computes how many assets one would need to mint `shares`\n    /// @param shares Amount of shares required\n    function previewMint(uint256 shares) external view returns (uint256);\n\n    /// @notice Computes how many shares one would need to withdraw assets\n    /// @param assets Amount of asset to withdraw\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    /// @notice Computes how many assets one would get by burning shares\n    /// @param shares Amount of shares to burn\n    function previewRedeem(uint256 shares) external view returns (uint256);\n\n    /// @notice Max deposit allowed for a user\n    /// @param user Address of the user to check\n    function maxDeposit(address user) external returns (uint256);\n\n    /// @notice Max mint allowed for a user\n    /// @param user Address of the user to check\n    function maxMint(address user) external returns (uint256);\n\n    /// @notice Max withdraw allowed for a user\n    /// @param user Address of the user to check\n    function maxWithdraw(address user) external returns (uint256);\n\n    /// @notice Max redeem allowed for a user\n    /// @param user Address of the user to check\n    function maxRedeem(address user) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Interface for WETH9\ninterface IWETH9 is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/interfaces/external/layerZero/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint256 _gasLimit,\n        bytes calldata _payload\n    ) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint256 _configType\n    ) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "contracts/interfaces/external/layerZero/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}\n"
    },
    "contracts/interfaces/external/layerZero/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint256 _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "contracts/interfaces/external/lido/IStETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title IStETH\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `StETH` contract\n/// @dev This interface only contains functions of the `StETH` which are called by other contracts\n/// of this module\ninterface IStETH {\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\n\n    event Submitted(address sender, uint256 amount, address referral);\n\n    function submit(address) external payable returns (uint256);\n\n    function getSharesByPooledEth(uint256 _ethAmount) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/lido/IWStETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title IWStETH\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `WStETH` contract\n/// @dev This interface only contains functions of the `WStETH` which are called by other contracts\n/// of this module\ninterface IWStETH {\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n\n    function stETH() external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/uniswap/IUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nstruct ExactInputParams {\n    bytes path;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n}\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface IUniswapV3Router {\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n}\n\n/// @title Router for price estimation functionality\n/// @notice Functions for getting the price of one token with respect to another using Uniswap V2\n/// @dev This interface is only used for non critical elements of the protocol\ninterface IUniswapV2Router {\n    /// @notice Given an input asset amount, returns the maximum output amount of the\n    /// other asset (accounting for fees) given reserves.\n    /// @param path Addresses of the pools used to get prices\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokens(\n        uint256 swapAmount,\n        uint256 minExpected,\n        address[] calldata path,\n        address receiver,\n        uint256 swapDeadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/external/uniswap/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3Pool {\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n}\n"
    },
    "contracts/interfaces/governance/IVeBoostProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title IVeBoostProxy\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `VeBoostProxy` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module\n/// @dev The `veBoostProxy` contract used by Angle is a full fork of Curve Finance implementation\ninterface IVeBoostProxy {\n    /// @notice Reads the adjusted veANGLE balance of an address (adjusted by delegation)\n    //solhint-disable-next-line\n    function adjusted_balance_of(address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAgToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @title IAgToken\n/// @author Angle Labs, Inc.\n/// @notice Interface for the stablecoins `AgToken` contracts\n/// @dev This interface only contains functions of the `AgToken` contract which are called by other contracts\n/// of this module or of the first module of the Angle Protocol\ninterface IAgToken is IERC20Upgradeable {\n    // ======================= Minter Role Only Functions ===========================\n\n    /// @notice Lets the `StableMaster` contract or another whitelisted contract mint agTokens\n    /// @param account Address to mint to\n    /// @param amount Amount to mint\n    /// @dev The contracts allowed to issue agTokens are the `StableMaster` contract, `VaultManager` contracts\n    /// associated to this stablecoin as well as the flash loan module (if activated) and potentially contracts\n    /// whitelisted by governance\n    function mint(address account, uint256 amount) external;\n\n    /// @notice Burns `amount` tokens from a `burner` address after being asked to by `sender`\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @param sender Address which requested the burn from `burner`\n    /// @dev This method is to be called by a contract with the minter right after being requested\n    /// to do so by a `sender` address willing to burn tokens from another `burner` address\n    /// @dev The method checks the allowance between the `sender` and the `burner`\n    function burnFrom(uint256 amount, address burner, address sender) external;\n\n    /// @notice Burns `amount` tokens from a `burner` address\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @dev This method is to be called by a contract with a minter right on the AgToken after being\n    /// requested to do so by an address willing to burn tokens from its address\n    function burnSelf(uint256 amount, address burner) external;\n\n    // ========================= Treasury Only Functions ===========================\n\n    /// @notice Adds a minter in the contract\n    /// @param minter Minter address to add\n    /// @dev Zero address checks are performed directly in the `Treasury` contract\n    function addMinter(address minter) external;\n\n    /// @notice Removes a minter from the contract\n    /// @param minter Minter address to remove\n    /// @dev This function can also be called by a minter wishing to revoke itself\n    function removeMinter(address minter) external;\n\n    /// @notice Sets a new treasury contract\n    /// @param _treasury New treasury address\n    function setTreasury(address _treasury) external;\n\n    // ========================= External functions ================================\n\n    /// @notice Checks whether an address has the right to mint agTokens\n    /// @param minter Address for which the minting right should be checked\n    /// @return Whether the address has the right to mint agTokens or not\n    function isMinter(address minter) external view returns (bool);\n\n    /// @notice Get the associated treasury\n    function treasury() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IAgTokenSideChainMultiBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @title IAgTokenSideChainMultiBridge\n/// @author Angle Labs, Inc.\n/// @notice Interface for the canonical `AgToken` contracts\n/// @dev This interface only contains functions useful for bridge tokens to interact with the canonical token\ninterface IAgTokenSideChainMultiBridge is IERC20PermitUpgradeable, IERC20Upgradeable {\n    /// @notice Mints the canonical token from a supported bridge token\n    /// @param bridgeToken Bridge token to use to mint\n    /// @param amount Amount of bridge tokens to send\n    /// @param to Address to which the stablecoin should be sent\n    /// @return Amount of the canonical stablecoin actually minted\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapIn(address bridgeToken, uint256 amount, address to) external returns (uint256);\n\n    /// @notice Burns the canonical token in exchange for a bridge token\n    /// @param bridgeToken Bridge token required\n    /// @param amount Amount of canonical tokens to burn\n    /// @param to Address to which the bridge token should be sent\n    /// @return Amount of bridge tokens actually sent back\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapOut(address bridgeToken, uint256 amount, address to) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAngleRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title IAngleRouter\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `AngleRouter` contract\n/// @dev This interface only contains functions of the `AngleRouter01` contract which are called by other contracts\n/// of this module\ninterface IAngleRouter {\n    function mint(\n        address user,\n        uint256 amount,\n        uint256 minStableAmount,\n        address stablecoin,\n        address collateral\n    ) external;\n\n    function burn(address user, uint256 amount, uint256 minAmountOut, address stablecoin, address collateral) external;\n\n    function mapPoolManagers(\n        address stableMaster,\n        address collateral\n    ) external view returns (address poolManager, address perpetualManager, address sanToken, address gauge);\n}\n"
    },
    "contracts/interfaces/IAngleRouterSidechain.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @notice Action types\nenum ActionType {\n    transfer,\n    wrap,\n    wrapNative,\n    sweep,\n    sweepNative,\n    unwrap,\n    unwrapNative,\n    swapIn,\n    swapOut,\n    uniswapV3,\n    oneInch,\n    claimRewards,\n    gaugeDeposit,\n    borrower\n}\n\n/// @notice Data needed to get permits\nstruct PermitType {\n    address token;\n    address owner;\n    uint256 value;\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\n/// @title IAngleRouterSidechain\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `AngleRouter` contract on other chains\ninterface IAngleRouterSidechain {\n    function mixer(PermitType[] memory paramsPermit, ActionType[] memory actions, bytes[] calldata data) external;\n}\n"
    },
    "contracts/interfaces/ICoreBorrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title ICoreBorrow\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `CoreBorrow` contract\n/// @dev This interface only contains functions of the `CoreBorrow` contract which are called by other contracts\n/// of this module\ninterface ICoreBorrow {\n    /// @notice Checks if an address corresponds to a treasury of a stablecoin with a flash loan\n    /// module initialized on it\n    /// @param treasury Address to check\n    /// @return Whether the address has the `FLASHLOANER_TREASURY_ROLE` or not\n    function isFlashLoanerTreasury(address treasury) external view returns (bool);\n\n    /// @notice Checks whether an address is governor of the Angle Protocol or not\n    /// @param admin Address to check\n    /// @return Whether the address has the `GOVERNOR_ROLE` or not\n    function isGovernor(address admin) external view returns (bool);\n\n    /// @notice Checks whether an address is governor or a guardian of the Angle Protocol or not\n    /// @param admin Address to check\n    /// @return Whether the address has the `GUARDIAN_ROLE` or not\n    /// @dev Governance should make sure when adding a governor to also give this governor the guardian\n    /// role by calling the `addGovernor` function\n    function isGovernorOrGuardian(address admin) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IFlashAngle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./IAgToken.sol\";\nimport \"./ICoreBorrow.sol\";\n\n/// @title IFlashAngle\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `FlashAngle` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module\ninterface IFlashAngle {\n    /// @notice Reference to the `CoreBorrow` contract managing the FlashLoan module\n    function core() external view returns (ICoreBorrow);\n\n    /// @notice Sends the fees taken from flash loans to the treasury contract associated to the stablecoin\n    /// @param stablecoin Stablecoin from which profits should be sent\n    /// @return balance Amount of profits sent\n    /// @dev This function can only be called by the treasury contract\n    function accrueInterestToTreasury(IAgToken stablecoin) external returns (uint256 balance);\n\n    /// @notice Adds support for a stablecoin\n    /// @param _treasury Treasury associated to the stablecoin to add support for\n    /// @dev This function can only be called by the `CoreBorrow` contract\n    function addStablecoinSupport(address _treasury) external;\n\n    /// @notice Removes support for a stablecoin\n    /// @param _treasury Treasury associated to the stablecoin to remove support for\n    /// @dev This function can only be called by the `CoreBorrow` contract\n    function removeStablecoinSupport(address _treasury) external;\n\n    /// @notice Sets a new core contract\n    /// @param _core Core contract address to set\n    /// @dev This function can only be called by the `CoreBorrow` contract\n    function setCore(address _core) external;\n}\n"
    },
    "contracts/interfaces/IKeeperRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @title IKeeperRegistry\n/// @author Angle Labs, Inc.\ninterface IKeeperRegistry {\n    /// @notice Checks whether an address is whitelisted during oracle updates\n    /// @param caller Address for which the whitelist should be checked\n    /// @return Whether the address is trusted or not\n    function isTrusted(address caller) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ILiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\ninterface ILiquidityGauge {\n    function deposit(\n        uint256 _value,\n        address _addr,\n        // solhint-disable-next-line\n        bool _claim_rewards\n    ) external;\n\n    function withdraw(\n        uint256 _value,\n        // solhint-disable-next-line\n        bool _claim_rewards\n    ) external;\n\n    // solhint-disable-next-line\n    function claim_rewards(address _addr, address _receiver) external;\n\n    // solhint-disable-next-line\n    function claimable_reward(address _addr, address _reward_token) external view returns (uint256 amount);\n\n    /// @dev Only for testing purposes\n    // solhint-disable-next-line\n    function deposit_reward_token(address _rewardToken, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./ITreasury.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/// @title IOracle\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `Oracle` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module\ninterface IOracle {\n    /// @notice Reads the rate from the Chainlink circuit and other data provided\n    /// @return quoteAmount The current rate between the in-currency and out-currency in the base\n    /// of the out currency\n    /// @dev For instance if the out currency is EUR (and hence agEUR), then the base of the returned\n    /// value is 10**18\n    function read() external view returns (uint256);\n\n    /// @notice Changes the treasury contract\n    /// @param _treasury Address of the new treasury contract\n    /// @dev This function can be called by an approved `VaultManager` contract which can call\n    /// this function after being requested to do so by a `treasury` contract\n    /// @dev In some situations (like reactor contracts), the `VaultManager` may not directly be linked\n    /// to the `oracle` contract and as such we may need governors to be able to call this function as well\n    function setTreasury(address _treasury) external;\n\n    /// @notice Reference to the `treasury` contract handling this `VaultManager`\n    function treasury() external view returns (ITreasury treasury);\n\n    /// @notice Array with the list of Chainlink feeds in the order in which they are read\n    function circuitChainlink() external view returns (AggregatorV3Interface[] memory);\n}\n"
    },
    "contracts/interfaces/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title ISwapper\n/// @author Angle Labs, Inc.\n/// @notice Interface for Swapper contracts\n/// @dev This interface defines the key functions `Swapper` contracts should have when interacting with\n/// Angle\ninterface ISwapper {\n    /// @notice Notifies a contract that an address should be given `outToken` from `inToken`\n    /// @param inToken Address of the token received\n    /// @param outToken Address of the token to obtain\n    /// @param outTokenRecipient Address to which the outToken should be sent\n    /// @param outTokenOwed Minimum amount of outToken the `outTokenRecipient` address should have at the end of the call\n    /// @param inTokenObtained Amount of collateral obtained by a related address prior\n    /// to the call to this function\n    /// @param data Extra data needed (to encode Uniswap swaps for instance)\n    function swap(\n        IERC20 inToken,\n        IERC20 outToken,\n        address outTokenRecipient,\n        uint256 outTokenOwed,\n        uint256 inTokenObtained,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./IAgToken.sol\";\nimport \"./ICoreBorrow.sol\";\nimport \"./IFlashAngle.sol\";\n\n/// @title ITreasury\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `Treasury` contract\n/// @dev This interface only contains functions of the `Treasury` which are called by other contracts\n/// of this module\ninterface ITreasury {\n    /// @notice Stablecoin handled by this `treasury` contract\n    function stablecoin() external view returns (IAgToken);\n\n    /// @notice Checks whether a given address has the  governor role\n    /// @param admin Address to check\n    /// @return Whether the address has the governor role\n    /// @dev Access control is only kept in the `CoreBorrow` contract\n    function isGovernor(address admin) external view returns (bool);\n\n    /// @notice Checks whether a given address has the guardian or the governor role\n    /// @param admin Address to check\n    /// @return Whether the address has the guardian or the governor role\n    /// @dev Access control is only kept in the `CoreBorrow` contract which means that this function\n    /// queries the `CoreBorrow` contract\n    function isGovernorOrGuardian(address admin) external view returns (bool);\n\n    /// @notice Checks whether a given address has well been initialized in this contract\n    /// as a `VaultManager`\n    /// @param _vaultManager Address to check\n    /// @return Whether the address has been initialized or not\n    function isVaultManager(address _vaultManager) external view returns (bool);\n\n    /// @notice Sets a new flash loan module for this stablecoin\n    /// @param _flashLoanModule Reference to the new flash loan module\n    /// @dev This function removes the minting right to the old flash loan module and grants\n    /// it to the new module\n    function setFlashLoanModule(address _flashLoanModule) external;\n\n    /// @notice Gets the vault manager list\n    function vaultManagerList(uint256 i) external returns (address);\n}\n"
    },
    "contracts/interfaces/IVaultManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ITreasury.sol\";\nimport \"./IOracle.sol\";\n\n// ========================= Key Structs and Enums =============================\n\n/// @notice Parameters associated to a given `VaultManager` contract: these all correspond\n/// to parameters which signification is detailed in the `VaultManagerStorage` file\nstruct VaultParameters {\n    uint256 debtCeiling;\n    uint64 collateralFactor;\n    uint64 targetHealthFactor;\n    uint64 interestRate;\n    uint64 liquidationSurcharge;\n    uint64 maxLiquidationDiscount;\n    bool whitelistingActivated;\n    uint256 baseBoost;\n}\n\n/// @notice Data stored to track someone's loan (or equivalently called position)\nstruct Vault {\n    // Amount of collateral deposited in the vault, in collateral decimals. For example, if the collateral\n    // is USDC with 6 decimals, then `collateralAmount` will be in base 10**6\n    uint256 collateralAmount;\n    // Normalized value of the debt (that is to say of the stablecoins borrowed). It is expressed\n    // in the base of Angle stablecoins (i.e. `BASE_TOKENS = 10**18`)\n    uint256 normalizedDebt;\n}\n\n/// @notice For a given `vaultID`, this encodes a liquidation opportunity that is to say details about the maximum\n/// amount that could be repaid by liquidating the position\n/// @dev All the values are null in the case of a vault which cannot be liquidated under these conditions\nstruct LiquidationOpportunity {\n    // Maximum stablecoin amount that can be repaid upon liquidating the vault\n    uint256 maxStablecoinAmountToRepay;\n    // Collateral amount given to the person in the case where the maximum amount to repay is given\n    uint256 maxCollateralAmountGiven;\n    // Threshold value of stablecoin amount to repay: it is ok for a liquidator to repay below threshold,\n    // but if this threshold is non null and the liquidator wants to repay more than threshold, it should repay\n    // the max stablecoin amount given in this vault\n    uint256 thresholdRepayAmount;\n    // Discount proposed to the liquidator on the collateral\n    uint256 discount;\n    // Amount of debt in the vault\n    uint256 currentDebt;\n}\n\n/// @notice Data stored during a liquidation process to keep in memory what's due to a liquidator and some\n/// essential data for vaults being liquidated\nstruct LiquidatorData {\n    // Current amount of stablecoins the liquidator should give to the contract\n    uint256 stablecoinAmountToReceive;\n    // Current amount of collateral the contract should give to the liquidator\n    uint256 collateralAmountToGive;\n    // Bad debt accrued across the liquidation process\n    uint256 badDebtFromLiquidation;\n    // Oracle value (in stablecoin base) at the time of the liquidation\n    uint256 oracleValue;\n    // Value of the `interestAccumulator` at the time of the call\n    uint256 newInterestAccumulator;\n}\n\n/// @notice Data to track during a series of action the amount to give or receive in stablecoins and collateral\n/// to the caller or associated addresses\nstruct PaymentData {\n    // Stablecoin amount the contract should give\n    uint256 stablecoinAmountToGive;\n    // Stablecoin amount owed to the contract\n    uint256 stablecoinAmountToReceive;\n    // Collateral amount the contract should give\n    uint256 collateralAmountToGive;\n    // Collateral amount owed to the contract\n    uint256 collateralAmountToReceive;\n}\n\n/// @notice Actions possible when composing calls to the different entry functions proposed\nenum ActionType {\n    createVault,\n    closeVault,\n    addCollateral,\n    removeCollateral,\n    repayDebt,\n    borrow,\n    getDebtIn,\n    permit\n}\n\n// ========================= Interfaces =============================\n\n/// @title IVaultManagerFunctions\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `VaultManager` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module (without getters)\ninterface IVaultManagerFunctions {\n    /// @notice Accrues interest accumulated across all vaults to the surplus and sends the surplus to the treasury\n    /// @return surplusValue Value of the surplus communicated to the `Treasury`\n    /// @return badDebtValue Value of the bad debt communicated to the `Treasury`\n    /// @dev `surplus` and `badDebt` should be reset to 0 once their current value have been given to the `treasury` contract\n    function accrueInterestToTreasury() external returns (uint256 surplusValue, uint256 badDebtValue);\n\n    /// @notice Removes debt from a vault after being requested to do so by another `VaultManager` contract\n    /// @param vaultID ID of the vault to remove debt from\n    /// @param amountStablecoins Amount of stablecoins to remove from the debt: this amount is to be converted to an\n    /// internal debt amount\n    /// @param senderBorrowFee Borrowing fees from the contract which requested this: this is to make sure that people are not\n    /// arbitraging difference in minting fees\n    /// @param senderRepayFee Repay fees from the contract which requested this: this is to make sure that people are not arbitraging\n    /// differences in repay fees\n    /// @dev This function can only be called from a vaultManager registered in the same Treasury\n    function getDebtOut(\n        uint256 vaultID,\n        uint256 amountStablecoins,\n        uint256 senderBorrowFee,\n        uint256 senderRepayFee\n    ) external;\n\n    /// @notice Gets the current debt of a vault\n    /// @param vaultID ID of the vault to check\n    /// @return Debt of the vault\n    function getVaultDebt(uint256 vaultID) external view returns (uint256);\n\n    /// @notice Gets the total debt across all vaults\n    /// @return Total debt across all vaults, taking into account the interest accumulated\n    /// over time\n    function getTotalDebt() external view returns (uint256);\n\n    /// @notice Sets the treasury contract\n    /// @param _treasury New treasury contract\n    /// @dev All required checks when setting up a treasury contract are performed in the contract\n    /// calling this function\n    function setTreasury(address _treasury) external;\n\n    /// @notice Creates a vault\n    /// @param toVault Address for which the va\n    /// @return vaultID ID of the vault created\n    /// @dev This function just creates the vault without doing any collateral or\n    function createVault(address toVault) external returns (uint256);\n\n    /// @notice Allows composability between calls to the different entry points of this module. Any user calling\n    /// this function can perform any of the allowed actions in the order of their choice\n    /// @param actions Set of actions to perform\n    /// @param datas Data to be decoded for each action: it can include like the `vaultID` or the `stablecoinAmount` to borrow\n    /// @param from Address from which stablecoins will be taken if one action includes burning stablecoins. This address\n    /// should either be the `msg.sender` or be approved by the latter\n    /// @param to Address to which stablecoins and/or collateral will be sent in case of\n    /// @param who Address of the contract to handle in case of repayment of stablecoins from received collateral\n    /// @param repayData Data to pass to the repayment contract in case of\n    /// @return paymentData Struct containing the accounting changes from the protocol's perspective (like how much of collateral\n    /// or how much has been received). Note that the values in the struct are not aggregated and you could have in the output\n    /// a positive amount of stablecoins to receive as well as a positive amount of stablecoins to give\n    /// @dev This function is optimized to reduce gas cost due to payment from or to the user and that expensive calls\n    /// or computations (like `oracleValue`) are done only once\n    /// @dev When specifying `vaultID` in `data`, it is important to know that if you specify `vaultID = 0`, it will simply\n    /// use the latest `vaultID`. This is the default behavior, and unless you're engaging into some complex protocol actions\n    /// it is encouraged to use `vaultID = 0` only when the first action of the batch is `createVault`\n    function angle(\n        ActionType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to,\n        address who,\n        bytes memory repayData\n    ) external returns (PaymentData memory paymentData);\n\n    /// @notice This function is a wrapper built on top of the function above. It enables users to interact with the contract\n    /// without having to provide `who` and `repayData` parameters\n    function angle(\n        ActionType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to\n    ) external returns (PaymentData memory paymentData);\n\n    /// @notice Initializes the `VaultManager` contract\n    /// @param _treasury Treasury address handling the contract\n    /// @param _collateral Collateral supported by this contract\n    /// @param _oracle Oracle contract used\n    /// @param _symbol Symbol used to define the `VaultManager` name and symbol\n    /// @dev The parameters and the oracle are the only elements which could be modified once the\n    /// contract has been initialized\n    /// @dev For the contract to be fully initialized, governance needs to set the parameters for the liquidation\n    /// boost\n    function initialize(\n        ITreasury _treasury,\n        IERC20 _collateral,\n        IOracle _oracle,\n        VaultParameters calldata params,\n        string memory _symbol\n    ) external;\n\n    /// @notice Minimum amount of debt a vault can have, expressed in `BASE_TOKENS` that is to say the base of the agTokens\n    function dust() external view returns (uint256);\n\n    /// @notice Pauses external permissionless functions of the contract\n    function togglePause() external;\n}\n\n/// @title IVaultManagerStorage\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `VaultManager` contract\n/// @dev This interface contains getters of the contract's public variables used by other contracts\n/// of this module\ninterface IVaultManagerStorage {\n    /// @notice Encodes the maximum ratio stablecoin/collateral a vault can have before being liquidated. It's what\n    /// determines the minimum collateral ratio of a position\n    function collateralFactor() external view returns (uint64);\n\n    /// @notice Stablecoin handled by this contract. Another `VaultManager` contract could have\n    /// the same rights as this `VaultManager` on the stablecoin contract\n    function stablecoin() external view returns (IAgToken);\n\n    /// @notice Reference to the `treasury` contract handling this `VaultManager`\n    function treasury() external view returns (ITreasury);\n\n    /// @notice Oracle contract to get access to the price of the collateral with respect to the stablecoin\n    function oracle() external view returns (IOracle);\n\n    /// @notice The `interestAccumulator` variable keeps track of the interest that should accrue to the protocol.\n    /// The stored value is not necessarily the true value: this one is recomputed every time an action takes place\n    /// within the protocol. It is in base `BASE_INTEREST`\n    function interestAccumulator() external view returns (uint256);\n\n    /// @notice Reference to the collateral handled by this `VaultManager`\n    function collateral() external view returns (IERC20);\n\n    /// @notice Total normalized amount of stablecoins borrowed, not taking into account the potential bad debt accumulated\n    /// This value is expressed in the base of Angle stablecoins (`BASE_TOKENS = 10**18`)\n    function totalNormalizedDebt() external view returns (uint256);\n\n    /// @notice Maximum amount of stablecoins that can be issued with this contract. It is expressed in `BASE_TOKENS`\n    function debtCeiling() external view returns (uint256);\n\n    /// @notice Maps a `vaultID` to its data (namely collateral amount and normalized debt)\n    function vaultData(uint256 vaultID) external view returns (uint256 collateralAmount, uint256 normalizedDebt);\n\n    /// @notice ID of the last vault created. The `vaultIDCount` variables serves as a counter to generate a unique\n    /// `vaultID` for each vault: it is like `tokenID` in basic ERC721 contracts\n    function vaultIDCount() external view returns (uint256);\n}\n\n/// @title IVaultManager\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `VaultManager` contract\ninterface IVaultManager is IVaultManagerFunctions, IVaultManagerStorage, IERC721Metadata {\n    function isApprovedOrOwner(address spender, uint256 vaultID) external view returns (bool);\n}\n\n/// @title IVaultManagerListing\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `VaultManagerListing` contract\ninterface IVaultManagerListing is IVaultManager {\n    /// @notice Get the collateral owned by `user` in the contract\n    /// @dev This function effectively sums the collateral amounts of all the vaults owned by `user`\n    function getUserCollateral(address user) external view returns (uint256);\n}\n"
    },
    "contracts/keeperMulticall/KeeperMulticall.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./RevertReasonParser.sol\";\n\n/// @title KeeperMulticall\n/// @notice Allows an authorized caller (keeper) to execute multiple actions in a single tx.\n/// @author Angle Labs, Inc.\n/// @dev Special features:\n///         - ability to pay the miner (for private Flashbots transactions)\n///         - swap tokens through 1inch\n/// @dev Tx need to be encoded as an array of Action. The flag `isDelegateCall` is used for calling functions within this same contract\ncontract KeeperMulticall is Initializable, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    //solhint-disable-next-line\n    address private constant _oneInch = 0x1111111254fb6c44bAC0beD2854e76F90643097d;\n\n    struct Action {\n        address target;\n        bytes data;\n        bool isDelegateCall;\n    }\n\n    event LogAction(address indexed target, bytes data);\n    event SentToMiner(uint256 indexed value);\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n\n    error AmountOutTooLow(uint256 amount, uint256 min);\n    error BalanceTooLow();\n    error FlashbotsErrorPayingMiner(uint256 value);\n    error IncompatibleLengths();\n    error RevertBytes();\n    error WrongAmount();\n    error ZeroAddress();\n\n    constructor() initializer {}\n\n    function initialize(address keeper) external initializer {\n        __AccessControl_init();\n\n        _setupRole(KEEPER_ROLE, keeper);\n        _setRoleAdmin(KEEPER_ROLE, KEEPER_ROLE);\n    }\n\n    /// @notice Allows an authorized keeper to execute multiple actions in a single step\n    /// @param actions Actions to be executed\n    /// @param percentageToMiner Percentage to pay to miner expressed in bps (10000)\n    /// @dev This is the main entry point for actions to be executed. The `isDelegateCall` flag is used for calling function inside this `KeeperMulticall` contract,\n    /// if we call other contracts, the flag should be false\n    function executeActions(\n        Action[] memory actions,\n        uint256 percentageToMiner\n    ) external payable onlyRole(KEEPER_ROLE) returns (bytes[] memory) {\n        uint256 numberOfActions = actions.length;\n        if (numberOfActions == 0) revert IncompatibleLengths();\n\n        bytes[] memory returnValues = new bytes[](numberOfActions + 1);\n\n        uint256 balanceBefore = address(this).balance;\n\n        for (uint256 i; i < numberOfActions; ++i) {\n            returnValues[i] = _executeAction(actions[i]);\n        }\n\n        if (percentageToMiner != 0) {\n            if (percentageToMiner >= 10000) revert WrongAmount();\n            uint256 balanceAfter = address(this).balance;\n            if (balanceAfter > balanceBefore) {\n                uint256 amountToMiner = ((balanceAfter - balanceBefore) * percentageToMiner) / 10000;\n                returnValues[numberOfActions] = payFlashbots(amountToMiner);\n            }\n        }\n\n        return returnValues;\n    }\n\n    /// @notice Gets the action address and data and executes it\n    /// @param action Action to be executed\n    function _executeAction(Action memory action) internal returns (bytes memory) {\n        bool success;\n        bytes memory response;\n\n        if (action.isDelegateCall) {\n            //solhint-disable-next-line\n            (success, response) = action.target.delegatecall(action.data);\n        } else {\n            //solhint-disable-next-line\n            (success, response) = action.target.call(action.data);\n        }\n\n        require(success, RevertReasonParser.parse(response, \"action reverted: \"));\n        emit LogAction(action.target, action.data);\n        return response;\n    }\n\n    /// @notice Ability to pay miner directly. Used for Flashbots to execute private transactions\n    /// @param value Value to be sent\n    function payFlashbots(uint256 value) public payable onlyRole(KEEPER_ROLE) returns (bytes memory) {\n        //solhint-disable-next-line\n        (bool success, bytes memory response) = block.coinbase.call{ value: value }(\"\");\n        if (!success) revert FlashbotsErrorPayingMiner(value);\n        emit SentToMiner(value);\n        return response;\n    }\n\n    /// @notice Used to check the balances the token holds for each token. If we don't have enough of a token, we revert the tx\n    /// @param tokens Array of tokens to check\n    /// @param minBalances Array of balances for each token\n    function finalBalanceCheck(IERC20[] memory tokens, uint256[] memory minBalances) external view returns (bool) {\n        uint256 tokensLength = tokens.length;\n        if (tokensLength == 0 || tokensLength != minBalances.length) revert IncompatibleLengths();\n\n        for (uint256 i; i < tokensLength; ++i) {\n            if (address(tokens[i]) == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n                if (address(this).balance < minBalances[i]) revert BalanceTooLow();\n            } else {\n                if (tokens[i].balanceOf(address(this)) < minBalances[i]) revert BalanceTooLow();\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice Swap token to another through 1Inch\n    /// @param minAmountOut Minimum amount of `out` token to receive for the swap to happen\n    /// @param payload Bytes needed for 1Inch API\n    function swapToken(uint256 minAmountOut, bytes memory payload) external onlyRole(KEEPER_ROLE) {\n        //solhint-disable-next-line\n        (bool success, bytes memory result) = _oneInch.call(payload);\n        if (!success) _revertBytes(result);\n\n        uint256 amountOut = abi.decode(result, (uint256));\n        if (amountOut < minAmountOut) revert AmountOutTooLow(amountOut, minAmountOut);\n    }\n\n    /// @notice Copied from 1Inch contract, used to revert if there is an error\n    function _revertBytes(bytes memory errMsg) internal pure {\n        if (errMsg.length != 0) {\n            //solhint-disable-next-line\n            assembly {\n                revert(add(32, errMsg), mload(errMsg))\n            }\n        }\n        revert RevertBytes();\n    }\n\n    /// @notice Approve a `spender` for `token`\n    /// @param token Address of the token to approve\n    /// @param spender Address of the spender to approve\n    /// @param amount Amount to approve\n    function approve(IERC20 token, address spender, uint256 amount) external onlyRole(KEEPER_ROLE) {\n        uint256 currentAllowance = token.allowance(address(this), spender);\n        if (currentAllowance < amount) {\n            token.safeIncreaseAllowance(spender, amount - currentAllowance);\n        } else if (currentAllowance > amount) {\n            token.safeDecreaseAllowance(spender, currentAllowance - amount);\n        }\n    }\n\n    receive() external payable {}\n\n    /// @notice Withdraw stuck funds\n    /// @param token Address of the token to recover\n    /// @param receiver Address where to send the tokens\n    /// @param amount Amount to recover\n    function withdrawStuckFunds(address token, address receiver, uint256 amount) external onlyRole(KEEPER_ROLE) {\n        if (receiver == address(0)) revert ZeroAddress();\n        if (token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            payable(receiver).transfer(amount);\n        } else {\n            IERC20(token).safeTransfer(receiver, amount);\n        }\n\n        emit Recovered(token, receiver, amount);\n    }\n}\n"
    },
    "contracts/keeperMulticall/MulticallWithFailure.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/// @title MultiCallWithFailure\n/// @author Angle Labs, Inc.\n/// @notice Multicall contract allowing subcalls to fail without reverting the entire call\ncontract MultiCallWithFailure {\n    error SubcallFailed();\n\n    struct Call {\n        address target;\n        bytes data;\n        bool canFail;\n    }\n\n    function multiCall(Call[] memory calls) external view returns (bytes[] memory) {\n        bytes[] memory results = new bytes[](calls.length);\n\n        for (uint256 i; i < calls.length; ++i) {\n            (bool success, bytes memory result) = calls[i].target.staticcall(calls[i].data);\n            if (!calls[i].canFail) {\n                if (!success) {\n                    revert SubcallFailed();\n                }\n            }\n            results[i] = result;\n        }\n\n        return results;\n    }\n}\n"
    },
    "contracts/keeperMulticall/RevertReasonParser.sol": {
      "content": "// SPDX-License-Identifier: GNU-3\n\npragma solidity ^0.8.12;\n\n/// @title RevertReasonParser\n/// @author 1Inch team, taken from:\n///     - https://docs.1inch.io/docs/limit-order-protocol/smart-contract/libraries/RevertReasonParser/\n///     - https://etherscan.io/address/0x1111111254fb6c44bAC0beD2854e76F90643097d#code\nlibrary RevertReasonParser {\n    bytes4 private constant _PANIC_SELECTOR = bytes4(keccak256(\"Panic(uint256)\"));\n    bytes4 private constant _ERROR_SELECTOR = bytes4(keccak256(\"Error(string)\"));\n\n    function parse(bytes memory data, string memory prefix) internal pure returns (string memory) {\n        if (data.length >= 4) {\n            bytes4 selector;\n            //solhint-disable-next-line\n            assembly {\n                selector := mload(add(data, 0x20))\n            }\n\n            // 68 = 4-byte selector + 32 bytes offset + 32 bytes length\n            if (selector == _ERROR_SELECTOR && data.length >= 68) {\n                uint256 offset;\n                bytes memory reason;\n                // solhint-disable no-inline-assembly\n                assembly {\n                    // 36 = 32 bytes data length + 4-byte selector\n                    offset := mload(add(data, 36))\n                    reason := add(data, add(36, offset))\n                }\n                /*\n                    revert reason is padded up to 32 bytes with ABI encoder: Error(string)\n                    also sometimes there is extra 32 bytes of zeros padded in the end:\n                    https://github.com/ethereum/solidity/issues/10170\n                    because of that we can't check for equality and instead check\n                    that offset + string length + extra 36 bytes is less than overall data length\n                */\n                require(data.length >= 36 + offset + reason.length, \"Invalid revert reason\");\n                return string(abi.encodePacked(prefix, \"Error(\", reason, \")\"));\n            }\n            // 36 = 4-byte selector + 32 bytes integer\n            else if (selector == _PANIC_SELECTOR && data.length == 36) {\n                uint256 code;\n                // solhint-disable no-inline-assembly\n                assembly {\n                    // 36 = 32 bytes data length + 4-byte selector\n                    code := mload(add(data, 36))\n                }\n                return string(abi.encodePacked(prefix, \"Panic(\", _toHex(code), \")\"));\n            }\n        }\n\n        return string(abi.encodePacked(prefix, \"Unknown(\", _toHex(data), \")\"));\n    }\n\n    function _toHex(uint256 value) private pure returns (string memory) {\n        return _toHex(abi.encodePacked(value));\n    }\n\n    function _toHex(bytes memory data) private pure returns (string memory) {\n        bytes16 alphabet = 0x30313233343536373839616263646566;\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i; i < data.length; ++i) {\n            str[2 * i + 2] = alphabet[uint8(data[i] >> 4)];\n            str[2 * i + 3] = alphabet[uint8(data[i] & 0x0f)];\n        }\n        return string(str);\n    }\n}\n"
    },
    "contracts/mock/Mock1Inch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract Mock1Inch {\n    using SafeERC20 for IERC20;\n\n    function swap(address tokenIn, uint256 amountIn, address to, address tokenOut, uint256 amountOut) external {\n        IERC20(tokenIn).safeTransferFrom(msg.sender, to, amountIn);\n        if (tokenOut == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            //solhint-disable-next-line\n            (bool sent, bytes memory data) = msg.sender.call{ value: amountOut }(\"\");\n            data;\n            require(sent, \"Failed to send Ether\");\n        } else {\n            IERC20(tokenOut).safeTransferFrom(to, msg.sender, amountOut);\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/mock/MockAnything.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\ncontract MockAnything {\n    uint256 public stateVar = 1;\n\n    error CustomError();\n    error CustomErrorWithValue(uint256);\n\n    function fail(uint256 value) external view returns (uint256) {\n        stateVar;\n        if (value < 10) {\n            revert CustomError();\n        }\n        if (value < 20) {\n            revert CustomErrorWithValue(value);\n        }\n        return value + 1;\n    }\n\n    function modifyState(uint256 value) external {\n        stateVar = value;\n    }\n}\n"
    },
    "contracts/mock/MockChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\ninterface MockAggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n\ncontract MockChainlinkOracle is MockAggregatorV3Interface {\n    uint80 public roundId = 0;\n    uint8 public keyDecimals = 0;\n\n    struct Entry {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n    }\n\n    mapping(uint256 => Entry) public entries;\n\n    bool public latestRoundDataShouldRevert;\n\n    string public desc;\n\n    constructor() {}\n\n    // Mock setup function\n    function setLatestAnswer(int256 answer, uint256 timestamp) external {\n        roundId++;\n        entries[roundId] = Entry({\n            roundId: roundId,\n            answer: answer,\n            startedAt: timestamp,\n            updatedAt: timestamp,\n            answeredInRound: roundId\n        });\n    }\n\n    function setLatestAnswerWithRound(int256 answer, uint256 timestamp, uint80 _roundId) external {\n        roundId = _roundId;\n        entries[roundId] = Entry({\n            roundId: roundId,\n            answer: answer,\n            startedAt: timestamp,\n            updatedAt: timestamp,\n            answeredInRound: roundId\n        });\n    }\n\n    function setLatestAnswerRevert(int256 answer, uint256 timestamp) external {\n        roundId++;\n        entries[roundId] = Entry({\n            roundId: roundId,\n            answer: answer,\n            startedAt: timestamp,\n            updatedAt: timestamp,\n            answeredInRound: roundId - 1\n        });\n    }\n\n    function setLatestRoundDataShouldRevert(bool _shouldRevert) external {\n        latestRoundDataShouldRevert = _shouldRevert;\n    }\n\n    function setDecimals(uint8 _decimals) external {\n        keyDecimals = _decimals;\n    }\n\n    function setDescritpion(string memory _desc) external {\n        desc = _desc;\n    }\n\n    function description() external view override returns (string memory) {\n        return desc;\n    }\n\n    function version() external view override returns (uint256) {\n        roundId;\n        return 0;\n    }\n\n    function latestRoundData() external view override returns (uint80, int256, uint256, uint256, uint80) {\n        if (latestRoundDataShouldRevert) {\n            revert(\"latestRoundData reverted\");\n        }\n        return getRoundData(uint80(roundId));\n    }\n\n    function decimals() external view override returns (uint8) {\n        return keyDecimals;\n    }\n\n    function getRoundData(uint80 _roundId) public view override returns (uint80, int256, uint256, uint256, uint80) {\n        Entry memory entry = entries[_roundId];\n        // Emulate a Chainlink aggregator\n        require(entry.updatedAt > 0, \"No data present\");\n        return (entry.roundId, entry.answer, entry.startedAt, entry.updatedAt, entry.answeredInRound);\n    }\n}\n"
    },
    "contracts/mock/MockCoreBorrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\ncontract MockCoreBorrow is ICoreBorrow {\n    mapping(address => bool) public flashLoaners;\n    mapping(address => bool) public governors;\n    mapping(address => bool) public guardians;\n\n    function isFlashLoanerTreasury(address treasury) external view override returns (bool) {\n        return flashLoaners[treasury];\n    }\n\n    function isGovernor(address admin) external view override returns (bool) {\n        return governors[admin];\n    }\n\n    function isGovernorOrGuardian(address admin) external view override returns (bool) {\n        return governors[admin] || guardians[admin];\n    }\n\n    function toggleGovernor(address admin) external {\n        governors[admin] = !governors[admin];\n    }\n\n    function toggleGuardian(address admin) external {\n        guardians[admin] = !guardians[admin];\n    }\n\n    function toggleFlashLoaners(address admin) external {\n        flashLoaners[admin] = !flashLoaners[admin];\n    }\n\n    function addStablecoinSupport(IFlashAngle flashAngle, address _treasury) external {\n        flashAngle.addStablecoinSupport(_treasury);\n    }\n\n    function removeStablecoinSupport(IFlashAngle flashAngle, address _treasury) external {\n        flashAngle.removeStablecoinSupport(_treasury);\n    }\n\n    function setCore(IFlashAngle flashAngle, address _core) external {\n        flashAngle.setCore(_core);\n    }\n\n    function setFlashLoanModule(ITreasury _treasury, address _flashLoanModule) external {\n        _treasury.setFlashLoanModule(_flashLoanModule);\n    }\n}\n"
    },
    "contracts/mock/MockERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"../interfaces/external/IERC1271.sol\";\n\ncontract MockERC1271 is IERC1271 {\n    uint256 public mode = 0;\n\n    function setMode(uint256 _mode) public {\n        mode = _mode;\n    }\n\n    /// @notice Returns whether the provided signature is valid for the provided data\n    /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\n    /// MUST allow external calls.\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\n    function isValidSignature(bytes32, bytes memory) external view returns (bytes4 magicValue) {\n        if (mode == 1) magicValue = 0x1626ba7e;\n    }\n}\n"
    },
    "contracts/mock/MockERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract MockERC721Receiver {\n    uint256 public mode = 0;\n\n    function setMode(uint256 _mode) public {\n        mode = _mode;\n    }\n\n    function onERC721Received(address, address, uint256, bytes memory) public view returns (bytes4) {\n        require(mode != 1, \"0x1111111\");\n        if (mode == 2) return this.setMode.selector;\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/mock/MockEulerPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockEulerPool {\n    IERC20 public collateral;\n    uint256 public poolSize;\n    //solhint-disable-next-line\n    uint256 public MAX_SANE_AMOUNT;\n\n    mapping(address => uint256) public users;\n    uint256 public interestRateAccumulator;\n\n    constructor(IERC20 collateral_, uint256 poolSize_) {\n        collateral = collateral_;\n        poolSize = poolSize_;\n        interestRateAccumulator = 10 ** 18;\n        MAX_SANE_AMOUNT = type(uint112).max;\n    }\n\n    function setPoolSize(uint256 poolSize_) external {\n        uint256 balance = collateral.balanceOf(address(this));\n        poolSize = poolSize_;\n        if (balance > poolSize_) collateral.transfer(msg.sender, balance - poolSize_);\n        if (balance < poolSize_) collateral.transferFrom(msg.sender, address(this), poolSize_ - balance);\n    }\n\n    function setInterestRateAccumulator(uint256 interestRateAccumulator_) external {\n        interestRateAccumulator = interestRateAccumulator_;\n    }\n\n    //solhint-disable-next-line\n    function setMAXSANEAMOUNT(uint256 MAX_SANE_AMOUNT_) external {\n        MAX_SANE_AMOUNT = MAX_SANE_AMOUNT_;\n    }\n\n    function balanceOfUnderlying(address account) external view returns (uint256) {\n        return (users[account] * interestRateAccumulator) / 10 ** 18;\n    }\n\n    function deposit(uint256, uint256 amount) external {\n        users[msg.sender] += (amount * 10 ** 18) / interestRateAccumulator;\n        poolSize += amount;\n        collateral.transferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256, uint256 amount) external {\n        if (amount == type(uint256).max) amount = (users[msg.sender] * interestRateAccumulator) / 10 ** 18;\n\n        require(amount <= poolSize, \"4\");\n        users[msg.sender] -= (amount * 10 ** 18) / interestRateAccumulator;\n        collateral.transfer(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/mock/MockFlashLoanModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ICoreBorrow.sol\";\n\ncontract MockFlashLoanModule is IFlashAngle {\n    ICoreBorrow public override core;\n    mapping(address => bool) public stablecoinsSupported;\n    mapping(IAgToken => uint256) public interestAccrued;\n    uint256 public surplusValue;\n\n    constructor(ICoreBorrow _core) {\n        core = _core;\n    }\n\n    function accrueInterestToTreasury(IAgToken stablecoin) external override returns (uint256 balance) {\n        balance = surplusValue;\n        interestAccrued[stablecoin] += balance;\n    }\n\n    function addStablecoinSupport(address _treasury) external override {\n        stablecoinsSupported[_treasury] = true;\n    }\n\n    function removeStablecoinSupport(address _treasury) external override {\n        stablecoinsSupported[_treasury] = false;\n    }\n\n    function setCore(address _core) external override {\n        core = ICoreBorrow(_core);\n    }\n\n    function setSurplusValue(uint256 _surplusValue) external {\n        surplusValue = _surplusValue;\n    }\n}\n"
    },
    "contracts/mock/MockFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\n\ncontract MockFlashLoanReceiver is IERC3156FlashBorrower {\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    constructor() {}\n\n    function onFlashLoan(\n        address,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external override returns (bytes32) {\n        IERC20(token).approve(msg.sender, amount + fee);\n        if (amount >= 10 ** 21) return keccak256(\"error\");\n        if (amount == 2 * 10 ** 18) {\n            IERC3156FlashLender(msg.sender).flashLoan(IERC3156FlashBorrower(address(this)), token, amount, data);\n            return keccak256(\"reentrant\");\n        } else return CALLBACK_SUCCESS;\n    }\n}\n"
    },
    "contracts/mock/MockInterestRateComputer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ncontract MockInterestRateComputer {\n    uint256 public interestRate;\n    uint256 public interestAccumulator;\n    uint256 public immutable baseInterest;\n    uint256 public immutable halfBase;\n\n    uint256 public constant WEEK = 7 * 86400;\n\n    constructor(uint256 _baseInterest, uint256 _interestRate) {\n        interestAccumulator = _baseInterest;\n        baseInterest = _baseInterest;\n        halfBase = _baseInterest / 2;\n        interestRate = _interestRate;\n    }\n\n    function _calculateAngle(uint256 exp, uint256 _interestAccumulator) internal view returns (uint256) {\n        uint256 ratePerSecond = interestRate;\n        if (exp == 0 || ratePerSecond == 0) return _interestAccumulator;\n        uint256 expMinusOne = exp - 1;\n        uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\n        uint256 basePowerTwo = (ratePerSecond * ratePerSecond) / baseInterest;\n        uint256 basePowerThree = (basePowerTwo * ratePerSecond) / baseInterest;\n        uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\n        uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\n        return (_interestAccumulator * (baseInterest + ratePerSecond * exp + secondTerm + thirdTerm)) / baseInterest;\n    }\n\n    function _calculateAave(uint256 exp, uint256 _interestAccumulator) internal view returns (uint256) {\n        uint256 ratePerSecond = interestRate;\n        if (exp == 0 || ratePerSecond == 0) return _interestAccumulator;\n        uint256 expMinusOne = exp - 1;\n        uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\n        uint256 basePowerTwo = (ratePerSecond * ratePerSecond + halfBase) / baseInterest;\n        uint256 basePowerThree = (basePowerTwo * ratePerSecond + halfBase) / baseInterest;\n        uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\n        uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\n        return (_interestAccumulator * (baseInterest + ratePerSecond * exp + secondTerm + thirdTerm)) / baseInterest;\n    }\n\n    function _calculateCompound(uint256 exp, uint256 _interestAccumulator) internal view returns (uint256) {\n        return _interestAccumulator * (baseInterest + interestRate * exp);\n    }\n\n    function _rpow(uint256 x, uint256 n, uint256 base) internal pure returns (uint256 z) {\n        //solhint-disable-next-line\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := x\n                }\n                let half := div(base, 2) // for rounding.\n                for {\n                    n := div(n, 2)\n                } n {\n                    n := div(n, 2)\n                } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) {\n                        revert(0, 0)\n                    }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n                    x := div(xxRound, base)\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                            revert(0, 0)\n                        }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n\n    function _calculateMaker(uint256 delta, uint256 _interestAccumulator) internal view returns (uint256) {\n        return (_rpow(baseInterest + interestRate, delta, baseInterest) * _interestAccumulator) / baseInterest;\n    }\n\n    function calculateAngle(uint256 delta) external view returns (uint256) {\n        return _calculateAngle(delta, interestAccumulator);\n    }\n\n    function calculateAave(uint256 delta) external view returns (uint256) {\n        return _calculateAave(delta, interestAccumulator);\n    }\n\n    function calculateMaker(uint256 delta) external view returns (uint256) {\n        return _calculateMaker(delta, interestAccumulator);\n    }\n\n    function calculateAngle1Year() external view returns (uint256) {\n        uint256 _interestAccumulator = interestAccumulator;\n        for (uint256 i; i < 52; ++i) {\n            _interestAccumulator = _calculateAngle(WEEK, _interestAccumulator);\n        }\n        return _interestAccumulator;\n    }\n\n    function calculateAave1Year() external view returns (uint256) {\n        uint256 _interestAccumulator = interestAccumulator;\n        for (uint256 i; i < 52; ++i) {\n            _interestAccumulator = _calculateAave(WEEK, _interestAccumulator);\n        }\n        return _interestAccumulator;\n    }\n\n    function calculateMaker1Year() external view returns (uint256) {\n        uint256 _interestAccumulator = interestAccumulator;\n        for (uint256 i; i < 52; ++i) {\n            _interestAccumulator = _calculateMaker(WEEK, _interestAccumulator);\n        }\n        return _interestAccumulator;\n    }\n\n    function calculateAngle1YearDirect() external view returns (uint256) {\n        uint256 _interestAccumulator = interestAccumulator;\n        _interestAccumulator = _calculateAngle(52 * WEEK, _interestAccumulator);\n\n        return _interestAccumulator;\n    }\n\n    function calculateAave1YearDirect() external view returns (uint256) {\n        uint256 _interestAccumulator = interestAccumulator;\n        _interestAccumulator = _calculateAave(52 * WEEK, _interestAccumulator);\n\n        return _interestAccumulator;\n    }\n\n    function calculateMaker1YearDirect() external view returns (uint256) {\n        uint256 _interestAccumulator = interestAccumulator;\n        _interestAccumulator = _calculateMaker(52 * WEEK, _interestAccumulator);\n\n        return _interestAccumulator;\n    }\n\n    function calculateCompound1YearDirect() external view returns (uint256) {\n        uint256 _interestAccumulator = interestAccumulator;\n        _interestAccumulator = _calculateCompound(52 * WEEK, _interestAccumulator);\n\n        return _interestAccumulator;\n    }\n}\n"
    },
    "contracts/mock/MockKeeperMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract MockKeeperMulticall is Initializable, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    //solhint-disable-next-line\n    address private constant _oneInch = 0x1111111254fb6c44bAC0beD2854e76F90643097d;\n\n    struct Action {\n        address target;\n        bytes data;\n        bool isDelegateCall;\n    }\n\n    event LogAction(address indexed target, bytes data);\n    event SentToMiner(uint256 indexed value);\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n\n    error AmountOutTooLow(uint256 amount, uint256 min);\n    error BalanceTooLow();\n    error FlashbotsErrorPayingMiner(uint256 value);\n    error IncompatibleLengths();\n    error RevertBytes();\n    error ZeroAddress();\n\n    constructor() initializer {}\n\n    function initialize(address keeper) public initializer {\n        __AccessControl_init();\n\n        _setupRole(KEEPER_ROLE, keeper);\n        _setRoleAdmin(KEEPER_ROLE, KEEPER_ROLE);\n    }\n}\n\ncontract MockKeeperMulticall2 {\n    uint256 public varTest = 1;\n\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    //solhint-disable-next-line\n    address private constant _oneInch = 0x1111111254fb6c44bAC0beD2854e76F90643097d;\n\n    struct Action {\n        address target;\n        bytes data;\n        bool isDelegateCall;\n    }\n\n    event LogAction(address indexed target, bytes data);\n    event SentToMiner(uint256 indexed value);\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n\n    error AmountOutTooLow(uint256 amount, uint256 min);\n    error BalanceTooLow();\n    error FlashbotsErrorPayingMiner(uint256 value);\n    error IncompatibleLengths();\n    error RevertBytes();\n    error ZeroAddress();\n\n    function functionTest() external pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/mock/MockLayerZero.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface ILzApp {\n    function lzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) external;\n}\n\ncontract MockLayerZero {\n    mapping(uint16 => uint256) public counters;\n    uint256 public config;\n    mapping(uint16 => uint64) public outboundNonce;\n    uint256 public resumeReceived;\n    uint256 public sendVersion;\n    uint256 public receiveVersion;\n\n    /// @notice Initiate with a fixe change rate\n    constructor() {}\n\n    function send(\n        uint16 _dstChainId,\n        bytes calldata,\n        bytes calldata,\n        address,\n        address,\n        bytes calldata\n    ) external payable {\n        counters[_dstChainId] += 1;\n    }\n\n    function getOutboundNonce(uint16 _dstChainId, address) external view returns (uint64) {\n        return outboundNonce[_dstChainId];\n    }\n\n    function setOutBoundNonce(uint16 _from, uint64 value) external {\n        outboundNonce[_from] = value;\n    }\n\n    function lzReceive(\n        address lzApp,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public {\n        ILzApp(lzApp).lzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    function estimateFees(\n        uint16,\n        address,\n        bytes calldata,\n        bool,\n        bytes calldata\n    ) external pure returns (uint256 nativeFee, uint256 zroFee) {\n        return (123, 456);\n    }\n\n    function setConfig(uint16, uint16, uint256 _configType, bytes calldata) external {\n        config = _configType;\n    }\n\n    function getConfig(uint16, uint16, address, uint256) external view returns (bytes memory) {\n        return abi.encodePacked(config);\n    }\n\n    function setSendVersion(uint16 _version) external {\n        sendVersion = _version;\n    }\n\n    function setReceiveVersion(uint16 _version) external {\n        receiveVersion = _version;\n    }\n\n    function forceResumeReceive(uint16, bytes calldata) external {\n        resumeReceived = 1 - resumeReceived;\n    }\n}\n"
    },
    "contracts/mock/MockLiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\nimport { ILiquidityGauge } from \"../interfaces/coreModule/ILiquidityGauge.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockLiquidityGauge is ILiquidityGauge, ERC20 {\n    using SafeERC20 for IERC20;\n\n    IERC20 internal _ANGLE = IERC20(0x31429d1856aD1377A8A0079410B297e1a9e214c2);\n    IERC20 internal _token;\n    mapping(address => uint256) public rewards;\n\n    constructor(string memory name_, string memory symbol_, address token_) ERC20(name_, symbol_) {\n        _token = IERC20(token_);\n    }\n\n    function deposit(\n        uint256 _value,\n        address _addr,\n        // solhint-disable-next-line\n        bool\n    ) external {\n        _token.safeTransferFrom(msg.sender, address(this), _value);\n        _mint(_addr, _value);\n    }\n\n    function withdraw(\n        uint256 _value,\n        // solhint-disable-next-line\n        bool\n    ) external {\n        _burn(msg.sender, _value);\n        _token.safeTransfer(msg.sender, _value);\n    }\n\n    // solhint-disable-next-line\n    function claim_rewards(address _addr, address _receiver) external {\n        if (_receiver == address(0)) _receiver = _addr;\n        _ANGLE.safeTransfer(_receiver, rewards[_addr]);\n        rewards[_addr] = 0;\n    }\n\n    // solhint-disable-next-line\n    function claimable_reward(address _addr, address) external view returns (uint256 amount) {\n        return rewards[_addr];\n    }\n\n    function setReward(address receiver_, uint256 amount) external {\n        rewards[receiver_] = amount;\n    }\n}\n"
    },
    "contracts/mock/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IOracle.sol\";\n\ncontract MockOracle is IOracle {\n    event Update(uint256 _peg);\n\n    ITreasury public treasury;\n\n    uint256 public base = 1 ether;\n    uint256 public precision = 1 ether;\n    uint256 public rate;\n    bool public outdated;\n\n    /// @notice Initiate with a fixe change rate\n    constructor(uint256 rate_, ITreasury _treasury) {\n        rate = rate_;\n        treasury = _treasury;\n    }\n\n    /// @notice Mock read\n    function read() external view override returns (uint256) {\n        return rate;\n    }\n\n    /// @notice change oracle rate\n    function update(uint256 newRate) external {\n        rate = newRate;\n    }\n\n    function setTreasury(address _treasury) external override {\n        treasury = ITreasury(_treasury);\n    }\n\n    function circuitChainlink() external pure override returns (AggregatorV3Interface[] memory) {}\n}\n"
    },
    "contracts/mock/MockPolygonAgEUR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport \"../agToken/polygon/utils/ERC20UpgradeableCustom.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\ninterface IChildToken {\n    function deposit(address user, bytes calldata depositData) external;\n\n    function withdraw(uint256 amount) external;\n}\n\ncontract MockPolygonAgEUR is\n    Initializable,\n    ERC20UpgradeableCustom,\n    AccessControlUpgradeable,\n    EIP712Upgradeable,\n    IChildToken\n{\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    /// @dev Emitted when the child chain manager changes\n    event ChildChainManagerAdded(address newAddress);\n    event ChildChainManagerRevoked(address oldAddress);\n\n    constructor() initializer {}\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address childChainManager,\n        address guardian\n    ) public initializer {\n        __ERC20_init(_name, _symbol);\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, guardian);\n        _setupRole(DEPOSITOR_ROLE, childChainManager);\n        __EIP712_init(_name, \"1\");\n    }\n\n    /**\n     * @notice Called when the bridge has tokens to mint\n     * @param user Address to mint the token to\n     * @param depositData Encoded amount to mint\n     */\n    function deposit(address user, bytes calldata depositData) external override {\n        require(hasRole(DEPOSITOR_ROLE, msg.sender));\n        uint256 amount = abi.decode(depositData, (uint256));\n        _mint(user, amount);\n    }\n\n    /**\n     * @notice Called when user wants to withdraw tokens back to root chain\n     * @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\n     * @param amount Amount of tokens to withdraw\n     */\n    function withdraw(uint256 amount) external override {\n        _burn(_msgSender(), amount);\n    }\n\n    // =============================================================================\n    // ======================= New data added for the upgrade ======================\n    // =============================================================================\n\n    mapping(address => bool) public isMinter;\n    /// @notice Reference to the treasury contract which can grant minting rights\n    address public treasury;\n    /// @notice Boolean to check whether the contract has been reinitialized after its upgrade\n    bool public treasuryInitialized;\n\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for fee computation\n    uint256 public constant BASE_PARAMS = 10 ** 9;\n\n    // =============================== Bridging Data ===============================\n\n    /// @notice Struct with some data about a specific bridge token\n    struct BridgeDetails {\n        // Limit on the balance of bridge token held by the contract: it is designed\n        // to reduce the exposure of the system to hacks\n        uint256 limit;\n        // Limit on the hourly volume of token minted through this bridge\n        // Technically the limit over a rolling hour is hourlyLimit x2 as hourly limit\n        // is enforced only between x:00 and x+1:00\n        uint256 hourlyLimit;\n        // Fee taken for swapping in and out the token\n        uint64 fee;\n        // Whether the associated token is allowed or not\n        bool allowed;\n        // Whether swapping in and out from the associated token is paused or not\n        bool paused;\n    }\n\n    /// @notice Maps a bridge token to data\n    mapping(address => BridgeDetails) public bridges;\n    /// @notice List of all bridge tokens\n    address[] public bridgeTokensList;\n    /// @notice Maps a bridge token to the associated hourly volume\n    mapping(address => mapping(uint256 => uint256)) public usage;\n    /// @notice Maps an address to whether it is exempt of fees for when it comes to swapping in and out\n    mapping(address => uint256) public isFeeExempt;\n\n    uint256[44] private __gap;\n\n    // ================================== Events ===================================\n\n    event BridgeTokenAdded(address indexed bridgeToken, uint256 limit, uint256 hourlyLimit, uint64 fee, bool paused);\n    event BridgeTokenToggled(address indexed bridgeToken, bool toggleStatus);\n    event BridgeTokenRemoved(address indexed bridgeToken);\n    event BridgeTokenFeeUpdated(address indexed bridgeToken, uint64 fee);\n    event BridgeTokenLimitUpdated(address indexed bridgeToken, uint256 limit);\n    event BridgeTokenHourlyLimitUpdated(address indexed bridgeToken, uint256 hourlyLimit);\n    event HourlyLimitUpdated(uint256 hourlyLimit);\n    event FeeToggled(address indexed theAddress, uint256 toggleStatus);\n    event KeeperToggled(address indexed keeper, bool toggleStatus);\n    event MinterToggled(address indexed minter);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event TreasuryUpdated(address indexed _treasury);\n\n    // ================================== Errors ===================================\n\n    error AssetStillControlledInReserves();\n    error BurnAmountExceedsAllowance();\n    error HourlyLimitExceeded();\n    error InvalidSender();\n    error InvalidToken();\n    error InvalidTreasury();\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error NotMinter();\n    error NotTreasury();\n    error TooBigAmount();\n    error TooHighParameterValue();\n    error TreasuryAlreadyInitialized();\n    error ZeroAddress();\n\n    /// @notice Checks to see if it is the `Treasury` calling this contract\n    /// @dev There is no Access Control here, because it can be handled cheaply through this modifier\n    modifier onlyTreasury() {\n        if (msg.sender != treasury) revert NotTreasury();\n        _;\n    }\n\n    /// @notice Checks whether the sender has the minting right\n    modifier onlyMinter() {\n        if (!isMinter[msg.sender]) revert NotMinter();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!ITreasury(treasury).isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!ITreasury(treasury).isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    /// @notice Sets up the treasury contract on Polygon after the upgrade\n    /// @param _treasury Address of the treasury contract\n    function setUpTreasury(address _treasury) external {\n        // Only governor on Polygon\n        if (msg.sender != 0xdA2D2f638D6fcbE306236583845e5822554c02EA) revert NotGovernor();\n        if (address(ITreasury(_treasury).stablecoin()) != address(this)) revert InvalidTreasury();\n        if (treasuryInitialized) revert TreasuryAlreadyInitialized();\n        treasury = _treasury;\n        treasuryInitialized = true;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // =========================== External Function ===============================\n\n    /// @notice Allows anyone to burn agToken without redeeming collateral back\n    /// @param amount Amount of stablecoins to burn\n    /// @dev This function can typically be called if there is a settlement mechanism to burn stablecoins\n    function burnStablecoin(uint256 amount) external {\n        _burnCustom(msg.sender, amount);\n    }\n\n    // ======================= Minter Role Only Functions ==========================\n\n    function burnSelf(uint256 amount, address burner) external onlyMinter {\n        _burnCustom(burner, amount);\n    }\n\n    function burnFrom(uint256 amount, address burner, address sender) external onlyMinter {\n        _burnFromNoRedeem(amount, burner, sender);\n    }\n\n    function mint(address account, uint256 amount) external onlyMinter {\n        _mint(account, amount);\n    }\n\n    // ======================= Treasury Only Functions =============================\n\n    function addMinter(address minter) external onlyTreasury {\n        isMinter[minter] = true;\n        emit MinterToggled(minter);\n    }\n\n    function removeMinter(address minter) external {\n        if (msg.sender != address(treasury) && msg.sender != minter) revert InvalidSender();\n        isMinter[minter] = false;\n        emit MinterToggled(minter);\n    }\n\n    function setTreasury(address _treasury) external onlyTreasury {\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // ============================ Internal Function ==============================\n\n    /// @notice Internal version of the function `burnFromNoRedeem`\n    /// @param amount Amount to burn\n    /// @dev It is at the level of this function that allowance checks are performed\n    function _burnFromNoRedeem(uint256 amount, address burner, address sender) internal {\n        if (burner != sender) {\n            uint256 currentAllowance = allowance(burner, sender);\n            if (currentAllowance < amount) revert BurnAmountExceedsAllowance();\n            _approve(burner, sender, currentAllowance - amount);\n        }\n        _burnCustom(burner, amount);\n    }\n\n    // ==================== External Permissionless Functions ======================\n\n    /// @notice Returns the list of all supported bridge tokens\n    /// @dev Helpful for UIs\n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridgeTokensList;\n    }\n\n    /// @notice Returns the current volume for a bridge, for the current hour\n    /// @dev Helpful for UIs\n    function currentUsage(address bridge) external view returns (uint256) {\n        return usage[bridge][block.timestamp / 3600];\n    }\n\n    /// @notice Mints the canonical token from a supported bridge token\n    /// @param bridgeToken Bridge token to use to mint\n    /// @param amount Amount of bridge tokens to send\n    /// @param to Address to which the stablecoin should be sent\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapIn(address bridgeToken, uint256 amount, address to) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n        uint256 balance = IERC20(bridgeToken).balanceOf(address(this));\n        if (balance + amount > bridgeDetails.limit) {\n            // In case someone maliciously sends tokens to this contract\n            // Or the limit changes\n            if (bridgeDetails.limit > balance) amount = bridgeDetails.limit - balance;\n            else {\n                amount = 0;\n            }\n        }\n\n        // Checking requirement on the hourly volume\n        uint256 hour = block.timestamp / 3600;\n        uint256 hourlyUsage = usage[bridgeToken][hour] + amount;\n        if (hourlyUsage > bridgeDetails.hourlyLimit) {\n            // Edge case when the hourly limit changes\n            if (bridgeDetails.hourlyLimit > usage[bridgeToken][hour])\n                amount = bridgeDetails.hourlyLimit - usage[bridgeToken][hour];\n            else {\n                amount = 0;\n            }\n        }\n        usage[bridgeToken][hour] = usage[bridgeToken][hour] + amount;\n\n        IERC20(bridgeToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 canonicalOut = amount;\n        // Computing fees\n        if (isFeeExempt[msg.sender] == 0) {\n            canonicalOut -= (canonicalOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        _mint(to, canonicalOut);\n        return canonicalOut;\n    }\n\n    /// @notice Burns the canonical token in exchange for a bridge token\n    /// @param bridgeToken Bridge token required\n    /// @param amount Amount of canonical tokens to burn\n    /// @param to Address to which the bridge token should be sent\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapOut(address bridgeToken, uint256 amount, address to) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n\n        _burnCustom(msg.sender, amount);\n        uint256 bridgeOut = amount;\n        if (isFeeExempt[msg.sender] == 0) {\n            bridgeOut -= (bridgeOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        IERC20(bridgeToken).safeTransfer(to, bridgeOut);\n        return bridgeOut;\n    }\n\n    // ======================= Governance Functions ================================\n\n    /// @notice Adds support for a bridge token\n    /// @param bridgeToken Bridge token to add: it should be a version of the stablecoin from another bridge\n    /// @param limit Limit on the balance of bridge token this contract could hold\n    /// @param hourlyLimit Limit on the hourly volume for this bridge\n    /// @param paused Whether swapping for this token should be paused or not\n    /// @param fee Fee taken upon swapping for or against this token\n    function addBridgeToken(\n        address bridgeToken,\n        uint256 limit,\n        uint256 hourlyLimit,\n        uint64 fee,\n        bool paused\n    ) external onlyGovernor {\n        if (bridges[bridgeToken].allowed || bridgeToken == address(0)) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        BridgeDetails memory _bridge;\n        _bridge.limit = limit;\n        _bridge.hourlyLimit = hourlyLimit;\n        _bridge.paused = paused;\n        _bridge.fee = fee;\n        _bridge.allowed = true;\n        bridges[bridgeToken] = _bridge;\n        bridgeTokensList.push(bridgeToken);\n        emit BridgeTokenAdded(bridgeToken, limit, hourlyLimit, fee, paused);\n    }\n\n    /// @notice Removes support for a token\n    /// @param bridgeToken Address of the bridge token to remove support for\n    function removeBridgeToken(address bridgeToken) external onlyGovernor {\n        if (IERC20(bridgeToken).balanceOf(address(this)) != 0) revert AssetStillControlledInReserves();\n        delete bridges[bridgeToken];\n        // Deletion from `bridgeTokensList` loop\n        uint256 bridgeTokensListLength = bridgeTokensList.length;\n        for (uint256 i; i < bridgeTokensListLength - 1; ++i) {\n            if (bridgeTokensList[i] == bridgeToken) {\n                // Replace the `bridgeToken` to remove with the last of the list\n                bridgeTokensList[i] = bridgeTokensList[bridgeTokensListLength - 1];\n                break;\n            }\n        }\n        // Remove last element in array\n        bridgeTokensList.pop();\n        emit BridgeTokenRemoved(bridgeToken);\n    }\n\n    /// @notice Recovers any ERC20 token\n    /// @dev Can be used to withdraw bridge tokens for them to be de-bridged on mainnet\n    function recoverERC20(address tokenAddress, address to, uint256 amountToRecover) external onlyGovernor {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Updates the `limit` amount for `bridgeToken`\n    function setLimit(address bridgeToken, uint256 limit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].limit = limit;\n        emit BridgeTokenLimitUpdated(bridgeToken, limit);\n    }\n\n    /// @notice Updates the `hourlyLimit` amount for `bridgeToken`\n    function setHourlyLimit(address bridgeToken, uint256 hourlyLimit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].hourlyLimit = hourlyLimit;\n        emit BridgeTokenHourlyLimitUpdated(bridgeToken, hourlyLimit);\n    }\n\n    /// @notice Updates the `fee` value for `bridgeToken`\n    function setSwapFee(address bridgeToken, uint64 fee) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        bridges[bridgeToken].fee = fee;\n        emit BridgeTokenFeeUpdated(bridgeToken, fee);\n    }\n\n    /// @notice Pauses or unpauses swapping in and out for a token\n    function toggleBridge(address bridgeToken) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bool pausedStatus = bridges[bridgeToken].paused;\n        bridges[bridgeToken].paused = !pausedStatus;\n        emit BridgeTokenToggled(bridgeToken, !pausedStatus);\n    }\n\n    /// @notice Toggles fees for the address `theAddress`\n    function toggleFeesForAddress(address theAddress) external onlyGovernorOrGuardian {\n        uint256 feeExemptStatus = 1 - isFeeExempt[theAddress];\n        isFeeExempt[theAddress] = feeExemptStatus;\n        emit FeeToggled(theAddress, feeExemptStatus);\n    }\n}\n"
    },
    "contracts/mock/MockRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IAngleRouter.sol\";\nimport \"../interfaces/external/uniswap/IUniswapRouter.sol\";\nimport \"../interfaces/external/lido/IWStETH.sol\";\n\ncontract MockRouter is IUniswapV3Router, IWStETH {\n    using SafeERC20 for IERC20;\n\n    uint256 public counterAngleMint;\n    uint256 public counterAngleBurn;\n    uint256 public counter1Inch;\n    uint256 public counterUni;\n    uint256 public counterWrap;\n    uint256 public counterMixer;\n    uint256 public amountOutUni;\n    uint256 public multiplierMintBurn;\n    uint256 public stETHMultiplier;\n    address public inToken;\n    address public outToken;\n\n    address public stETH;\n\n    /// @notice Action types\n    enum ActionType {\n        transfer,\n        wrap,\n        wrapNative,\n        sweep,\n        sweepNative,\n        unwrap,\n        unwrapNative,\n        swapIn,\n        swapOut,\n        uniswapV3,\n        oneInch,\n        claimRewards,\n        gaugeDeposit,\n        borrower\n    }\n\n    /// @notice Data needed to get permits\n    struct PermitType {\n        address token;\n        address owner;\n        uint256 value;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    constructor() {}\n\n    function mint(address user, uint256 amount, uint256, address stablecoin, address collateral) external {\n        counterAngleMint += 1;\n        IERC20(collateral).safeTransferFrom(msg.sender, address(this), amount);\n        IERC20(stablecoin).safeTransfer(user, (amount * 10 ** 9) / multiplierMintBurn);\n    }\n\n    function setStETH(address _stETH) external {\n        stETH = _stETH;\n    }\n\n    function burn(address user, uint256 amount, uint256, address stablecoin, address collateral) external {\n        counterAngleBurn += 1;\n        IERC20(stablecoin).safeTransferFrom(msg.sender, address(this), amount);\n        IERC20(collateral).safeTransfer(user, (amount * multiplierMintBurn) / 10 ** 9);\n    }\n\n    function mixer(\n        PermitType[] memory paramsPermit,\n        ActionType[] memory actions,\n        bytes[] calldata data\n    ) public payable virtual {\n        paramsPermit;\n        counterMixer += 1;\n        for (uint256 i; i < actions.length; ++i) {\n            if (actions[i] == ActionType.transfer) {\n                (address transferToken, uint256 amount) = abi.decode(data[i], (address, uint256));\n                IERC20(transferToken).safeTransferFrom(msg.sender, address(this), amount);\n            }\n        }\n    }\n\n    function wrap(uint256 amount) external returns (uint256 amountOut) {\n        amountOut = (amount * stETHMultiplier) / 10 ** 9;\n        counterWrap += 1;\n        IERC20(stETH).safeTransferFrom(msg.sender, address(this), amount);\n        IERC20(outToken).safeTransfer(msg.sender, amountOut);\n    }\n\n    function oneInch(uint256 amountIn) external returns (uint256 amountOut) {\n        counter1Inch += 1;\n        amountOut = (amountOutUni * amountIn) / 10 ** 9;\n        IERC20(inToken).safeTransferFrom(msg.sender, address(this), amountIn);\n        IERC20(outToken).safeTransfer(msg.sender, amountOut);\n    }\n\n    function oneInchReverts() external {\n        counter1Inch += 1;\n        revert(\"wrong swap\");\n    }\n\n    function oneInchRevertsWithoutMessage() external {\n        counter1Inch += 1;\n        require(false);\n    }\n\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut) {\n        counterUni += 1;\n        amountOut = (params.amountIn * amountOutUni) / 10 ** 9;\n        IERC20(inToken).safeTransferFrom(msg.sender, address(this), params.amountIn);\n        IERC20(outToken).safeTransfer(params.recipient, amountOut);\n        require(amountOut >= params.amountOutMinimum);\n    }\n\n    function setMultipliers(uint256 a, uint256 b) external {\n        amountOutUni = a;\n        multiplierMintBurn = b;\n    }\n\n    function setStETHMultiplier(uint256 value) external {\n        stETHMultiplier = value;\n    }\n\n    function setInOut(address _collateral, address _stablecoin) external {\n        inToken = _collateral;\n        outToken = _stablecoin;\n    }\n}\n"
    },
    "contracts/mock/MockSidechainAgEUR.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../agToken/AgToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title AgTokenSideChainMultiBridge\n/// @author Angle Labs, Inc.\n/// @notice Contract for Angle agTokens on other chains than Ethereum mainnet\n/// @dev This contract supports bridge tokens having a minting right on the stablecoin (also referred to as the canonical\n/// or the native token)\n/// @dev References:\n///      - FRAX implementation: https://polygonscan.com/address/0x45c32fA6DF82ead1e2EF74d17b76547EDdFaFF89#code\n///      - QiDAO implementation: https://snowtrace.io/address/0x5c49b268c9841AFF1Cc3B0a418ff5c3442eE3F3b#code\ncontract MockSidechainAgEUR is AgToken {\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for fee computation\n    uint256 public constant BASE_PARAMS = 10 ** 9;\n\n    // =============================== Bridging Data ===============================\n\n    /// @notice Struct with some data about a specific bridge token\n    struct BridgeDetails {\n        // Limit on the balance of bridge token held by the contract: it is designed\n        // to reduce the exposure of the system to hacks\n        uint256 limit;\n        // Limit on the hourly volume of token minted through this bridge\n        // Technically the limit over a rolling hour is hourlyLimit x2 as hourly limit\n        // is enforced only between x:00 and x+1:00\n        uint256 hourlyLimit;\n        // Fee taken for swapping in and out the token\n        uint64 fee;\n        // Whether the associated token is allowed or not\n        bool allowed;\n        // Whether swapping in and out from the associated token is paused or not\n        bool paused;\n    }\n\n    /// @notice Maps a bridge token to data\n    mapping(address => BridgeDetails) public bridges;\n    /// @notice List of all bridge tokens\n    address[] public bridgeTokensList;\n    /// @notice Maps a bridge token to the associated hourly volume\n    mapping(address => mapping(uint256 => uint256)) public usage;\n    /// @notice Maps an address to whether it is exempt of fees for when it comes to swapping in and out\n    mapping(address => uint256) public isFeeExempt;\n\n    // ================================== Events ===================================\n\n    event BridgeTokenAdded(address indexed bridgeToken, uint256 limit, uint256 hourlyLimit, uint64 fee, bool paused);\n    event BridgeTokenToggled(address indexed bridgeToken, bool toggleStatus);\n    event BridgeTokenRemoved(address indexed bridgeToken);\n    event BridgeTokenFeeUpdated(address indexed bridgeToken, uint64 fee);\n    event BridgeTokenLimitUpdated(address indexed bridgeToken, uint256 limit);\n    event BridgeTokenHourlyLimitUpdated(address indexed bridgeToken, uint256 hourlyLimit);\n    event HourlyLimitUpdated(uint256 hourlyLimit);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event FeeToggled(address indexed theAddress, uint256 toggleStatus);\n\n    // =============================== Errors ================================\n\n    error AssetStillControlledInReserves();\n    error HourlyLimitExceeded();\n    error InvalidToken();\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error TooBigAmount();\n    error TooHighParameterValue();\n    error ZeroAddress();\n\n    // ============================= Constructor ===================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!ITreasury(treasury).isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!ITreasury(treasury).isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    // ==================== External Permissionless Functions ======================\n\n    /// @notice Returns the list of all supported bridge tokens\n    /// @dev Helpful for UIs\n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridgeTokensList;\n    }\n\n    /// @notice Returns the current volume for a bridge, for the current hour\n    /// @param bridgeToken Bridge used to mint\n    /// @dev Helpful for UIs\n    function currentUsage(address bridgeToken) external view returns (uint256) {\n        return usage[bridgeToken][block.timestamp / 3600];\n    }\n\n    /// @notice Mints the canonical token from a supported bridge token\n    /// @param bridgeToken Bridge token to use to mint\n    /// @param amount Amount of bridge tokens to send\n    /// @param to Address to which the stablecoin should be sent\n    /// @return Amount of the canonical stablecoin actually minted\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapIn(address bridgeToken, uint256 amount, address to) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n        uint256 balance = IERC20(bridgeToken).balanceOf(address(this));\n        if (balance + amount > bridgeDetails.limit) {\n            // In case someone maliciously sends tokens to this contract\n            // Or the limit changes\n            if (bridgeDetails.limit > balance) amount = bridgeDetails.limit - balance;\n            else {\n                amount = 0;\n            }\n        }\n\n        // Checking requirement on the hourly volume\n        uint256 hour = block.timestamp / 3600;\n        uint256 hourlyUsage = usage[bridgeToken][hour] + amount;\n        if (hourlyUsage > bridgeDetails.hourlyLimit) {\n            // Edge case when the hourly limit changes\n            if (bridgeDetails.hourlyLimit > usage[bridgeToken][hour])\n                amount = bridgeDetails.hourlyLimit - usage[bridgeToken][hour];\n            else {\n                amount = 0;\n            }\n        }\n        usage[bridgeToken][hour] = usage[bridgeToken][hour] + amount;\n\n        IERC20(bridgeToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 canonicalOut = amount;\n        // Computing fees\n        if (isFeeExempt[msg.sender] == 0) {\n            canonicalOut -= (canonicalOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        _mint(to, canonicalOut);\n        return canonicalOut;\n    }\n\n    /// @notice Burns the canonical token in exchange for a bridge token\n    /// @param bridgeToken Bridge token required\n    /// @param amount Amount of canonical tokens to burn\n    /// @param to Address to which the bridge token should be sent\n    /// @return Amount of bridge tokens actually sent back\n    /// @dev Some fees may be taken by the protocol depending on the token used and on the address calling\n    function swapOut(address bridgeToken, uint256 amount, address to) external returns (uint256) {\n        BridgeDetails memory bridgeDetails = bridges[bridgeToken];\n        if (!bridgeDetails.allowed || bridgeDetails.paused) revert InvalidToken();\n\n        _burn(msg.sender, amount);\n        uint256 bridgeOut = amount;\n        if (isFeeExempt[msg.sender] == 0) {\n            bridgeOut -= (bridgeOut * bridgeDetails.fee) / BASE_PARAMS;\n        }\n        IERC20(bridgeToken).safeTransfer(to, bridgeOut);\n        return bridgeOut;\n    }\n\n    // ======================= Governance Functions ================================\n\n    /// @notice Adds support for a bridge token\n    /// @param bridgeToken Bridge token to add: it should be a version of the stablecoin from another bridge\n    /// @param limit Limit on the balance of bridge token this contract could hold\n    /// @param hourlyLimit Limit on the hourly volume for this bridge\n    /// @param paused Whether swapping for this token should be paused or not\n    /// @param fee Fee taken upon swapping for or against this token\n    function addBridgeToken(\n        address bridgeToken,\n        uint256 limit,\n        uint256 hourlyLimit,\n        uint64 fee,\n        bool paused\n    ) external onlyGovernor {\n        if (bridges[bridgeToken].allowed || bridgeToken == address(0)) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        BridgeDetails memory _bridge;\n        _bridge.limit = limit;\n        _bridge.hourlyLimit = hourlyLimit;\n        _bridge.paused = paused;\n        _bridge.fee = fee;\n        _bridge.allowed = true;\n        bridges[bridgeToken] = _bridge;\n        bridgeTokensList.push(bridgeToken);\n        emit BridgeTokenAdded(bridgeToken, limit, hourlyLimit, fee, paused);\n    }\n\n    /// @notice Removes support for a token\n    /// @param bridgeToken Address of the bridge token to remove support for\n    function removeBridgeToken(address bridgeToken) external onlyGovernor {\n        if (IERC20(bridgeToken).balanceOf(address(this)) != 0) revert AssetStillControlledInReserves();\n        delete bridges[bridgeToken];\n        // Deletion from `bridgeTokensList` loop\n        uint256 bridgeTokensListLength = bridgeTokensList.length;\n        for (uint256 i; i < bridgeTokensListLength - 1; ++i) {\n            if (bridgeTokensList[i] == bridgeToken) {\n                // Replace the `bridgeToken` to remove with the last of the list\n                bridgeTokensList[i] = bridgeTokensList[bridgeTokensListLength - 1];\n                break;\n            }\n        }\n        // Remove last element in array\n        bridgeTokensList.pop();\n        emit BridgeTokenRemoved(bridgeToken);\n    }\n\n    /// @notice Recovers any ERC20 token\n    /// @dev Can be used to withdraw bridge tokens for them to be de-bridged on mainnet\n    function recoverERC20(address tokenAddress, address to, uint256 amountToRecover) external onlyGovernor {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Updates the `limit` amount for `bridgeToken`\n    function setLimit(address bridgeToken, uint256 limit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].limit = limit;\n        emit BridgeTokenLimitUpdated(bridgeToken, limit);\n    }\n\n    /// @notice Updates the `hourlyLimit` amount for `bridgeToken`\n    function setHourlyLimit(address bridgeToken, uint256 hourlyLimit) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bridges[bridgeToken].hourlyLimit = hourlyLimit;\n        emit BridgeTokenHourlyLimitUpdated(bridgeToken, hourlyLimit);\n    }\n\n    /// @notice Updates the `fee` value for `bridgeToken`\n    function setSwapFee(address bridgeToken, uint64 fee) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        if (fee > BASE_PARAMS) revert TooHighParameterValue();\n        bridges[bridgeToken].fee = fee;\n        emit BridgeTokenFeeUpdated(bridgeToken, fee);\n    }\n\n    /// @notice Pauses or unpauses swapping in and out for a token\n    function toggleBridge(address bridgeToken) external onlyGovernorOrGuardian {\n        if (!bridges[bridgeToken].allowed) revert InvalidToken();\n        bool pausedStatus = bridges[bridgeToken].paused;\n        bridges[bridgeToken].paused = !pausedStatus;\n        emit BridgeTokenToggled(bridgeToken, !pausedStatus);\n    }\n\n    /// @notice Toggles fees for the address `theAddress`\n    function toggleFeesForAddress(address theAddress) external onlyGovernorOrGuardian {\n        uint256 feeExemptStatus = 1 - isFeeExempt[theAddress];\n        isFeeExempt[theAddress] = feeExemptStatus;\n        emit FeeToggled(theAddress, feeExemptStatus);\n    }\n}\n"
    },
    "contracts/mock/MockStableMaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"./MockToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SLPData, MintBurnData } from \"../interfaces/coreModule/IStableMaster.sol\";\n\n// All the details about a collateral that are going to be stored in `StableMaster`\nstruct Collateral {\n    // Interface for the token accepted by the underlying `PoolManager` contract\n    IERC20 token;\n    // Reference to the `SanToken` for the pool\n    MockToken sanToken;\n    // Reference to the `PerpetualManager` for the pool\n    address perpetualManager;\n    // Adress of the oracle for the change rate between\n    // collateral and the corresponding stablecoin\n    address oracle;\n    // Amount of collateral in the reserves that comes from users\n    // converted in stablecoin value. Updated at minting and burning.\n    // A `stocksUsers` of 10 for a collateral type means that overall the balance of the collateral from users\n    // that minted/burnt stablecoins using this collateral is worth 10 of stablecoins\n    uint256 stocksUsers;\n    // Exchange rate between sanToken and collateral\n    uint256 sanRate;\n    // Base used in the collateral implementation (ERC20 decimal)\n    uint256 collatBase;\n    // Parameters for SLPs and update of the `sanRate`\n    SLPData slpData;\n    // All the fees parameters\n    MintBurnData feeData;\n}\n\ncontract MockStableMaster {\n    mapping(address => uint256) public poolManagerMap;\n\n    constructor() {}\n\n    function updateStocksUsers(uint256 amount, address poolManager) external {\n        poolManagerMap[poolManager] += amount;\n    }\n\n    function burnSelf(IAgToken agToken, uint256 amount, address burner) external {\n        agToken.burnSelf(amount, burner);\n    }\n\n    function burnFrom(IAgToken agToken, uint256 amount, address burner, address sender) external {\n        agToken.burnFrom(amount, burner, sender);\n    }\n\n    function mint(IAgToken agToken, address account, uint256 amount) external {\n        agToken.mint(account, amount);\n    }\n}\n\ncontract MockStableMasterSanWrapper is MockStableMaster {\n    using SafeERC20 for IERC20;\n\n    /// @notice Maps a `PoolManager` contract handling a collateral for this stablecoin to the properties of the struct above\n    mapping(address => Collateral) public collateralMap;\n\n    constructor() MockStableMaster() {}\n\n    uint256 internal constant _BASE_TOKENS = 10 ** 18;\n    uint256 internal constant _BASE_PARAMS = 10 ** 9;\n    IERC20 public token;\n\n    function deposit(uint256 assets, address receiver, address poolManager) external {\n        token.safeTransferFrom(msg.sender, address(this), assets);\n        Collateral storage col = collateralMap[poolManager];\n        _updateSanRate(col);\n        uint256 amount = (assets * _BASE_TOKENS) / col.sanRate;\n        col.sanToken.mint(receiver, amount);\n    }\n\n    function withdraw(uint256 assets, address sender, address receiver, address poolManager) external {\n        Collateral storage col = collateralMap[poolManager];\n        _updateSanRate(col);\n        col.sanToken.burn(sender, assets);\n        // Computing the amount of collateral to give back to the SLP depending on slippage and on the `sanRate`\n        uint256 redeemInC = (assets * (_BASE_PARAMS - col.slpData.slippage) * col.sanRate) /\n            (_BASE_TOKENS * _BASE_PARAMS);\n        token.safeTransfer(receiver, redeemInC);\n    }\n\n    function setPoolManagerToken(address, address token_) external {\n        token = MockToken(token_);\n    }\n\n    function setPoolManagerSanToken(address poolManager, address sanToken_) external {\n        Collateral storage col = collateralMap[poolManager];\n        col.sanToken = MockToken(sanToken_);\n    }\n\n    function setSanRate(address poolManager, uint256 sanRate_) external {\n        Collateral storage col = collateralMap[poolManager];\n        col.sanRate = sanRate_;\n    }\n\n    function _updateSanRate(Collateral storage col) internal {\n        uint256 _lockedInterests = col.slpData.lockedInterests;\n        // Checking if the `sanRate` has been updated in the current block using past block fees\n        // This is a way to prevent flash loans attacks when an important amount of fees are going to be distributed\n        // in a block: fees are stored but will just be distributed to SLPs who will be here during next blocks\n        if (block.timestamp != col.slpData.lastBlockUpdated && _lockedInterests > 0) {\n            uint256 sanMint = col.sanToken.totalSupply();\n            if (sanMint != 0) {\n                // Checking if the update is too important and should be made in multiple blocks\n                if (_lockedInterests > col.slpData.maxInterestsDistributed) {\n                    // `sanRate` is expressed in `BASE_TOKENS`\n                    col.sanRate += (col.slpData.maxInterestsDistributed * 10 ** 18) / sanMint;\n                    _lockedInterests -= col.slpData.maxInterestsDistributed;\n                } else {\n                    col.sanRate += (_lockedInterests * 10 ** 18) / sanMint;\n                    _lockedInterests = 0;\n                }\n            } else {\n                _lockedInterests = 0;\n            }\n        }\n        col.slpData.lockedInterests = _lockedInterests;\n        col.slpData.lastBlockUpdated = block.timestamp;\n    }\n\n    // copy paste from the deployed contract\n    function estimateSanRate(address poolManager) external view returns (uint256 sanRate, uint64 slippage) {\n        Collateral memory col = collateralMap[poolManager];\n        uint256 _lockedInterests = col.slpData.lockedInterests;\n        // Checking if the `sanRate` has been updated in the current block using past block fees\n        // This is a way to prevent flash loans attacks when an important amount of fees are going to be distributed\n        // in a block: fees are stored but will just be distributed to SLPs who will be here during next blocks\n        if (block.timestamp != col.slpData.lastBlockUpdated && _lockedInterests > 0) {\n            uint256 sanMint = col.sanToken.totalSupply();\n            if (sanMint != 0) {\n                // Checking if the update is too important and should be made in multiple blocks\n                if (_lockedInterests > col.slpData.maxInterestsDistributed) {\n                    // `sanRate` is expressed in `BASE_TOKENS`\n                    col.sanRate += (col.slpData.maxInterestsDistributed * 10 ** 18) / sanMint;\n                    _lockedInterests -= col.slpData.maxInterestsDistributed;\n                } else {\n                    col.sanRate += (_lockedInterests * 10 ** 18) / sanMint;\n                    _lockedInterests = 0;\n                }\n            } else {\n                _lockedInterests = 0;\n            }\n        }\n        return (col.sanRate, col.slpData.slippage);\n    }\n\n    function setSLPData(\n        address poolManager,\n        uint256 lockedInterests,\n        uint256 maxInterestsDistributed,\n        uint64 slippage\n    ) external {\n        Collateral storage col = collateralMap[poolManager];\n        col.slpData.lockedInterests = lockedInterests;\n        col.slpData.maxInterestsDistributed = maxInterestsDistributed;\n        col.slpData.slippage = slippage;\n    }\n}\n"
    },
    "contracts/mock/MockSwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/ISwapper.sol\";\n\ncontract MockSwapper is ISwapper {\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    uint256 public counter;\n\n    constructor() {}\n\n    function swap(IERC20, IERC20, address, uint256, uint256, bytes calldata data) external {\n        counter += 1;\n        data;\n    }\n}\n\ncontract MockSwapperWithSwap is ISwapper {\n    using SafeERC20 for IERC20;\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    uint256 public counter;\n\n    constructor() {}\n\n    function swap(\n        IERC20,\n        IERC20 outToken,\n        address outTokenRecipient,\n        uint256 outTokenOwed,\n        uint256,\n        bytes calldata data\n    ) external {\n        counter += 1;\n        outToken.safeTransfer(outTokenRecipient, outTokenOwed);\n\n        data;\n    }\n}\n"
    },
    "contracts/mock/MockSwapperSidechain.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../swapper/Swapper.sol\";\n\n/// @title MockSwapperSidechain\n/// @author Angle Labs, Inc.\ncontract MockSwapperSidechain is Swapper {\n    error NotImplemented();\n\n    /// @notice Constructor of the contract\n    /// @param _core Core address\n    /// @param _uniV3Router UniswapV3 Router address\n    /// @param _oneInch 1Inch Router address\n    /// @param _angleRouter AngleRouter contract address\n    constructor(\n        ICoreBorrow _core,\n        IUniswapV3Router _uniV3Router,\n        address _oneInch,\n        IAngleRouterSidechain _angleRouter\n    ) Swapper(_core, _uniV3Router, _oneInch, _angleRouter) {}\n\n    function _swapLeverage(bytes memory) internal pure override returns (uint256) {\n        revert NotImplemented();\n    }\n}\n"
    },
    "contracts/mock/MockToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    uint8 internal _decimal;\n    mapping(address => bool) public minters;\n    address public treasury;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimal_) ERC20(name_, symbol_) {\n        _decimal = decimal_;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimal;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function setAllowance(address from, address to) public {\n        _approve(from, to, type(uint256).max);\n    }\n\n    function burnSelf(uint256 amount, address account) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function addMinter(address minter) public {\n        minters[minter] = true;\n    }\n\n    function removeMinter(address minter) public {\n        minters[minter] = false;\n    }\n\n    function setTreasury(address _treasury) public {\n        treasury = _treasury;\n    }\n}\n"
    },
    "contracts/mock/MockTokenPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract MockTokenPermit is ERC20Permit {\n    using SafeERC20 for IERC20;\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    uint8 internal _decimal;\n    mapping(address => bool) public minters;\n    address public treasury;\n    uint256 public fees;\n\n    bool public reverts;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimal_) ERC20Permit(name_) ERC20(name_, symbol_) {\n        _decimal = decimal_;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimal;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function setAllowance(address from, address to) public {\n        _approve(from, to, type(uint256).max);\n    }\n\n    function burnSelf(uint256 amount, address account) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function addMinter(address minter) public {\n        minters[minter] = true;\n    }\n\n    function removeMinter(address minter) public {\n        minters[minter] = false;\n    }\n\n    function setTreasury(address _treasury) public {\n        treasury = _treasury;\n    }\n\n    function setFees(uint256 _fees) public {\n        fees = _fees;\n    }\n\n    function recoverERC20(IERC20 token, address to, uint256 amount) external {\n        token.safeTransfer(to, amount);\n    }\n\n    function swapIn(address bridgeToken, uint256 amount, address to) external returns (uint256) {\n        require(!reverts);\n\n        IERC20(bridgeToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 canonicalOut = amount;\n        canonicalOut -= (canonicalOut * fees) / 10 ** 9;\n        _mint(to, canonicalOut);\n        return canonicalOut;\n    }\n\n    function swapOut(address bridgeToken, uint256 amount, address to) external returns (uint256) {\n        require(!reverts);\n        _burn(msg.sender, amount);\n        uint256 bridgeOut = amount;\n        bridgeOut -= (bridgeOut * fees) / 10 ** 9;\n        IERC20(bridgeToken).safeTransfer(to, bridgeOut);\n        return bridgeOut;\n    }\n}\n"
    },
    "contracts/mock/MockTreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/IVaultManager.sol\";\n\ncontract MockTreasury is ITreasury {\n    IAgToken public override stablecoin;\n    address public governor;\n    address public guardian;\n    address public vaultManager1;\n    address public vaultManager2;\n    address public flashLoanModule;\n    address[] public vaultManagerList;\n\n    constructor(\n        IAgToken _stablecoin,\n        address _governor,\n        address _guardian,\n        address _vaultManager1,\n        address _vaultManager2,\n        address _flashLoanModule\n    ) {\n        stablecoin = _stablecoin;\n        governor = _governor;\n        guardian = _guardian;\n        vaultManager1 = _vaultManager1;\n        vaultManager2 = _vaultManager2;\n        flashLoanModule = _flashLoanModule;\n    }\n\n    function isGovernor(address admin) external view override returns (bool) {\n        return (admin == governor);\n    }\n\n    function isGovernorOrGuardian(address admin) external view override returns (bool) {\n        return (admin == governor || admin == guardian);\n    }\n\n    function isVaultManager(address _vaultManager) external view override returns (bool) {\n        return (_vaultManager == vaultManager1 || _vaultManager == vaultManager2);\n    }\n\n    function setStablecoin(IAgToken _stablecoin) external {\n        stablecoin = _stablecoin;\n    }\n\n    function setFlashLoanModule(address _flashLoanModule) external override {\n        flashLoanModule = _flashLoanModule;\n    }\n\n    function setGovernor(address _governor) external {\n        governor = _governor;\n    }\n\n    function setVaultManager(address _vaultManager) external {\n        vaultManager1 = _vaultManager;\n    }\n\n    function setVaultManager2(address _vaultManager) external {\n        vaultManager2 = _vaultManager;\n    }\n\n    function setTreasury(address _agTokenOrVaultManager, address _treasury) external {\n        IAgToken(_agTokenOrVaultManager).setTreasury(_treasury);\n    }\n\n    function addMinter(IAgToken _agToken, address _minter) external {\n        _agToken.addMinter(_minter);\n    }\n\n    function removeMinter(IAgToken _agToken, address _minter) external {\n        _agToken.removeMinter(_minter);\n    }\n\n    function accrueInterestToTreasury(IFlashAngle flashAngle) external returns (uint256 balance) {\n        balance = flashAngle.accrueInterestToTreasury(stablecoin);\n    }\n\n    function accrueInterestToTreasuryVaultManager(IVaultManager _vaultManager) external returns (uint256, uint256) {\n        return _vaultManager.accrueInterestToTreasury();\n    }\n}\n"
    },
    "contracts/mock/MockUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\ncontract MockUniswapV3Pool {\n    address public token0;\n    address public token1;\n    uint32 public constant EPOCH_DURATION = 24 * 3600 * 7;\n\n    function setToken(address token, uint256 who) external {\n        if (who == 0) token0 = token;\n        else token1 = token;\n    }\n\n    function round(uint256 amount) external pure returns (uint256) {\n        return (amount / EPOCH_DURATION) * EPOCH_DURATION;\n    }\n}\n"
    },
    "contracts/mock/MockVaultManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IVaultManager.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockVaultManager {\n    ITreasury public treasury;\n    mapping(uint256 => Vault) public vaultData;\n    mapping(uint256 => address) public ownerOf;\n    uint256 public surplus;\n    uint256 public badDebt;\n    IAgToken public token;\n    address public oracle = address(this);\n\n    address public governor;\n    address public collateral;\n    address public stablecoin;\n    uint256 public oracleValue;\n    uint256 public interestAccumulator;\n    uint256 public collateralFactor;\n    uint256 public totalNormalizedDebt;\n\n    constructor(address _treasury) {\n        treasury = ITreasury(_treasury);\n    }\n\n    function accrueInterestToTreasury() external returns (uint256, uint256) {\n        // Avoid the function to be view\n        if (surplus >= badDebt) {\n            token.mint(msg.sender, surplus - badDebt);\n        }\n        return (surplus, badDebt);\n    }\n\n    function read() external view returns (uint256) {\n        return oracleValue;\n    }\n\n    function setParams(\n        address _governor,\n        address _collateral,\n        address _stablecoin,\n        uint256 _oracleValue,\n        uint256 _interestAccumulator,\n        uint256 _collateralFactor,\n        uint256 _totalNormalizedDebt\n    ) external {\n        governor = _governor;\n        collateral = _collateral;\n        stablecoin = _stablecoin;\n        interestAccumulator = _interestAccumulator;\n        collateralFactor = _collateralFactor;\n        totalNormalizedDebt = _totalNormalizedDebt;\n        oracleValue = _oracleValue;\n    }\n\n    function setOwner(uint256 vaultID, address owner) external virtual {\n        ownerOf[vaultID] = owner;\n    }\n\n    function setVaultData(uint256 normalizedDebt, uint256 collateralAmount, uint256 vaultID) external {\n        vaultData[vaultID].normalizedDebt = normalizedDebt;\n        vaultData[vaultID].collateralAmount = collateralAmount;\n    }\n\n    function isGovernor(address admin) external view returns (bool) {\n        return admin == governor;\n    }\n\n    function setSurplusBadDebt(uint256 _surplus, uint256 _badDebt, IAgToken _token) external {\n        surplus = _surplus;\n        badDebt = _badDebt;\n        token = _token;\n    }\n\n    function getDebtOut(uint256 vaultID, uint256 amountStablecoins, uint256 senderBorrowFee) external {}\n\n    function setTreasury(address _treasury) external {\n        treasury = ITreasury(_treasury);\n    }\n\n    function getVaultDebt(uint256 vaultID) external view returns (uint256) {\n        vaultID;\n        token;\n        return 0;\n    }\n\n    function createVault(address toVault) external view returns (uint256) {\n        toVault;\n        token;\n        return 0;\n    }\n}\n\ncontract MockVaultManagerListing is MockVaultManager {\n    // @notice Mapping from owner address to all his vaults\n    mapping(address => uint256[]) internal _ownerListVaults;\n\n    constructor(address _treasury) MockVaultManager(_treasury) {}\n\n    function getUserVaults(address owner) public view returns (uint256[] memory) {\n        return _ownerListVaults[owner];\n    }\n\n    function getUserCollateral(address owner) public view returns (uint256 totalCollateral) {\n        uint256[] memory vaultList = _ownerListVaults[owner];\n        uint256 vaultListLength = vaultList.length;\n        for (uint256 k; k < vaultListLength; ++k) {\n            totalCollateral += vaultData[vaultList[k]].collateralAmount;\n        }\n        return totalCollateral;\n    }\n\n    function setOwner(uint256 vaultID, address owner) external override {\n        if (ownerOf[vaultID] != address(0)) _removeVaultFromList(ownerOf[vaultID], vaultID);\n        _ownerListVaults[owner].push(vaultID);\n        ownerOf[vaultID] = owner;\n    }\n\n    /// @notice Remove `vaultID` from `user` stroed vault list\n    /// @param user Address to look out for the vault list\n    /// @param vaultID VaultId to remove from the list\n    /// @dev The vault is necessarily in the list\n    function _removeVaultFromList(address user, uint256 vaultID) internal {\n        uint256[] storage vaultList = _ownerListVaults[user];\n        uint256 vaultListLength = vaultList.length;\n        for (uint256 i; i < vaultListLength - 1; ++i) {\n            if (vaultList[i] == vaultID) {\n                vaultList[i] = vaultList[vaultListLength - 1];\n                break;\n            }\n        }\n        vaultList.pop();\n    }\n}\n"
    },
    "contracts/mock/MockVeBoostProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../interfaces/governance/IVeBoostProxy.sol\";\n\ncontract MockVeBoostProxy is IVeBoostProxy {\n    //solhint-disable-next-line\n    mapping(address => uint256) public adjusted_balance_of;\n\n    constructor() {}\n\n    function setBalance(address concerned, uint256 balance) external {\n        adjusted_balance_of[concerned] = balance;\n    }\n}\n"
    },
    "contracts/oracle/BaseOracleChainlinkMulti.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n                  *                                                                                \n                *****                                                                            \n                  *                                                                        \n                                   *            ///.                                  \n                                 *****        ////////                                      \n                                   *       /////////////                                         \n                                       //////////////////                                      \n                                  ///////////////////////                                   \n                               ////////////////////////////                                 \n                              /////////////////////////                                \n                            ,//////////////////////////////////////                           \n                          //////////////////////////////////////////                           \n                        ///////////////////////////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////.,//////////////////////////                     \n                       .//////////////////////..,./////////////////////                       \n                        ...////////////////.....,.////////////////                        \n                          ,.,//////////// ........,///////////                          \n                            .,.,//////      ,.......///////                            \n                               ,..//           ........./                               \n                                 ..,                .....,                                 \n                                    .                     ,.,                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                   \n                                                                            \n                                                                          \n                                                            \n*/\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\n/// @title BaseOracleChainlinkMulti\n/// @author Angle Labs, Inc.\n/// @notice Base Contract to be overriden by all contracts of the protocol\n/// @dev This base contract concerns an oracle that uses Chainlink with multiple pools to read from\n/// @dev All gas-efficient implementation of the `OracleChainlinkMulti` contract should inherit from this\nabstract contract BaseOracleChainlinkMulti is IOracle {\n    // ========================= Parameters and References =========================\n\n    /// @inheritdoc IOracle\n    ITreasury public override treasury;\n    /// @notice Represent the maximum amount of time (in seconds) between each Chainlink update\n    /// before the price feed is considered stale\n    uint32 public stalePeriod;\n\n    // =================================== Event ===================================\n\n    event StalePeriodUpdated(uint32 _stalePeriod);\n\n    // =================================== Errors ===================================\n\n    error InvalidChainlinkRate();\n    error NotGovernorOrGuardian();\n    error NotVaultManagerOrGovernor();\n\n    /// @notice Constructor for an oracle using Chainlink with multiple pools to read from\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the VaultManager which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) {\n        stalePeriod = _stalePeriod;\n        treasury = ITreasury(_treasury);\n    }\n\n    // ============================= Reading Oracles ===============================\n\n    /// @inheritdoc IOracle\n    function read() external view virtual override returns (uint256 quoteAmount);\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public view virtual returns (AggregatorV3Interface[] memory);\n\n    /// @notice Reads a Chainlink feed using a quote amount and converts the quote amount to\n    /// the out-currency\n    /// @param quoteAmount The amount for which to compute the price expressed with base decimal\n    /// @param feed Chainlink feed to query\n    /// @param multiplied Whether the ratio outputted by Chainlink should be multiplied or divided\n    /// to the `quoteAmount`\n    /// @param decimals Number of decimals of the corresponding Chainlink pair\n    /// @return The `quoteAmount` converted in out-currency\n    function _readChainlinkFeed(\n        uint256 quoteAmount,\n        AggregatorV3Interface feed,\n        uint8 multiplied,\n        uint256 decimals\n    ) internal view returns (uint256) {\n        (uint80 roundId, int256 ratio, , uint256 updatedAt, uint80 answeredInRound) = feed.latestRoundData();\n        if (ratio <= 0 || roundId > answeredInRound || block.timestamp - updatedAt > stalePeriod)\n            revert InvalidChainlinkRate();\n        uint256 castedRatio = uint256(ratio);\n        // Checking whether we should multiply or divide by the ratio computed\n        if (multiplied == 1) return (quoteAmount * castedRatio) / (10 ** decimals);\n        else return (quoteAmount * (10 ** decimals)) / castedRatio;\n    }\n\n    // ======================= Governance Related Functions ========================\n\n    /// @notice Changes the stale period\n    /// @param _stalePeriod New stale period (in seconds)\n    function changeStalePeriod(uint32 _stalePeriod) external {\n        if (!treasury.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        stalePeriod = _stalePeriod;\n        emit StalePeriodUpdated(_stalePeriod);\n    }\n\n    /// @inheritdoc IOracle\n    function setTreasury(address _treasury) external override {\n        if (!treasury.isVaultManager(msg.sender) && !treasury.isGovernor(msg.sender))\n            revert NotVaultManagerOrGovernor();\n        treasury = ITreasury(_treasury);\n    }\n}\n"
    },
    "contracts/oracle/BaseOracleChainlinkMultiTwoFeeds.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"./BaseOracleChainlinkMulti.sol\";\n\n/// @title BaseOracleChainlinkMultiTwoFeeds\n/// @author Angle Labs, Inc.\n/// @notice Base contract for an oracle that reads into two Chainlink feeds (including an EUR/USD feed) which both have\n/// 8 decimals\nabstract contract BaseOracleChainlinkMultiTwoFeeds is BaseOracleChainlinkMulti {\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @notice Returns the quote amount of the oracle contract\n    function _getQuoteAmount() internal view virtual returns (uint256) {\n        return 10 ** 18;\n    }\n\n    /// @inheritdoc IOracle\n    function read() public view virtual override returns (uint256 quoteAmount) {\n        quoteAmount = _getQuoteAmount();\n        AggregatorV3Interface[] memory _circuitChainlink = circuitChainlink();\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        uint256 circuitLength = _circuitChainlink.length;\n        for (uint256 i; i < circuitLength; ++i) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                _circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/BaseOracleChainlinkOneFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"./BaseOracleChainlinkMulti.sol\";\n\n/// @title BaseOracleChainlinkOneFeed\n/// @author Angle Labs, Inc.\n/// @notice Base contract for an oracle that reads into one Chainlink feeds with 8 decimals\nabstract contract BaseOracleChainlinkOneFeed is BaseOracleChainlinkMulti {\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @notice Returns the quote amount of the oracle contract\n    function _getQuoteAmount() internal view virtual returns (uint256) {\n        return 10 ** 18;\n    }\n\n    /// @inheritdoc IOracle\n    function read() external view virtual override returns (uint256 quoteAmount) {\n        AggregatorV3Interface[] memory _circuitChainlink = circuitChainlink();\n        quoteAmount = _readChainlinkFeed(_getQuoteAmount(), _circuitChainlink[0], 1, 8);\n    }\n}\n"
    },
    "contracts/oracle/implementations/arbitrum/EUR/OracleBTCEURChainlinkArbitrum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleBTCEURChainlinkArbitrum\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of BTC in Euro in base 18\n/// @dev This contract is built to be deployed on Arbitrum\ncontract OracleBTCEURChainlinkArbitrum is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"BTC/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle BTC/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x6ce185860a4963106506C203335A2910413708e9);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0xA14d53bC1F1c0F31B4aA3BD109344E5009051a84);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/arbitrum/EUR/OracleETHEURChainlinkArbitrum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleETHEURChainlinkArbitrum\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of ETH in Euro in base 18\n/// @dev This contract is built to be deployed on Arbitrum\ncontract OracleETHEURChainlinkArbitrum is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"ETH/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle ETH/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0xA14d53bC1F1c0F31B4aA3BD109344E5009051a84);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/arbitrum/EUR/OracleSTEURETHChainlinkArbitrum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\nimport \"../../../../interfaces/external/IERC4626.sol\";\n\n/// @title OracleSTEURETHChainlinkArbitrum\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of stEUR in ETH in base 18\ncontract OracleSTEURETHChainlinkArbitrum is BaseOracleChainlinkMultiTwoFeeds, AggregatorV3Interface {\n    string public constant DESCRIPTION = \"stEUR/ETH Oracle\";\n    IERC4626 public constant STEUR = IERC4626(0x004626A008B1aCdC4c74ab51644093b155e59A23);\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle agEUR/USD - Redstone\n        _circuitChainlink[0] = AggregatorV3Interface(0x37963F10245e7c3a10c0E9d43a6E617B4Bc8440A);\n        // Oracle ETH/USD - Chainlink\n        _circuitChainlink[1] = AggregatorV3Interface(0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612);\n        return _circuitChainlink;\n    }\n\n    /// @inheritdoc BaseOracleChainlinkMultiTwoFeeds\n    function _getQuoteAmount() internal view override returns (uint256) {\n        return STEUR.convertToAssets(1 ether);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                           CHAINLINK INTERFACE COMPATIBILITY                                        \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc AggregatorV3Interface\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc AggregatorV3Interface\n    function description() external pure returns (string memory desc) {\n        desc = \"Angle stEUR/ETH Price Feed\";\n    }\n\n    /// @inheritdoc AggregatorV3Interface\n    function version() external pure returns (uint256) {\n        return 1;\n    }\n\n    /// @inheritdoc AggregatorV3Interface\n    /// @return roundID\n    /// @return aggregatorPrice\n    /// @return startedAt\n    /// @return timestamp\n    /// @return answeredInRound\n    /// @dev The `roundId`, `startedAt` and `answeredInRound` values return in this function must be disregarded\n    /// @dev In order not to multiply oracle calls, the timestamp returned here is the `block.timestamp`.\n    /// The contract still performs an heartbeat check for every oracle value that it reads, and the accurate\n    /// value of the `timestamp` (if this one is taken as the minimum between the last update timestamp\n    /// of the two oracles) is between: current timestamp and the current timestamp minus `stalePeriod`\n    function latestRoundData() public view returns (uint80, int256, uint256, uint256, uint80) {\n        return (0, int256(read()), 0, block.timestamp, 0);\n    }\n\n    /// @inheritdoc AggregatorV3Interface\n    /// @dev This function always returns the latestRoundData\n    function getRoundData(uint80) external view returns (uint80, int256, uint256, uint256, uint80) {\n        return latestRoundData();\n    }\n}\n"
    },
    "contracts/oracle/implementations/arbitrum/EUR/OracleUSDCEURChainlinkArbitrum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleUSDCEURChainlinkArbitrum\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of USDC in Euro in base 18\n/// @dev This contract is built to be deployed on Arbitrum\ncontract OracleUSDCEURChainlinkArbitrum is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"USDC/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle ETH/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x50834F3163758fcC1Df9973b6e91f0F0F0434aD3);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0xA14d53bC1F1c0F31B4aA3BD109344E5009051a84);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/avalanche/EUR/OracleAVAXEURChainlinkAvalanche.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleAVAXEURChainlinkAvalanche\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of AVAX in Euro in base 18\n/// @dev This contract is built to be deployed on Avalanche\ncontract OracleAVAXEURChainlinkAvalanche is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"AVAX/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle AVAX/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x0A77230d17318075983913bC2145DB16C7366156);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x192f2DBA961Bb0277520C082d6bfa87D5961333E);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/avalanche/EUR/OracleUSDCEURChainlinkAvalanche.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleUSDCEURChainlinkAvalanche\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of USDC in Euro in base 18\n/// @dev This contract is built to be deployed on Avalanche\ncontract OracleUSDCEURChainlinkAvalanche is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"USDC/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle USDC/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0xF096872672F44d6EBA71458D74fe67F9a77a23B9);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x192f2DBA961Bb0277520C082d6bfa87D5961333E);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/EUR/OracleBTCEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleBTCEURChainlink\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of BTC in Euro in base 18\ncontract OracleBTCEURChainlink is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"BTC/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle BTC/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/EUR/OracleCBETHEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleCBETHEURChainlink\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of cbETH in Euro in base 18\ncontract OracleCBETHEURChainlink is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"cbETH/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](3);\n        // Oracle cbETH/ETH\n        _circuitChainlink[0] = AggregatorV3Interface(0xF017fcB346A1885194689bA23Eff2fE6fA5C483b);\n        // Oracle ETH/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n        // Oracle EUR/USD\n        _circuitChainlink[2] = AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\n        return _circuitChainlink;\n    }\n\n    /// @inheritdoc BaseOracleChainlinkMultiTwoFeeds\n    function read() public view virtual override returns (uint256 quoteAmount) {\n        quoteAmount = _getQuoteAmount();\n        AggregatorV3Interface[] memory _circuitChainlink = circuitChainlink();\n        uint8[3] memory circuitChainIsMultiplied = [1, 1, 0];\n        uint8[3] memory chainlinkDecimals = [18, 8, 8];\n        uint256 circuitLength = _circuitChainlink.length;\n        for (uint256 i; i < circuitLength; ++i) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                _circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/EUR/OracleETHEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleETHEURChainlink\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of ETH in Euro in base 18\ncontract OracleETHEURChainlink is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"ETH/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle ETH/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/EUR/OracleHIGHEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleHIGHEURChainlink\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of HIGH in Euro in base 18\ncontract OracleHIGHEURChainlink is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"HIGH/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](1);\n        // Oracle HIGH/EUR\n        _circuitChainlink[0] = AggregatorV3Interface(0x9E8E794ad6Ecdb6d5c7eaBE059D30E907F58859b);\n        return _circuitChainlink;\n    }\n\n    /// @inheritdoc BaseOracleChainlinkMultiTwoFeeds\n    function read() public view override returns (uint256 quoteAmount) {\n        quoteAmount = _readChainlinkFeed(_getQuoteAmount(), circuitChainlink()[0], 1, 8);\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/EUR/OracleIB01EURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleIB01EURChainlink\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of IB01 in Euro in base 18\ncontract OracleIB01EURChainlink is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"IB01/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle IB01/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x32d1463EB53b73C095625719Afa544D5426354cB);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/EUR/OracleLUSDEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleLUSDEURChainlink\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of LUSD in Euro in base 18\ncontract OracleLUSDEURChainlink is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"LUSD/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle LUSD/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x3D7aE7E594f2f2091Ad8798313450130d0Aba3a0);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/EUR/OracleUSDCEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleUSDCEURChainlink\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of USDC in Euro in base 18\ncontract OracleUSDCEURChainlink is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"USDC/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle USDC/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/EUR/OracleWSTETHEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\nimport \"../../../../interfaces/external/lido/IStETH.sol\";\n\n/// @title OracleWSTETHEURChainlink\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of wSTETH in Euro in base 18\ncontract OracleWSTETHEURChainlink is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"wSTETH/EUR Oracle\";\n    IStETH public constant STETH = IStETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle stETH/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0xCfE54B5cD566aB89272946F602D76Ea879CAb4a8);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\n        return _circuitChainlink;\n    }\n\n    /// @inheritdoc BaseOracleChainlinkMultiTwoFeeds\n    function _getQuoteAmount() internal view override returns (uint256) {\n        return STETH.getPooledEthByShares(1 ether);\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/USD/OracleWSTETHUSDChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkOneFeed.sol\";\nimport \"../../../../interfaces/external/lido/IStETH.sol\";\n\n/// @title OracleWSTETHUSDChainlink\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of wSTETH in USD in base 18\ncontract OracleWSTETHUSDChainlink is BaseOracleChainlinkOneFeed {\n    string public constant DESCRIPTION = \"wSTETH/USD Oracle\";\n    IStETH public constant STETH = IStETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkOneFeed(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](1);\n        // Oracle stETH/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0xCfE54B5cD566aB89272946F602D76Ea879CAb4a8);\n        return _circuitChainlink;\n    }\n\n    /// @inheritdoc BaseOracleChainlinkOneFeed\n    function _getQuoteAmount() internal view override returns (uint256) {\n        return STETH.getPooledEthByShares(1 ether);\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/XAU/OracleETHXAUChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleETHXAUChainlink\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of ETH in XAU in base 18\ncontract OracleETHXAUChainlink is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"ETH/GOLD Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle ETH/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n        // Oracle XAU/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x214eD9Da11D2fbe465a6fc601a91E62EbEc1a0D6);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/XAU/OracleLUSDXAUChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleLUSDXAUChainlink\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of LUSD in XAU in base 18\ncontract OracleLUSDXAUChainlink is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"LUSD/GOLD Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle LUSD/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x3D7aE7E594f2f2091Ad8798313450130d0Aba3a0);\n        // Oracle XAU/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x214eD9Da11D2fbe465a6fc601a91E62EbEc1a0D6);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/XAU/OracleUSDCXAUChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleUSDCXAUChainlink\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of USDC in XAU in base 18\ncontract OracleUSDCXAUChainlink is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"USDC/GOLD Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle USDC/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\n        // Oracle XAU/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x214eD9Da11D2fbe465a6fc601a91E62EbEc1a0D6);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/mainnet/XAU/OracleWSTETHXAUChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\nimport \"../../../../interfaces/external/lido/IStETH.sol\";\n\n/// @title OracleWSTETHXAUChainlink\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of wSTETH in XAU in base 18\ncontract OracleWSTETHXAUChainlink is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"wSTETH/XAU Oracle\";\n    IStETH public constant STETH = IStETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle stETH/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0xCfE54B5cD566aB89272946F602D76Ea879CAb4a8);\n        // Oracle XAU/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x214eD9Da11D2fbe465a6fc601a91E62EbEc1a0D6);\n        return _circuitChainlink;\n    }\n\n    /// @inheritdoc BaseOracleChainlinkMultiTwoFeeds\n    function _getQuoteAmount() internal view override returns (uint256) {\n        return STETH.getPooledEthByShares(1 ether);\n    }\n}\n"
    },
    "contracts/oracle/implementations/optimism/EUR/OracleETHEURChainlinkOptimism.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleETHEURChainlinkOptimism\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of ETH in Euro in base 18\n/// @dev This contract is built to be deployed on Optimism\ncontract OracleETHEURChainlinkOptimism is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"ETH/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle ETH/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x13e3Ee699D1909E989722E753853AE30b17e08c5);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x3626369857A10CcC6cc3A6e4f5C2f5984a519F20);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/optimism/EUR/OracleOPEURChainlinkOptimism.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleOPEURChainlinkOptimism\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of OP in Euro in base 18\n/// @dev This contract is built to be deployed on Optimism\ncontract OracleOPEURChainlinkOptimism is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"OP/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle OP/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x0D276FC14719f9292D5C1eA2198673d1f4269246);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x3626369857A10CcC6cc3A6e4f5C2f5984a519F20);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/optimism/EUR/OracleUSDCEURChainlinkOptimism.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleUSDCEURChainlinkOptimism\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of USDC in Euro in base 18\n/// @dev This contract is built to be deployed on Optimism\ncontract OracleUSDCEURChainlinkOptimism is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"USDC/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle USDC/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0x16a9FA2FDa030272Ce99B29CF780dFA30361E0f3);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x3626369857A10CcC6cc3A6e4f5C2f5984a519F20);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/polygon/EUR/OracleBTCEURChainlinkPolygon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleBTCEURChainlinkPolygon\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of BTC in Euro in base 18\n/// @dev This contract is built to be deployed on Polygon\ncontract OracleBTCEURChainlinkPolygon is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"BTC/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle BTC/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0xc907E116054Ad103354f2D350FD2514433D57F6f);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x73366Fe0AA0Ded304479862808e02506FE556a98);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/polygon/EUR/OracleETHEURChainlinkPolygon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleETHEURChainlinkPolygon\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of ETH in Euro in base 18\n/// @dev This contract is built to be deployed on Polygon\ncontract OracleETHEURChainlinkPolygon is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"ETH/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle ETH/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0xF9680D99D6C9589e2a93a78A04A279e509205945);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x73366Fe0AA0Ded304479862808e02506FE556a98);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/polygon/EUR/OracleMAIEURChainlinkPolygon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleMAIEURChainlinkPolygon\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of MAI in Euro in base 18\n/// @dev This contract is built to be deployed on Polygon\ncontract OracleMAIEURChainlinkPolygon is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"MAI/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle MAI/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0xd8d483d813547CfB624b8Dc33a00F2fcbCd2D428);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x73366Fe0AA0Ded304479862808e02506FE556a98);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/polygon/EUR/OracleMATICEURChainlinkPolygon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleMATICEURChainlinkPolygon\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of MATIC in Euro in base 18\n/// @dev This contract is built to be deployed on Polygon\ncontract OracleMATICEURChainlinkPolygon is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"MATIC/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle MATIC/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0xAB594600376Ec9fD91F8e885dADF0CE036862dE0);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x73366Fe0AA0Ded304479862808e02506FE556a98);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/polygon/EUR/OracleUSDCEURChainlinkPolygon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleUSDCEURChainlinkPolygon\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of USDC in Euro in base 18\n/// @dev This contract is built to be deployed on Polygon\ncontract OracleUSDCEURChainlinkPolygon is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"USDC/EUR Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle USDC/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0xfE4A8cc5b5B2366C1B58Bea3858e81843581b2F7);\n        // Oracle EUR/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x73366Fe0AA0Ded304479862808e02506FE556a98);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/implementations/polygon/XAU/OracleETHXAUChainlinkPolygon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../BaseOracleChainlinkMultiTwoFeeds.sol\";\n\n/// @title OracleETHXAUChainlinkPolygon\n/// @author Angle Labs, Inc.\n/// @notice Gives the price of ETH in XAU in base 18\n/// @dev This contract is built to be deployed on Polygon\ncontract OracleETHXAUChainlinkPolygon is BaseOracleChainlinkMultiTwoFeeds {\n    string public constant DESCRIPTION = \"ETH/GOLD Oracle\";\n\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMultiTwoFeeds(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public pure override returns (AggregatorV3Interface[] memory) {\n        AggregatorV3Interface[] memory _circuitChainlink = new AggregatorV3Interface[](2);\n        // Oracle ETH/USD\n        _circuitChainlink[0] = AggregatorV3Interface(0xF9680D99D6C9589e2a93a78A04A279e509205945);\n        // Oracle XAU/USD\n        _circuitChainlink[1] = AggregatorV3Interface(0x0C466540B2ee1a31b441671eac0ca886e051E410);\n        return _circuitChainlink;\n    }\n}\n"
    },
    "contracts/oracle/KeeperRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/IKeeperRegistry.sol\";\n\n/// @title KeeperRegistry\n/// @notice Maintains a mapping of keepers authorized to use the core module just after oracle updates\n/// @author Angle Labs, Inc.\ncontract KeeperRegistry is Initializable, IKeeperRegistry {\n    using SafeERC20 for IERC20;\n\n    /// @notice Contract handling access control\n    ICoreBorrow public coreBorrow;\n\n    /// @notice Trusted EOAs - needs to be tx.origin\n    mapping(address => uint256) public trusted;\n\n    uint256[48] private __gap;\n\n    // =================================== EVENTS ==================================\n\n    event TrustedToggled(address indexed wallet, bool trust);\n\n    // =================================== ERRORS ==================================\n\n    error NotGovernorOrGuardian();\n    error NotTrusted();\n    error ZeroAddress();\n\n    // ================================= MODIFIERS =================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!coreBorrow.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    // ================================ CONSTRUCTOR ================================\n\n    constructor() initializer {}\n\n    function initialize(ICoreBorrow _coreBorrow) public initializer {\n        if (address(_coreBorrow) == address(0)) revert ZeroAddress();\n        coreBorrow = _coreBorrow;\n    }\n\n    // =============================== MAIN FUNCTIONS ==============================\n\n    /// @notice Adds or removes a trusted keeper bot\n    function toggleTrusted(address eoa) external onlyGovernorOrGuardian {\n        uint256 trustedStatus = 1 - trusted[eoa];\n        trusted[eoa] = trustedStatus;\n        emit TrustedToggled(eoa, trustedStatus == 1);\n    }\n\n    /// @inheritdoc IKeeperRegistry\n    function isTrusted(address caller) external view returns (bool) {\n        return trusted[caller] == 1;\n    }\n}\n"
    },
    "contracts/oracle/OracleChainlinkMulti.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"./BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleChainlinkMulti\n/// @author Angle Labs, Inc.\n/// @notice Oracle contract, one contract is deployed per collateral/stablecoin pair\n/// @dev This contract concerns an oracle that uses Chainlink with multiple pools to read from\n/// @dev Typically we expect to use this contract to read like the ETH/USD and then USD/EUR feed\ncontract OracleChainlinkMulti is BaseOracleChainlinkMulti {\n    // ========================= Parameters and References =========================\n\n    /// @notice Chainlink pools, the order of the pools has to be the order in which they are read for the computation\n    /// of the price\n    AggregatorV3Interface[] internal _circuitChainlink;\n    /// @notice Whether each rate for the pairs in `circuitChainlink` should be multiplied or divided\n    uint8[] public circuitChainIsMultiplied;\n    /// @notice Decimals for each Chainlink pairs\n    uint8[] public chainlinkDecimals;\n    /// @notice Unit of the stablecoin\n    uint256 public immutable outBase;\n    /// @notice Description of the assets concerned by the oracle and the price outputted\n    string public description;\n\n    // ===================================== Error =================================\n\n    error IncompatibleLengths();\n\n    /// @notice Constructor for an oracle using Chainlink with multiple pools to read from\n    /// @param circuitChainlink_ Chainlink pool addresses (in order)\n    /// @param _circuitChainIsMultiplied Whether we should multiply or divide by this rate\n    /// @param _outBase Unit of the stablecoin (or the out asset) associated to the oracle\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the VaultManager which reads from this feed\n    /// @param _description Description of the assets concerned by the oracle\n    /// @dev For instance, if this oracle is supposed to give the price of ETH in EUR, and if the agEUR\n    /// stablecoin associated to EUR has 18 decimals, then `outBase` should be 10**18\n    constructor(\n        address[] memory circuitChainlink_,\n        uint8[] memory _circuitChainIsMultiplied,\n        uint256 _outBase,\n        uint32 _stalePeriod,\n        address _treasury,\n        string memory _description\n    ) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {\n        outBase = _outBase;\n        description = _description;\n        uint256 circuitLength = circuitChainlink_.length;\n        if (circuitLength == 0 || circuitLength != _circuitChainIsMultiplied.length) revert IncompatibleLengths();\n        for (uint256 i; i < circuitLength; ++i) {\n            AggregatorV3Interface _pool = AggregatorV3Interface(circuitChainlink_[i]);\n            _circuitChainlink.push(_pool);\n            chainlinkDecimals.push(_pool.decimals());\n        }\n        circuitChainIsMultiplied = _circuitChainIsMultiplied;\n    }\n\n    // ============================= Reading Oracles ===============================\n\n    /// @inheritdoc IOracle\n    function circuitChainlink() public view override returns (AggregatorV3Interface[] memory) {\n        return _circuitChainlink;\n    }\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = outBase;\n        uint256 circuitLength = _circuitChainlink.length;\n        for (uint256 i; i < circuitLength; ++i) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                _circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/settlement/Settlement.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ISwapper.sol\";\nimport \"../interfaces/IVaultManager.sol\";\n\n/// @title Settlement\n/// @author Angle Labs, Inc.\n/// @notice Settlement Contract for a VaultManager\n/// @dev This settlement contract should be activated by a careful governance which needs to have performed\n/// some key operations before activating this contract\n/// @dev In case of global settlement, there should be one settlement contract per `VaultManager`\ncontract Settlement {\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_PARAMS = 10 ** 9;\n    /// @notice Base used for interest computation\n    uint256 public constant BASE_INTEREST = 10 ** 27;\n    /// @notice Base used for exchange rate computation. It is assumed\n    /// that stablecoins have this base\n    uint256 public constant BASE_STABLECOIN = 10 ** 18;\n    /// @notice Duration of the claim period for over-collateralized vaults\n    uint256 public constant OVER_COLLATERALIZED_CLAIM_DURATION = 3 * 24 * 3600;\n\n    // =============== Immutable references set in the constructor =================\n\n    /// @notice `VaultManager` of this settlement contract\n    IVaultManager public immutable vaultManager;\n    /// @notice Reference to the stablecoin supported by the `VaultManager` contract\n    IAgToken public immutable stablecoin;\n    /// @notice Reference to the collateral supported by the `VaultManager`\n    IERC20 public immutable collateral;\n    /// @notice Base of the collateral\n    uint256 internal immutable _collatBase;\n\n    // ================ Variables frozen at settlement activation ==================\n\n    /// @notice Value of the oracle for the collateral/stablecoin pair\n    uint256 public oracleValue;\n    /// @notice Value of the interest accumulator at settlement activation\n    uint256 public interestAccumulator;\n    /// @notice Timestamp at which settlement was activated\n    uint256 public activationTimestamp;\n    /// @notice Collateral factor of the `VaultManager`\n    uint64 public collateralFactor;\n\n    // =================== Variables updated during the process ====================\n\n    /// @notice How much collateral you can get from stablecoins\n    uint256 public collateralStablecoinExchangeRate;\n    /// @notice Amount of collateral that will be left over at the end of the process\n    uint256 public leftOverCollateral;\n    /// @notice Whether the `collateralStablecoinExchangeRate` has been computed\n    bool public exchangeRateComputed;\n    /// @notice Maps a vault to 1 if it was claimed by its owner\n    mapping(uint256 => uint256) public vaultCheck;\n\n    // ================================ Events =====================================\n\n    event GlobalClaimPeriodActivated(uint256 _collateralStablecoinExchangeRate);\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n    event SettlementActivated(uint256 startTimestamp);\n    event VaultClaimed(uint256 vaultID, uint256 stablecoinAmount, uint256 collateralAmount);\n\n    // ================================ Errors =====================================\n\n    error GlobalClaimPeriodNotStarted();\n    error InsolventVault();\n    error NotGovernor();\n    error NotOwner();\n    error RestrictedClaimPeriodNotEnded();\n    error SettlementNotInitialized();\n    error VaultAlreadyClaimed();\n\n    /// @notice Constructor of the contract\n    /// @param _vaultManager Address of the `VaultManager` associated to this `Settlement` contract\n    /// @dev Out of safety, this constructor reads values from the `VaultManager` contract directly\n    constructor(IVaultManager _vaultManager) {\n        vaultManager = _vaultManager;\n        stablecoin = _vaultManager.stablecoin();\n        collateral = _vaultManager.collateral();\n        _collatBase = 10 ** (IERC20Metadata(address(collateral)).decimals());\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!(vaultManager.treasury().isGovernor(msg.sender))) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Activates the settlement contract\n    /// @dev When calling this function governance should make sure to have:\n    /// 1. Accrued the interest rate on the contract\n    /// 2. Paused the contract\n    /// 3. Recovered all the collateral available in the `VaultManager` contract either\n    /// by doing a contract upgrade or by calling a `recoverERC20` method if supported\n    function activateSettlement() external onlyGovernor {\n        oracleValue = (vaultManager.oracle()).read();\n        interestAccumulator = vaultManager.interestAccumulator();\n        activationTimestamp = block.timestamp;\n        collateralFactor = vaultManager.collateralFactor();\n        emit SettlementActivated(block.timestamp);\n    }\n\n    /// @notice Allows the owner of an over-collateralized vault to claim its collateral upon bringing back all owed stablecoins\n    /// @param vaultID ID of the vault to claim\n    /// @param to Address to which collateral should be sent\n    /// @param who Address which should be notified if needed of the transfer of stablecoins and collateral\n    /// @param data Data to pass to the `who` contract for it to successfully give the correct amount of stablecoins\n    /// to the `msg.sender` address\n    /// @return Amount of collateral sent to the `to` address\n    /// @return Amount of stablecoins sent to the contract\n    /// @dev Claiming can only happen short after settlement activation\n    /// @dev A vault cannot be claimed twice and only the owner of the vault can claim it (regardless of the approval logic)\n    /// @dev Only over-collateralized vaults can be claimed from this medium\n    function claimOverCollateralizedVault(\n        uint256 vaultID,\n        address to,\n        address who,\n        bytes memory data\n    ) external returns (uint256, uint256) {\n        if (activationTimestamp == 0 || block.timestamp > activationTimestamp + OVER_COLLATERALIZED_CLAIM_DURATION)\n            revert SettlementNotInitialized();\n        if (vaultCheck[vaultID] == 1) revert VaultAlreadyClaimed();\n        if (vaultManager.ownerOf(vaultID) != msg.sender) revert NotOwner();\n        (uint256 collateralAmount, uint256 normalizedDebt) = vaultManager.vaultData(vaultID);\n        uint256 vaultDebt = (normalizedDebt * interestAccumulator) / BASE_INTEREST;\n        if (collateralAmount * oracleValue * collateralFactor < vaultDebt * BASE_PARAMS * _collatBase)\n            revert InsolventVault();\n        vaultCheck[vaultID] = 1;\n        emit VaultClaimed(vaultID, vaultDebt, collateralAmount);\n        return _handleRepay(collateralAmount, vaultDebt, to, who, data);\n    }\n\n    /// @notice Activates the global claim period by setting the `collateralStablecoinExchangeRate` which is going to\n    /// dictate how much of collateral will be recoverable for each stablecoin\n    /// @dev This function can only be called by the governor in order to allow it in case multiple settlements happen across\n    /// different `VaultManager` to rebalance the amount of stablecoins on each to make sure that across all settlement contracts\n    /// a similar value of collateral can be obtained against a similar value of stablecoins\n    function activateGlobalClaimPeriod() external onlyGovernor {\n        if (activationTimestamp == 0 || block.timestamp <= activationTimestamp + OVER_COLLATERALIZED_CLAIM_DURATION)\n            revert RestrictedClaimPeriodNotEnded();\n        uint256 collateralBalance = collateral.balanceOf(address(this));\n        uint256 leftOverDebt = (vaultManager.totalNormalizedDebt() * interestAccumulator) / BASE_INTEREST;\n        uint256 stablecoinBalance = stablecoin.balanceOf(address(this));\n        // How much 1 of stablecoin will give you in collateral\n        uint256 _collateralStablecoinExchangeRate;\n\n        if (stablecoinBalance < leftOverDebt) {\n            // The left over debt is the total debt minus the stablecoins which have already been accumulated\n            // in the first phase\n            leftOverDebt -= stablecoinBalance;\n            // If you control all the debt, then you are entitled to get all the collateral left in the protocol\n            _collateralStablecoinExchangeRate = (collateralBalance * BASE_STABLECOIN) / leftOverDebt;\n            // But at the same time, you cannot get more collateral than the value of the stablecoins you brought\n            uint256 maxExchangeRate = (BASE_STABLECOIN * _collatBase) / oracleValue;\n            if (_collateralStablecoinExchangeRate >= maxExchangeRate) {\n                // In this situation, we're sure that `leftOverCollateral` will be positive: governance should be wary\n                // to call `recoverERC20` short after though as there's nothing that is going to prevent people to redeem\n                // more stablecoins than the `leftOverDebt`\n                leftOverCollateral = collateralBalance - (leftOverDebt * _collatBase) / oracleValue;\n                _collateralStablecoinExchangeRate = maxExchangeRate;\n            }\n        }\n        exchangeRateComputed = true;\n        // In the else case where there is no debt left, you cannot get anything from your stablecoins\n        // and so the `collateralStablecoinExchangeRate` is null\n        collateralStablecoinExchangeRate = _collateralStablecoinExchangeRate;\n        emit GlobalClaimPeriodActivated(_collateralStablecoinExchangeRate);\n    }\n\n    /// @notice Allows to claim collateral from stablecoins\n    /// @param to Address to which collateral should be sent\n    /// @param who Address which should be notified if needed of the transfer of stablecoins and collateral\n    /// @param data Data to pass to the `who` contract for it to successfully give the correct amount of stablecoins\n    /// to the `msg.sender` address\n    /// @return Amount of collateral sent to the `to` address\n    /// @return Amount of stablecoins sent to the contract\n    /// @dev This function reverts if the `collateralStablecoinExchangeRate` is null and hence if the global claim period has\n    /// not been activated\n    function claimCollateralFromStablecoins(\n        uint256 stablecoinAmount,\n        address to,\n        address who,\n        bytes memory data\n    ) external returns (uint256, uint256) {\n        if (!exchangeRateComputed) revert GlobalClaimPeriodNotStarted();\n        return\n            _handleRepay(\n                (stablecoinAmount * collateralStablecoinExchangeRate) / BASE_STABLECOIN,\n                stablecoinAmount,\n                to,\n                who,\n                data\n            );\n    }\n\n    /// @notice Handles the simultaneous repayment of stablecoins with a transfer of collateral\n    /// @param collateralAmountToGive Amount of collateral the contract should give\n    /// @param stableAmountToRepay Amount of stablecoins the contract should burn from the call\n    /// @param to Address to which stablecoins should be sent\n    /// @param who Address which should be notified if needed of the transfer\n    /// @param data Data to pass to the `who` contract for it to successfully give the correct amount of stablecoins\n    /// to the `msg.sender` address\n    /// @dev This function allows for capital-efficient claims of collateral from stablecoins\n    function _handleRepay(\n        uint256 collateralAmountToGive,\n        uint256 stableAmountToRepay,\n        address to,\n        address who,\n        bytes memory data\n    ) internal returns (uint256, uint256) {\n        collateral.safeTransfer(to, collateralAmountToGive);\n        if (data.length != 0) {\n            ISwapper(who).swap(\n                collateral,\n                IERC20(address(stablecoin)),\n                msg.sender,\n                stableAmountToRepay,\n                collateralAmountToGive,\n                data\n            );\n        }\n        stablecoin.transferFrom(msg.sender, address(this), stableAmountToRepay);\n        return (collateralAmountToGive, stableAmountToRepay);\n    }\n\n    /// @notice Recovers leftover tokens from the contract or tokens that were mistakenly sent to the contract\n    /// @param tokenAddress Address of the token to recover\n    /// @param to Address to send the remaining tokens to\n    /// @param amountToRecover Amount to recover from the contract\n    /// @dev Governors cannot recover more collateral than what would be leftover from the contract\n    /// @dev This function can be used to rebalance stablecoin balances across different settlement contracts\n    /// to make sure every stablecoin can be redeemed for the same value of collateral\n    /// @dev It can also be used to recover tokens that are mistakenly sent to this contract\n    function recoverERC20(address tokenAddress, address to, uint256 amountToRecover) external onlyGovernor {\n        if (tokenAddress == address(collateral)) {\n            if (!exchangeRateComputed) revert GlobalClaimPeriodNotStarted();\n            leftOverCollateral -= amountToRecover;\n            collateral.safeTransfer(to, amountToRecover);\n        } else {\n            IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        }\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n}\n"
    },
    "contracts/swapper/Swapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n                  *                                                                                \n                *****                                                                            \n                  *                                                                        \n                                   *            ///.                                  \n                                 *****        ////////                                      \n                                   *       /////////////                                         \n                                       //////////////////                                      \n                                  ///////////////////////                                   \n                               ////////////////////////////                                 \n                              /////////////////////////                                \n                            ,//////////////////////////////////////                           \n                          //////////////////////////////////////////                           \n                        ///////////////////////////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////.,//////////////////////////                     \n                       .//////////////////////..,./////////////////////                       \n                        ...////////////////.....,.////////////////                        \n                          ,.,//////////// ........,///////////                          \n                            .,.,//////      ,.......///////                            \n                               ,..//           ........./                               \n                                 ..,                .....,                                 \n                                    .                     ,.,                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                   \n                                                                            \n                                                                          \n                                                            \n*/\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IAngleRouterSidechain.sol\";\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/ISwapper.sol\";\nimport \"../interfaces/external/lido/IWStETH.sol\";\nimport \"../interfaces/external/uniswap/IUniswapRouter.sol\";\n\n// ==================================== ENUM ===================================\n\n/// @notice All possible swaps\nenum SwapType {\n    UniswapV3,\n    oneInch,\n    AngleRouter,\n    Leverage,\n    None\n}\n\n/// @title Swapper\n/// @author Angle Labs, Inc.\n/// @notice Swapper contract facilitating interactions with Angle VaultManager contracts, notably\n/// liquidation and leverage transactions\ncontract Swapper is ISwapper {\n    using SafeERC20 for IERC20;\n\n    // ===================== CONSTANTS AND IMMUTABLE VARIABLES =====================\n\n    /// @notice Reference to the `CoreBorrow` contract of the module which handles all AccessControl logic\n    ICoreBorrow public immutable core;\n    /// @notice Uniswap Router contract\n    IUniswapV3Router public immutable uniV3Router;\n    /// @notice 1inch Router\n    address public immutable oneInch;\n    /// @notice AngleRouter\n    IAngleRouterSidechain public immutable angleRouter;\n\n    // =================================== ERRORS ==================================\n\n    error EmptyReturnMessage();\n    error IncompatibleLengths();\n    error NotGovernorOrGuardian();\n    error TooSmallAmountOut();\n    error ZeroAddress();\n\n    /// @notice Constructor of the contract\n    /// @param _core Core address\n    /// @param _uniV3Router UniswapV3 Router address\n    /// @param _oneInch 1inch Router address\n    /// @param _angleRouter AngleRouter contract address\n    constructor(\n        ICoreBorrow _core,\n        IUniswapV3Router _uniV3Router,\n        address _oneInch,\n        IAngleRouterSidechain _angleRouter\n    ) {\n        if (address(_core) == address(0) || _oneInch == address(0) || address(_angleRouter) == address(0))\n            revert ZeroAddress();\n        core = _core;\n        uniV3Router = _uniV3Router;\n        oneInch = _oneInch;\n        angleRouter = _angleRouter;\n    }\n\n    // ========================= EXTERNAL ACCESS FUNCTIONS =========================\n\n    /// @inheritdoc ISwapper\n    /// @dev This function swaps the `inToken` to the `outToken` by doing a UniV3 swap, a 1inch swap or by interacting\n    /// with the `AngleRouter` contract\n    /// @dev One slippage check is performed at the end of the call\n    /// @dev In this implementation, the function tries to make sure that the `outTokenRecipient` address has at the end\n    /// of the call `outTokenOwed`, leftover tokens are sent to a `to` address which by default is the `outTokenRecipient`\n    function swap(\n        IERC20 inToken,\n        IERC20 outToken,\n        address outTokenRecipient,\n        uint256 outTokenOwed,\n        uint256 inTokenObtained,\n        bytes memory data\n    ) external {\n        // Address to receive the surplus amount of token at the end of the call\n        address to;\n        // For slippage protection, it is checked at the end of the call\n        uint256 minAmountOut;\n        // Type of the swap to execute: if `swapType == 4`, then it is optional to swap\n        uint256 swapType;\n        // We're reusing the `data` variable (it can be `path` on UniswapV3, a payload for 1inch or like encoded actions\n        // for a router call)\n        (to, minAmountOut, swapType, data) = abi.decode(data, (address, uint256, uint256, bytes));\n\n        to = (to == address(0)) ? outTokenRecipient : to;\n\n        _swap(inToken, inTokenObtained, SwapType(swapType), data);\n\n        // A final slippage check is performed after the swaps\n        uint256 outTokenBalance = outToken.balanceOf(address(this));\n        if (outTokenBalance < minAmountOut) revert TooSmallAmountOut();\n\n        // The `outTokenRecipient` may already have enough in balance, in which case there's no need to transfer\n        // to this address the token and everything can be given to the `to` address\n        uint256 outTokenBalanceRecipient = outToken.balanceOf(outTokenRecipient);\n        if (outTokenBalanceRecipient >= outTokenOwed || to == outTokenRecipient)\n            outToken.safeTransfer(to, outTokenBalance);\n        else {\n            // The `outTokenRecipient` should receive the delta to make sure its end balance is equal to `outTokenOwed`\n            // Any leftover in this case is sent to the `to` address\n            // The function reverts if it did not obtain more than `outTokenOwed - outTokenBalanceRecipient` from the swap\n            outToken.safeTransfer(outTokenRecipient, outTokenOwed - outTokenBalanceRecipient);\n            outToken.safeTransfer(to, outTokenBalanceRecipient + outTokenBalance - outTokenOwed);\n        }\n        // Reusing the `inTokenObtained` variable for the `inToken` balance\n        // Sending back the remaining amount of inTokens to the `to` address: it is possible that not the full `inTokenObtained`\n        // is swapped to `outToken` if we're using the `1inch` payload\n        inTokenObtained = inToken.balanceOf(address(this));\n        if (inTokenObtained != 0) inToken.safeTransfer(to, inTokenObtained);\n    }\n\n    // ============================ GOVERNANCE FUNCTION ============================\n\n    /// @notice Changes allowances of this contract for different tokens\n    /// @param tokens Addresses of the tokens to allow\n    /// @param spenders Addresses to allow transfer\n    /// @param amounts Amounts to allow\n    function changeAllowance(\n        IERC20[] calldata tokens,\n        address[] calldata spenders,\n        uint256[] calldata amounts\n    ) external {\n        if (!core.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        uint256 tokensLength = tokens.length;\n        if (tokensLength != spenders.length || tokensLength != amounts.length) revert IncompatibleLengths();\n        for (uint256 i; i < tokensLength; ++i) {\n            _changeAllowance(tokens[i], spenders[i], amounts[i]);\n        }\n    }\n\n    // ========================= INTERNAL UTILITY FUNCTIONS ========================\n\n    /// @notice Internal version of the `_changeAllowance` function\n    function _changeAllowance(IERC20 token, address spender, uint256 amount) internal {\n        uint256 currentAllowance = token.allowance(address(this), spender);\n        // In case `currentAllowance < type(uint256).max / 2` and we want to increase it:\n        // Do nothing (to handle tokens that need reapprovals to 0 and save gas)\n        if (currentAllowance < amount && currentAllowance < type(uint256).max / 2) {\n            token.safeIncreaseAllowance(spender, amount - currentAllowance);\n        } else if (currentAllowance > amount) {\n            token.safeDecreaseAllowance(spender, currentAllowance - amount);\n        }\n    }\n\n    /// @notice Checks the allowance for a contract and updates it to the max if it is not big enough\n    /// @param token Token for which allowance should be checked\n    /// @param spender Address to grant allowance to\n    /// @param amount Minimum amount of tokens needed for the allowance\n    function _checkAllowance(IERC20 token, address spender, uint256 amount) internal {\n        uint256 currentAllowance = token.allowance(address(this), spender);\n        if (currentAllowance < amount) token.safeIncreaseAllowance(spender, type(uint256).max - currentAllowance);\n    }\n\n    /// @notice Performs a swap using either Uniswap, 1inch. This function can also stake stETH to wstETH\n    /// @param inToken Token to swap\n    /// @param amount Amount of tokens to swap\n    /// @param swapType Type of the swap to perform\n    /// @param args Extra args for the swap: in the case of Uniswap it should be a path, for 1inch it should be\n    /// a payload\n    /// @dev This function does nothing if `swapType` is None and it simply passes on the `amount` it received\n    /// @dev No slippage is specified in the actions given here as a final slippage check is performed\n    /// after the call to this function\n    function _swap(IERC20 inToken, uint256 amount, SwapType swapType, bytes memory args) internal {\n        if (swapType == SwapType.UniswapV3) _swapOnUniswapV3(inToken, amount, args);\n        else if (swapType == SwapType.oneInch) _swapOn1inch(inToken, args);\n        else if (swapType == SwapType.AngleRouter) _angleRouterActions(inToken, args);\n        else if (swapType == SwapType.Leverage) _swapLeverage(args);\n    }\n\n    /// @notice Performs a UniswapV3 swap\n    /// @param inToken Token to swap\n    /// @param amount Amount of tokens to swap\n    /// @param path Path for the UniswapV3 swap: this encodes the out token that is going to be obtained\n    /// @dev This function does not check the out token obtained here: if it is wrongly specified, either\n    /// the `swap` function could fail or these tokens could stay on the contract\n    function _swapOnUniswapV3(IERC20 inToken, uint256 amount, bytes memory path) internal returns (uint256 amountOut) {\n        // We need more than `amount` of allowance to the contract\n        _checkAllowance(inToken, address(uniV3Router), amount);\n        amountOut = uniV3Router.exactInput(ExactInputParams(path, address(this), block.timestamp, amount, 0));\n    }\n\n    /// @notice Allows to swap any token to an accepted collateral via 1inch API\n    /// @param inToken Token received for the 1inch swap\n    /// @param payload Bytes needed for 1inch API\n    function _swapOn1inch(IERC20 inToken, bytes memory payload) internal returns (uint256 amountOut) {\n        _changeAllowance(inToken, oneInch, type(uint256).max);\n        //solhint-disable-next-line\n        (bool success, bytes memory result) = oneInch.call(payload);\n        if (!success) _revertBytes(result);\n        amountOut = abi.decode(result, (uint256));\n    }\n\n    /// @notice Performs actions with the router contract of the protocol on the corresponding chain\n    /// @param inToken Token concerned by the action and for which\n    function _angleRouterActions(IERC20 inToken, bytes memory args) internal {\n        (ActionType[] memory actions, bytes[] memory actionData) = abi.decode(args, (ActionType[], bytes[]));\n        _changeAllowance(inToken, address(angleRouter), type(uint256).max);\n        PermitType[] memory permits;\n        angleRouter.mixer(permits, actions, actionData);\n    }\n\n    /// @notice Allows to take leverage or deleverage via a specific contract\n    /// @param payload Bytes needed for 1inch API\n    /// @dev This function is to be implemented if the swapper concerns a token that requires some actions\n    /// not supported by 1inch or UniV3\n    function _swapLeverage(bytes memory payload) internal virtual returns (uint256 amountOut) {}\n\n    /// @notice Internal function used for error handling\n    /// @param errMsg Error message received\n    function _revertBytes(bytes memory errMsg) internal pure {\n        if (errMsg.length != 0) {\n            //solhint-disable-next-line\n            assembly {\n                revert(add(32, errMsg), mload(errMsg))\n            }\n        }\n        revert EmptyReturnMessage();\n    }\n}\n"
    },
    "contracts/treasury/Treasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n                  *                                                                                \n                *****                                                                            \n                  *                                                                        \n                                   *            ///.                                  \n                                 *****        ////////                                      \n                                   *       /////////////                                         \n                                       //////////////////                                      \n                                  ///////////////////////                                   \n                               ////////////////////////////                                 \n                              /////////////////////////                                \n                            ,//////////////////////////////////////                           \n                          //////////////////////////////////////////                           \n                        ///////////////////////////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////.,//////////////////////////                     \n                       .//////////////////////..,./////////////////////                       \n                        ...////////////////.....,.////////////////                        \n                          ,.,//////////// ........,///////////                          \n                            .,.,//////      ,.......///////                            \n                               ,..//           ........./                               \n                                 ..,                .....,                                 \n                                    .                     ,.,                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                   \n                                                                            \n                                                                          \n                                                            \n*/\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IVaultManager.sol\";\n\n/// @title Treasury\n/// @author Angle Labs, Inc.\n/// @notice Treasury of Angle Borrowing Module doing the accounting across all VaultManagers for\n/// a given stablecoin\ncontract Treasury is ITreasury, Initializable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_9 = 1e9;\n\n    // ================================= REFERENCES ================================\n\n    /// @notice Reference to the `CoreBorrow` contract of the module which handles all AccessControl logic\n    ICoreBorrow public core;\n    /// @notice Flash Loan Module with a minter right on the stablecoin\n    IFlashAngle public flashLoanModule;\n    /// @inheritdoc ITreasury\n    IAgToken public stablecoin;\n    /// @notice Address responsible for handling the surplus made by the treasury\n    address public surplusManager;\n    /// @notice List of the accepted `VaultManager` of the protocol\n    address[] public vaultManagerList;\n    /// @notice Maps an address to 1 if it was initialized as a `VaultManager` contract\n    mapping(address => uint256) public vaultManagerMap;\n\n    // ================================= VARIABLES =================================\n\n    /// @notice Amount of bad debt (unbacked stablecoin) accumulated across all `VaultManager` contracts\n    /// linked to this stablecoin\n    uint256 public badDebt;\n    /// @notice Surplus amount accumulated by the contract waiting to be distributed to governance. Technically\n    /// only a share of this `surplusBuffer` will go to governance. Once a share of the surplus buffer has been\n    /// given to governance, then this surplus is reset\n    uint256 public surplusBuffer;\n\n    // ================================= PARAMETER =================================\n\n    /// @notice Share of the `surplusBuffer` distributed to governance (in `BASE_9`)\n    uint64 public surplusForGovernance;\n\n    // =================================== EVENTS ==================================\n\n    event BadDebtUpdated(uint256 badDebtValue);\n    event CoreUpdated(address indexed _core);\n    event NewTreasurySet(address indexed _treasury);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event SurplusBufferUpdated(uint256 surplusBufferValue);\n    event SurplusForGovernanceUpdated(uint64 _surplusForGovernance);\n    event SurplusManagerUpdated(address indexed _surplusManager);\n    event VaultManagerToggled(address indexed vaultManager);\n\n    // =================================== ERRORS ==================================\n\n    error AlreadyVaultManager();\n    error InvalidAddress();\n    error InvalidTreasury();\n    error NotCore();\n    error NotGovernor();\n    error NotVaultManager();\n    error RightsNotRemoved();\n    error TooBigAmount();\n    error TooHighParameterValue();\n    error ZeroAddress();\n\n    // ================================== MODIFIER =================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!core.isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Initializes the treasury contract\n    /// @param _core Address of the `CoreBorrow` contract of the module\n    /// @param _stablecoin Address of the stablecoin\n    function initialize(ICoreBorrow _core, IAgToken _stablecoin) public virtual initializer {\n        if (address(_stablecoin) == address(0) || address(_core) == address(0)) revert ZeroAddress();\n        core = _core;\n        stablecoin = _stablecoin;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // =============================== VIEW FUNCTIONS ==============================\n\n    /// @inheritdoc ITreasury\n    function isGovernor(address admin) external view returns (bool) {\n        return core.isGovernor(admin);\n    }\n\n    /// @inheritdoc ITreasury\n    function isGovernorOrGuardian(address admin) external view returns (bool) {\n        return core.isGovernorOrGuardian(admin);\n    }\n\n    /// @inheritdoc ITreasury\n    function isVaultManager(address _vaultManager) external view returns (bool) {\n        return vaultManagerMap[_vaultManager] == 1;\n    }\n\n    // ===================== EXTERNAL PERMISSIONLESS FUNCTIONS =====================\n\n    /// @notice Fetches the surplus accrued across all the `VaultManager` contracts controlled by this\n    /// `Treasury` contract as well as from the fees of the `FlashLoan` module\n    /// @return Surplus buffer value at the end of the call\n    /// @return Bad debt value at the end of the call\n    /// @dev This function pools surplus and bad debt across all contracts and then updates the `surplusBuffer`\n    /// (or the `badDebt` if more losses were made than profits)\n    function fetchSurplusFromAll() external returns (uint256, uint256) {\n        return _fetchSurplusFromAll();\n    }\n\n    /// @notice Fetches the surplus accrued in the flash loan module and updates the `surplusBuffer`\n    /// @return Surplus buffer value at the end of the call\n    /// @return Bad debt value at the end of the call\n    /// @dev This function fails if the `flashLoanModule` has not been initialized yet\n    function fetchSurplusFromFlashLoan() external returns (uint256, uint256) {\n        uint256 surplusBufferValue = surplusBuffer + flashLoanModule.accrueInterestToTreasury(stablecoin);\n        return _updateSurplusAndBadDebt(surplusBufferValue, badDebt);\n    }\n\n    /// @notice Pushes the surplus buffer to the `surplusManager` contract\n    /// @return governanceAllocation Amount transferred to governance\n    /// @dev It makes sure to fetch the surplus from all the contracts handled by this treasury to avoid\n    /// the situation where rewards are still distributed to governance even though a `VaultManager` has made\n    /// a big loss\n    /// @dev Typically this function is to be called once every week by a keeper to distribute rewards to veANGLE\n    /// holders\n    /// @dev `stablecoin` must be an AgToken and hence `transfer` reverts if the call is not successful\n    function pushSurplus() external returns (uint256 governanceAllocation) {\n        address _surplusManager = surplusManager;\n        if (_surplusManager == address(0)) {\n            revert ZeroAddress();\n        }\n        (uint256 surplusBufferValue, ) = _fetchSurplusFromAll();\n        surplusBuffer = 0;\n        emit SurplusBufferUpdated(0);\n        governanceAllocation = (surplusForGovernance * surplusBufferValue) / BASE_9;\n        stablecoin.transfer(_surplusManager, governanceAllocation);\n    }\n\n    /// @notice Updates the bad debt of the protocol in case where the protocol has accumulated some revenue\n    /// from an external source\n    /// @param amount Amount to reduce the bad debt of\n    /// @return badDebtValue Value of the bad debt at the end of the call\n    /// @dev If the protocol has made a loss and managed to make some profits to recover for this loss (through\n    /// a program like Olympus Pro), then this function needs to be called\n    /// @dev `badDebt` is simply reduced here by burning stablecoins\n    /// @dev It is impossible to burn more than the `badDebt` otherwise this function could be used to manipulate\n    /// the `surplusBuffer` and hence the amount going to governance\n    function updateBadDebt(uint256 amount) external returns (uint256 badDebtValue) {\n        stablecoin.burnSelf(amount, address(this));\n        badDebtValue = badDebt - amount;\n        badDebt = badDebtValue;\n        emit BadDebtUpdated(badDebtValue);\n    }\n\n    // ========================= INTERNAL UTILITY FUNCTIONS ========================\n\n    /// @notice Internal version of the `fetchSurplusFromAll` function\n    function _fetchSurplusFromAll() internal returns (uint256 surplusBufferValue, uint256 badDebtValue) {\n        (surplusBufferValue, badDebtValue) = _fetchSurplusFromList(vaultManagerList);\n        // It will fail anyway if the `flashLoanModule` is the zero address\n        if (address(flashLoanModule) != address(0))\n            surplusBufferValue += flashLoanModule.accrueInterestToTreasury(stablecoin);\n        (surplusBufferValue, badDebtValue) = _updateSurplusAndBadDebt(surplusBufferValue, badDebtValue);\n    }\n\n    /// @notice Fetches the surplus from a list of `VaultManager` addresses without modifying the\n    /// `surplusBuffer` and `badDebtValue`\n    /// @return surplusBufferValue Value the `surplusBuffer` should have after the call if it was updated\n    /// @return badDebtValue Value the `badDebt` should have after the call if it was updated\n    /// @dev This internal function is never to be called alone, and should always be called in conjunction\n    /// with the `_updateSurplusAndBadDebt` function\n    function _fetchSurplusFromList(\n        address[] memory vaultManagers\n    ) internal returns (uint256 surplusBufferValue, uint256 badDebtValue) {\n        badDebtValue = badDebt;\n        surplusBufferValue = surplusBuffer;\n        uint256 newSurplus;\n        uint256 newBadDebt;\n        uint256 vaultManagersLength = vaultManagers.length;\n        for (uint256 i; i < vaultManagersLength; ++i) {\n            (newSurplus, newBadDebt) = IVaultManager(vaultManagers[i]).accrueInterestToTreasury();\n            surplusBufferValue += newSurplus;\n            badDebtValue += newBadDebt;\n        }\n    }\n\n    /// @notice Updates the `surplusBuffer` and the `badDebt` from updated values after calling the flash loan module\n    /// and/or a list of `VaultManager` contracts\n    /// @param surplusBufferValue Value of the surplus buffer after the calls to the different modules\n    /// @param badDebtValue Value of the bad debt after the calls to the different modules\n    /// @return Value of the `surplusBuffer` corrected from the `badDebt`\n    /// @return Value of the `badDebt` corrected from the `surplusBuffer` and from the surplus the treasury had accumulated\n    /// previously\n    /// @dev When calling this function, it is possible that there is a positive `surplusBufferValue` and `badDebtValue`,\n    /// this function tries to reconcile both values and makes sure that we either have surplus or bad debt but not both\n    /// at the same time\n    function _updateSurplusAndBadDebt(\n        uint256 surplusBufferValue,\n        uint256 badDebtValue\n    ) internal returns (uint256, uint256) {\n        if (badDebtValue != 0) {\n            // If we have bad debt we need to burn stablecoins that accrued to the protocol\n            // We still need to make sure that we're not burning too much or as much as we can if the debt is big\n            uint256 balance = stablecoin.balanceOf(address(this));\n            // We are going to burn `min(balance, badDebtValue)`\n            uint256 toBurn = balance <= badDebtValue ? balance : badDebtValue;\n            stablecoin.burnSelf(toBurn, address(this));\n            // If we burned more than `surplusBuffer`, we set surplus to 0. It means we had to tap into Treasury reserve\n            surplusBufferValue = toBurn >= surplusBufferValue ? 0 : surplusBufferValue - toBurn;\n            badDebtValue -= toBurn;\n            // Note here that the stablecoin balance is necessarily greater than the surplus buffer, and so if\n            // `surplusBuffer >= toBurn`, then `badDebtValue = toBurn`\n        }\n        surplusBuffer = surplusBufferValue;\n        badDebt = badDebtValue;\n        emit SurplusBufferUpdated(surplusBufferValue);\n        emit BadDebtUpdated(badDebtValue);\n        return (surplusBufferValue, badDebtValue);\n    }\n\n    /// @notice Adds a new `VaultManager`\n    /// @param vaultManager `VaultManager` contract to add\n    /// @dev This contract should have already been initialized with a correct treasury address\n    /// @dev It's this function that gives the minter right to the `VaultManager`\n    function _addVaultManager(address vaultManager) internal virtual {\n        if (vaultManagerMap[vaultManager] == 1) revert AlreadyVaultManager();\n        if (address(IVaultManager(vaultManager).treasury()) != address(this)) revert InvalidTreasury();\n        vaultManagerMap[vaultManager] = 1;\n        vaultManagerList.push(vaultManager);\n        emit VaultManagerToggled(vaultManager);\n        stablecoin.addMinter(vaultManager);\n    }\n\n    // ============================= GOVERNOR FUNCTIONS ============================\n\n    /// @notice Adds a new minter for the stablecoin\n    /// @param minter Minter address to add\n    function addMinter(address minter) external virtual onlyGovernor {\n        if (minter == address(0)) revert ZeroAddress();\n        stablecoin.addMinter(minter);\n    }\n\n    /// @notice External wrapper for `_addVaultManager`\n    function addVaultManager(address vaultManager) external virtual onlyGovernor {\n        _addVaultManager(vaultManager);\n    }\n\n    /// @notice Removes a minter from the stablecoin contract\n    /// @param minter Minter address to remove\n    function removeMinter(address minter) external virtual onlyGovernor {\n        // To remove the minter role to a `VaultManager` you have to go through the `removeVaultManager` function\n        if (vaultManagerMap[minter] == 1) revert InvalidAddress();\n        stablecoin.removeMinter(minter);\n    }\n\n    /// @notice Removes a `VaultManager`\n    /// @param vaultManager `VaultManager` contract to remove\n    /// @dev A removed `VaultManager` loses its minter right on the stablecoin\n    function removeVaultManager(address vaultManager) external onlyGovernor {\n        if (vaultManagerMap[vaultManager] != 1) revert NotVaultManager();\n        delete vaultManagerMap[vaultManager];\n        // deletion from `vaultManagerList` loop\n        uint256 vaultManagerListLength = vaultManagerList.length;\n        for (uint256 i; i < vaultManagerListLength - 1; ++i) {\n            if (vaultManagerList[i] == vaultManager) {\n                // replace the `VaultManager` to remove with the last of the list\n                vaultManagerList[i] = vaultManagerList[vaultManagerListLength - 1];\n                break;\n            }\n        }\n        // remove last element in array\n        vaultManagerList.pop();\n        emit VaultManagerToggled(vaultManager);\n        stablecoin.removeMinter(vaultManager);\n    }\n\n    /// @notice Allows to recover any ERC20 token, including the stablecoin handled by this contract, and to send it\n    /// to a contract\n    /// @param tokenAddress Address of the token to recover\n    /// @param to Address of the contract to send collateral to\n    /// @param amountToRecover Amount of collateral to transfer\n    /// @dev It is impossible to recover the stablecoin of the protocol if there is some bad debt for it\n    /// @dev In this case, the function makes sure to fetch the surplus/bad debt from all the `VaultManager` contracts\n    /// and from the flash loan module\n    /// @dev If the token to recover is the stablecoin, tokens recovered are fetched\n    /// from the surplus and not from the `surplusBuffer`\n    function recoverERC20(address tokenAddress, address to, uint256 amountToRecover) external onlyGovernor {\n        // Cannot recover stablecoin if badDebt or tap into the surplus buffer\n        if (tokenAddress == address(stablecoin)) {\n            _fetchSurplusFromAll();\n            // If balance is non zero then this means, after the call to `fetchSurplusFromAll` that\n            // bad debt is necessarily null\n            uint256 balance = stablecoin.balanceOf(address(this));\n            if (amountToRecover + surplusBuffer > balance) revert TooBigAmount();\n            stablecoin.transfer(to, amountToRecover);\n        } else {\n            IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        }\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Changes the treasury contract and communicates this change to all `VaultManager` contract\n    /// @param _treasury New treasury address for this stablecoin\n    /// @dev This function is basically a way to remove rights to this contract and grant them to a new one\n    /// @dev It could be used to set a new core contract\n    function setTreasury(address _treasury) external virtual onlyGovernor {\n        if (ITreasury(_treasury).stablecoin() != stablecoin) revert InvalidTreasury();\n        // Flash loan role should be removed before calling this function\n        if (core.isFlashLoanerTreasury(address(this))) revert RightsNotRemoved();\n        emit NewTreasurySet(_treasury);\n        uint256 vaultManagerListLength = vaultManagerList.length;\n        for (uint256 i; i < vaultManagerListLength; ++i) {\n            IVaultManager(vaultManagerList[i]).setTreasury(_treasury);\n        }\n        // A `TreasuryUpdated` event is triggered in the stablecoin\n        stablecoin.setTreasury(_treasury);\n    }\n\n    /// @notice Sets the `surplusForGovernance` parameter\n    /// @param _surplusForGovernance New value of the parameter\n    /// @dev To pause surplus distribution, governance needs to set a zero value for `surplusForGovernance`\n    /// which means\n    function setSurplusForGovernance(uint64 _surplusForGovernance) external onlyGovernor {\n        if (_surplusForGovernance > BASE_9) revert TooHighParameterValue();\n        surplusForGovernance = _surplusForGovernance;\n        emit SurplusForGovernanceUpdated(_surplusForGovernance);\n    }\n\n    /// @notice Sets the `surplusManager` contract responsible for handling the surplus of the\n    /// protocol\n    /// @param _surplusManager New address responsible for handling the surplus\n    function setSurplusManager(address _surplusManager) external onlyGovernor {\n        if (_surplusManager == address(0)) revert ZeroAddress();\n        surplusManager = _surplusManager;\n        emit SurplusManagerUpdated(_surplusManager);\n    }\n\n    /// @notice Sets a new `core` contract\n    /// @dev This function should typically be called on all treasury contracts after the `setCore`\n    /// function has been called on the `CoreBorrow` contract\n    /// @dev One sanity check that can be performed here is to verify whether at least the governor\n    /// calling the contract is still a governor in the new core\n    function setCore(ICoreBorrow _core) external onlyGovernor {\n        if (!_core.isGovernor(msg.sender)) revert NotGovernor();\n        core = ICoreBorrow(_core);\n        emit CoreUpdated(address(_core));\n    }\n\n    /// @inheritdoc ITreasury\n    function setFlashLoanModule(address _flashLoanModule) external {\n        if (msg.sender != address(core)) revert NotCore();\n        address oldFlashLoanModule = address(flashLoanModule);\n        flashLoanModule = IFlashAngle(_flashLoanModule);\n        if (oldFlashLoanModule != address(0)) {\n            stablecoin.removeMinter(oldFlashLoanModule);\n        }\n        // We may want to cancel the module\n        if (_flashLoanModule != address(0)) {\n            stablecoin.addMinter(_flashLoanModule);\n        }\n    }\n}\n"
    },
    "contracts/ui-helpers/AngleBorrowHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n                  *                                                                                \n                *****                                                                            \n                  *                                                                        \n                                   *            ///.                                  \n                                 *****        ////////                                      \n                                   *       /////////////                                         \n                                       //////////////////                                      \n                                  ///////////////////////                                   \n                               ////////////////////////////                                 \n                              /////////////////////////                                \n                            ,//////////////////////////////////////                           \n                          //////////////////////////////////////////                           \n                        ///////////////////////////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////.,//////////////////////////                     \n                       .//////////////////////..,./////////////////////                       \n                        ...////////////////.....,.////////////////                        \n                          ,.,//////////// ........,///////////                          \n                            .,.,//////      ,.......///////                            \n                               ,..//           ........./                               \n                                 ..,                .....,                                 \n                                    .                     ,.,                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                   \n                                                                            \n                                                                          \n                                                            \n*/\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../interfaces/IVaultManager.sol\";\n\npragma solidity ^0.8.12;\n\n/// @title AngleBorrowHelpers\n/// @author Angle Labs, Inc.\n/// @notice Contract with view functions designed to facilitate integrations on the Borrow module of the Angle Protocol\n/// @dev This contract only contains view functions to be queried off-chain. It was thus not optimized for gas consumption\ncontract AngleBorrowHelpers is Initializable {\n    /// @notice Returns all the vaults owned or controlled (under the form of approval) by an address\n    /// @param vaultManager VaultManager address to query vaultIDs on\n    /// @param spender Address for which vault ownerships should be checked\n    /// @return List of `vaultID` controlled by this address\n    /// @return Count of vaults owned by the address\n    /// @dev This function is never to be called on-chain since it iterates over all vaultIDs. It is here\n    /// to reduce dependency on an external graph to link an ID to its owner\n    function getControlledVaults(\n        IVaultManager vaultManager,\n        address spender\n    ) external view returns (uint256[] memory, uint256) {\n        uint256 arraySize = vaultManager.vaultIDCount();\n        uint256[] memory vaultsControlled = new uint256[](arraySize);\n        uint256 count;\n        for (uint256 i = 1; i <= arraySize; ++i) {\n            try vaultManager.isApprovedOrOwner(spender, i) returns (bool _isApprovedOrOwner) {\n                if (_isApprovedOrOwner) {\n                    vaultsControlled[count] = i;\n                    count += 1;\n                }\n            } catch {\n                continue;\n            } // This happens if nobody owns the vaultID=i (if there has been a burn)\n        }\n        return (vaultsControlled, count);\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n}\n"
    },
    "contracts/ui-helpers/AngleHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\nimport \"../interfaces/IAngleRouter.sol\";\nimport \"../interfaces/coreModule/IAgTokenMainnet.sol\";\nimport \"../interfaces/coreModule/ICore.sol\";\nimport \"../interfaces/coreModule/IOracleCore.sol\";\nimport \"../interfaces/coreModule/IPerpetualManager.sol\";\nimport \"../interfaces/coreModule/IPoolManager.sol\";\nimport \"../interfaces/coreModule/IStableMaster.sol\";\nimport \"./AngleBorrowHelpers.sol\";\n\npragma solidity ^0.8.12;\n\nstruct Parameters {\n    SLPData slpData;\n    MintBurnData feeData;\n    PerpetualManagerFeeData perpFeeData;\n    PerpetualManagerParamData perpParam;\n}\n\nstruct PerpetualManagerFeeData {\n    uint64[] xHAFeesDeposit;\n    uint64[] yHAFeesDeposit;\n    uint64[] xHAFeesWithdraw;\n    uint64[] yHAFeesWithdraw;\n    uint64 haBonusMalusDeposit;\n    uint64 haBonusMalusWithdraw;\n}\n\nstruct PerpetualManagerParamData {\n    uint64 maintenanceMargin;\n    uint64 maxLeverage;\n    uint64 targetHAHedge;\n    uint64 limitHAHedge;\n    uint64 lockTime;\n}\n\nstruct CollateralAddresses {\n    address stableMaster;\n    address poolManager;\n    address perpetualManager;\n    address sanToken;\n    address oracle;\n    address gauge;\n    address feeManager;\n    address[] strategies;\n}\n\n/// @title AngleHelpers\n/// @author Angle Labs, Inc.\n/// @notice Contract with view functions designed to facilitate integrations on the Core and Borrow module of the Angle Protocol\n/// @dev This contract only contains view functions to be queried off-chain. It was thus not optimized for gas consumption\ncontract AngleHelpers is AngleBorrowHelpers {\n    // =========================== HELPER VIEW FUNCTIONS ===========================\n\n    /// @notice Gives the amount of `agToken` you'd be getting if you were executing in the same block a mint transaction\n    /// with `amount` of `collateral` in the Core module of the Angle protocol as well as the value of the fees\n    /// (in `BASE_PARAMS`) that would be applied during the mint\n    /// @return Amount of `agToken` that would be obtained with a mint transaction in the same block\n    /// @return Percentage of fees that would be taken during a mint transaction in the same block\n    /// @dev This function reverts if the mint transaction was to revert in the same conditions (without taking into account\n    /// potential approval problems to the `StableMaster` contract)\n    function previewMintAndFees(\n        uint256 amount,\n        address agToken,\n        address collateral\n    ) external view returns (uint256, uint256) {\n        return _previewMintAndFees(amount, agToken, collateral);\n    }\n\n    /// @notice Gives the amount of `collateral` you'd be getting if you were executing in the same block a burn transaction\n    ///  with `amount` of `agToken` in the Core module of the Angle protocol as well as the value of the fees\n    /// (in `BASE_PARAMS`) that would be applied during the burn\n    /// @return Amount of `collateral` that would be obtained with a burn transaction in the same block\n    /// @return Percentage of fees that would be taken during a burn transaction in the same block\n    /// @dev This function reverts if the burn transaction was to revert in the same conditions (without taking into account\n    /// potential approval problems to the `StableMaster` contract or agToken balance prior to the call)\n    function previewBurnAndFees(\n        uint256 amount,\n        address agToken,\n        address collateral\n    ) external view returns (uint256, uint256) {\n        return _previewBurnAndFees(amount, agToken, collateral);\n    }\n\n    /// @notice Returns all the addresses associated to the (`agToken`,`collateral`) pair given\n    /// @return addresses A struct with all the addresses associated in the Core module\n    function getCollateralAddresses(\n        address agToken,\n        address collateral\n    ) external view returns (CollateralAddresses memory addresses) {\n        address stableMaster = IAgTokenMainnet(agToken).stableMaster();\n        (address poolManager, address perpetualManager, address sanToken, address gauge) = ROUTER.mapPoolManagers(\n            stableMaster,\n            collateral\n        );\n        (, , , IOracleCore oracle, , , , , ) = IStableMaster(stableMaster).collateralMap(poolManager);\n        addresses.stableMaster = stableMaster;\n        addresses.poolManager = poolManager;\n        addresses.perpetualManager = perpetualManager;\n        addresses.sanToken = sanToken;\n        addresses.gauge = gauge;\n        addresses.oracle = address(oracle);\n        addresses.feeManager = IPoolManager(poolManager).feeManager();\n\n        uint256 length;\n        while (true) {\n            try IPoolManager(poolManager).strategyList(length) returns (address) {\n                length += 1;\n            } catch {\n                break;\n            }\n        }\n        address[] memory strategies = new address[](length);\n        for (uint256 i; i < length; ++i) {\n            strategies[i] = IPoolManager(poolManager).strategyList(i);\n        }\n        addresses.strategies = strategies;\n    }\n\n    /// @notice Gets the addresses of all the `StableMaster` contracts and their associated `AgToken` addresses\n    /// @return List of the `StableMaster` addresses of the Angle protocol\n    /// @return List of the `AgToken` addresses of the protocol\n    /// @dev The place of an agToken address in the list is the same as the corresponding `StableMaster` address\n    function getStablecoinAddresses() external view returns (address[] memory, address[] memory) {\n        address[] memory stableMasterAddresses = CORE.stablecoinList();\n        address[] memory agTokenAddresses = new address[](stableMasterAddresses.length);\n        for (uint256 i; i < stableMasterAddresses.length; ++i) {\n            agTokenAddresses[i] = IStableMaster(stableMasterAddresses[i]).agToken();\n        }\n        return (stableMasterAddresses, agTokenAddresses);\n    }\n\n    /// @notice Returns most of the governance parameters associated to the (`agToken`,`collateral`) pair given\n    /// @return params Struct with most of the parameters in the `StableMaster` and `PerpetualManager` contracts\n    /// @dev Check out the struct `Parameters` for the meaning of the return values\n    function getCollateralParameters(\n        address agToken,\n        address collateral\n    ) external view returns (Parameters memory params) {\n        (address stableMaster, address poolManager) = _getStableMasterAndPoolManager(agToken, collateral);\n        (\n            ,\n            ,\n            IPerpetualManager perpetualManager,\n            ,\n            ,\n            ,\n            ,\n            SLPData memory slpData,\n            MintBurnData memory feeData\n        ) = IStableMaster(stableMaster).collateralMap(poolManager);\n\n        params.slpData = slpData;\n        params.feeData = feeData;\n        params.perpParam.maintenanceMargin = perpetualManager.maintenanceMargin();\n        params.perpParam.maxLeverage = perpetualManager.maxLeverage();\n        params.perpParam.targetHAHedge = perpetualManager.targetHAHedge();\n        params.perpParam.limitHAHedge = perpetualManager.limitHAHedge();\n        params.perpParam.lockTime = perpetualManager.lockTime();\n\n        params.perpFeeData.haBonusMalusDeposit = perpetualManager.haBonusMalusDeposit();\n        params.perpFeeData.haBonusMalusWithdraw = perpetualManager.haBonusMalusWithdraw();\n\n        uint256 length;\n        while (true) {\n            try perpetualManager.xHAFeesDeposit(length) returns (uint64) {\n                length += 1;\n            } catch {\n                break;\n            }\n        }\n        uint64[] memory data = new uint64[](length);\n        uint64[] memory data2 = new uint64[](length);\n        for (uint256 i; i < length; ++i) {\n            data[i] = perpetualManager.xHAFeesDeposit(i);\n            data2[i] = perpetualManager.yHAFeesDeposit(i);\n        }\n        params.perpFeeData.xHAFeesDeposit = data;\n        params.perpFeeData.yHAFeesDeposit = data2;\n\n        length = 0;\n        while (true) {\n            try perpetualManager.xHAFeesWithdraw(length) returns (uint64) {\n                length += 1;\n            } catch {\n                break;\n            }\n        }\n        data = new uint64[](length);\n        data2 = new uint64[](length);\n        for (uint256 i; i < length; ++i) {\n            data[i] = perpetualManager.xHAFeesWithdraw(i);\n            data2[i] = perpetualManager.yHAFeesWithdraw(i);\n        }\n        params.perpFeeData.xHAFeesWithdraw = data;\n        params.perpFeeData.yHAFeesWithdraw = data2;\n    }\n\n    /// @notice Returns the address of the poolManager associated to an (`agToken`, `collateral`) pair\n    /// in the Core module of the protocol\n    function getPoolManager(address agToken, address collateral) public view returns (address poolManager) {\n        (, poolManager) = _getStableMasterAndPoolManager(agToken, collateral);\n    }\n\n    // ============================= REPLICA FUNCTIONS =============================\n    // These replicate what is done in the other contracts of the protocol\n\n    function _previewBurnAndFees(\n        uint256 amount,\n        address agToken,\n        address collateral\n    ) internal view returns (uint256 amountForUserInCollat, uint256 feePercent) {\n        (address stableMaster, address poolManager) = _getStableMasterAndPoolManager(agToken, collateral);\n        (\n            address token,\n            ,\n            IPerpetualManager perpetualManager,\n            IOracleCore oracle,\n            uint256 stocksUsers,\n            ,\n            uint256 collatBase,\n            ,\n            MintBurnData memory feeData\n        ) = IStableMaster(stableMaster).collateralMap(poolManager);\n        if (token == address(0) || IStableMaster(stableMaster).paused(keccak256(abi.encodePacked(STABLE, poolManager))))\n            revert NotInitialized();\n        if (amount > stocksUsers) revert InvalidAmount();\n\n        if (feeData.xFeeBurn.length == 1) {\n            feePercent = feeData.yFeeBurn[0];\n        } else {\n            bytes memory data = abi.encode(address(perpetualManager), feeData.targetHAHedge);\n            uint64 hedgeRatio = _computeHedgeRatio(stocksUsers - amount, data);\n            feePercent = _piecewiseLinear(hedgeRatio, feeData.xFeeBurn, feeData.yFeeBurn);\n        }\n        feePercent = (feePercent * feeData.bonusMalusBurn) / BASE_PARAMS;\n\n        amountForUserInCollat = (amount * (BASE_PARAMS - feePercent) * collatBase) / (oracle.readUpper() * BASE_PARAMS);\n    }\n\n    function _previewMintAndFees(\n        uint256 amount,\n        address agToken,\n        address collateral\n    ) internal view returns (uint256 amountForUserInStable, uint256 feePercent) {\n        (address stableMaster, address poolManager) = _getStableMasterAndPoolManager(agToken, collateral);\n        (\n            address token,\n            ,\n            IPerpetualManager perpetualManager,\n            IOracleCore oracle,\n            uint256 stocksUsers,\n            ,\n            ,\n            ,\n            MintBurnData memory feeData\n        ) = IStableMaster(stableMaster).collateralMap(poolManager);\n        if (token == address(0) || IStableMaster(stableMaster).paused(keccak256(abi.encodePacked(STABLE, poolManager))))\n            revert NotInitialized();\n\n        amountForUserInStable = oracle.readQuoteLower(amount);\n\n        if (feeData.xFeeMint.length == 1) feePercent = feeData.yFeeMint[0];\n        else {\n            bytes memory data = abi.encode(address(perpetualManager), feeData.targetHAHedge);\n            uint64 hedgeRatio = _computeHedgeRatio(amountForUserInStable + stocksUsers, data);\n            feePercent = _piecewiseLinear(hedgeRatio, feeData.xFeeMint, feeData.yFeeMint);\n        }\n        feePercent = (feePercent * feeData.bonusMalusMint) / BASE_PARAMS;\n\n        amountForUserInStable = (amountForUserInStable * (BASE_PARAMS - feePercent)) / BASE_PARAMS;\n        if (stocksUsers + amountForUserInStable > feeData.capOnStableMinted) revert InvalidAmount();\n    }\n\n    // ============================= UTILITY FUNCTIONS =============================\n    // These utility functions are taken from other contracts of the protocol\n\n    function _computeHedgeRatio(uint256 newStocksUsers, bytes memory data) internal view returns (uint64 ratio) {\n        (address perpetualManager, uint64 targetHAHedge) = abi.decode(data, (address, uint64));\n        uint256 totalHedgeAmount = IPerpetualManager(perpetualManager).totalHedgeAmount();\n        newStocksUsers = (targetHAHedge * newStocksUsers) / BASE_PARAMS;\n        if (newStocksUsers > totalHedgeAmount) ratio = uint64((totalHedgeAmount * BASE_PARAMS) / newStocksUsers);\n        else ratio = uint64(BASE_PARAMS);\n    }\n\n    function _piecewiseLinear(uint64 x, uint64[] memory xArray, uint64[] memory yArray) internal pure returns (uint64) {\n        if (x >= xArray[xArray.length - 1]) {\n            return yArray[xArray.length - 1];\n        } else if (x <= xArray[0]) {\n            return yArray[0];\n        } else {\n            uint256 lower;\n            uint256 upper = xArray.length - 1;\n            uint256 mid;\n            while (upper - lower > 1) {\n                mid = lower + (upper - lower) / 2;\n                if (xArray[mid] <= x) {\n                    lower = mid;\n                } else {\n                    upper = mid;\n                }\n            }\n            if (yArray[upper] > yArray[lower]) {\n                return\n                    yArray[lower] +\n                    ((yArray[upper] - yArray[lower]) * (x - xArray[lower])) /\n                    (xArray[upper] - xArray[lower]);\n            } else {\n                return\n                    yArray[lower] -\n                    ((yArray[lower] - yArray[upper]) * (x - xArray[lower])) /\n                    (xArray[upper] - xArray[lower]);\n            }\n        }\n    }\n\n    function _getStableMasterAndPoolManager(\n        address agToken,\n        address collateral\n    ) internal view returns (address stableMaster, address poolManager) {\n        stableMaster = IAgTokenMainnet(agToken).stableMaster();\n        (poolManager, , , ) = ROUTER.mapPoolManagers(stableMaster, collateral);\n    }\n\n    // ========================= CONSTANTS AND INITIALIZERS ========================\n\n    IAngleRouter public constant ROUTER = IAngleRouter(0xBB755240596530be0c1DE5DFD77ec6398471561d);\n    ICore public constant CORE = ICore(0x61ed74de9Ca5796cF2F8fD60D54160D47E30B7c3);\n\n    bytes32 public constant STABLE = keccak256(\"STABLE\");\n    uint256 public constant BASE_PARAMS = 10 ** 9;\n\n    error NotInitialized();\n    error InvalidAmount();\n}\n"
    },
    "contracts/utils/Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nerror InsufficientAssets();\n\n/// @title Constants\n/// @author Angle Labs, Inc.\n/// @notice Constants and errors for Angle Protocol contracts\ncontract Constants {\n    uint256 internal constant _BASE_9 = 1e9;\n    uint256 internal constant _BASE_18 = 1e18;\n    uint256 internal constant _BASE_27 = 1e27;\n    uint256 internal constant _BASE_36 = 1e36;\n}\n"
    },
    "contracts/vaultManager/VaultManagerERC721.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./VaultManagerStorage.sol\";\n\n/// @title VaultManagerERC721\n/// @author Angle Labs, Inc.\n/// @dev Base ERC721 Implementation of VaultManager\nabstract contract VaultManagerERC721 is IERC721MetadataUpgradeable, VaultManagerStorage {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// @inheritdoc IERC721MetadataUpgradeable\n    string public name;\n    /// @inheritdoc IERC721MetadataUpgradeable\n    string public symbol;\n\n    // ================================= MODIFIERS =================================\n\n    /// @notice Checks if the person interacting with the vault with `vaultID` is approved\n    /// @param caller Address of the person seeking to interact with the vault\n    /// @param vaultID ID of the concerned vault\n    modifier onlyApprovedOrOwner(address caller, uint256 vaultID) {\n        if (!_isApprovedOrOwner(caller, vaultID)) revert NotApproved();\n        _;\n    }\n\n    // ================================ ERC721 LOGIC ===============================\n\n    /// @notice Checks whether a given address is approved for a vault or owns this vault\n    /// @param spender Address for which vault ownership should be checked\n    /// @param vaultID ID of the vault to check\n    /// @return Whether the `spender` address owns or is approved for `vaultID`\n    function isApprovedOrOwner(address spender, uint256 vaultID) external view returns (bool) {\n        return _isApprovedOrOwner(spender, vaultID);\n    }\n\n    /// @inheritdoc IERC721MetadataUpgradeable\n    function tokenURI(uint256 vaultID) external view returns (string memory) {\n        if (!_exists(vaultID)) revert NonexistentVault();\n        // There is no vault with `vaultID` equal to 0, so the following variable is\n        // always greater than zero\n        uint256 temp = vaultID;\n        uint256 digits;\n        while (temp != 0) {\n            ++digits;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (vaultID != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(vaultID % 10)));\n            vaultID /= 10;\n        }\n        return bytes(_baseURI).length != 0 ? string(abi.encodePacked(_baseURI, string(buffer))) : \"\";\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function balanceOf(address owner) external view returns (uint256) {\n        if (owner == address(0)) revert ZeroAddress();\n        return _balances[owner];\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function ownerOf(uint256 vaultID) external view returns (address) {\n        return _ownerOf(vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function approve(address to, uint256 vaultID) external {\n        address owner = _ownerOf(vaultID);\n        if (to == owner) revert ApprovalToOwner();\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert NotApproved();\n\n        _approve(to, vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function getApproved(uint256 vaultID) external view returns (address) {\n        if (!_exists(vaultID)) revert NonexistentVault();\n        return _getApproved(vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator] == 1;\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function transferFrom(address from, address to, uint256 vaultID) external onlyApprovedOrOwner(msg.sender, vaultID) {\n        _transfer(from, to, vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function safeTransferFrom(address from, address to, uint256 vaultID) external {\n        safeTransferFrom(from, to, vaultID, \"\");\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 vaultID,\n        bytes memory _data\n    ) public onlyApprovedOrOwner(msg.sender, vaultID) {\n        _safeTransfer(from, to, vaultID, _data);\n    }\n\n    // ================================ ERC165 LOGIC ===============================\n\n    /// @inheritdoc IERC165Upgradeable\n    function supportsInterface(bytes4 interfaceId) external pure virtual returns (bool) {\n        return\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IVaultManager).interfaceId ||\n            interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    // ================== INTERNAL FUNCTIONS FOR THE ERC721 LOGIC ==================\n\n    /// @notice Internal version of the `ownerOf` function\n    function _ownerOf(uint256 vaultID) internal view returns (address owner) {\n        owner = _owners[vaultID];\n        if (owner == address(0)) revert NonexistentVault();\n    }\n\n    /// @notice Internal version of the `getApproved` function\n    function _getApproved(uint256 vaultID) internal view returns (address) {\n        return _vaultApprovals[vaultID];\n    }\n\n    /// @notice Internal version of the `safeTransferFrom` function (with the data parameter)\n    function _safeTransfer(address from, address to, uint256 vaultID, bytes memory _data) internal {\n        _transfer(from, to, vaultID);\n        if (!_checkOnERC721Received(from, to, vaultID, _data)) revert NonERC721Receiver();\n    }\n\n    /// @notice Checks whether a vault exists\n    /// @param vaultID ID of the vault to check\n    /// @return Whether `vaultID` has been created\n    function _exists(uint256 vaultID) internal view returns (bool) {\n        return _owners[vaultID] != address(0);\n    }\n\n    /// @notice Internal version of the `isApprovedOrOwner` function\n    function _isApprovedOrOwner(address spender, uint256 vaultID) internal view returns (bool) {\n        // The following checks if the vault exists\n        address owner = _ownerOf(vaultID);\n        return (spender == owner || _getApproved(vaultID) == spender || _operatorApprovals[owner][spender] == 1);\n    }\n\n    /// @notice Internal version of the `createVault` function\n    /// Mints `vaultID` and transfers it to `to`\n    /// @dev This method is equivalent to the `_safeMint` method used in OpenZeppelin ERC721 contract\n    /// @dev Emits a {Transfer} event\n    function _mint(address to) internal returns (uint256 vaultID) {\n        if (to == address(0)) revert ZeroAddress();\n\n        unchecked {\n            vaultIDCount += 1;\n        }\n\n        vaultID = vaultIDCount;\n        _beforeTokenTransfer(address(0), to, vaultID);\n\n        unchecked {\n            _balances[to] += 1;\n        }\n\n        _owners[vaultID] = to;\n        emit Transfer(address(0), to, vaultID);\n        if (!_checkOnERC721Received(address(0), to, vaultID, \"\")) revert NonERC721Receiver();\n    }\n\n    /// @notice Destroys `vaultID`\n    /// @dev `vaultID` must exist\n    /// @dev Emits a {Transfer} event\n    function _burn(uint256 vaultID) internal {\n        address owner = _ownerOf(vaultID);\n\n        _beforeTokenTransfer(owner, address(0), vaultID);\n        // Clear approvals\n        _approve(address(0), vaultID);\n        // The following line cannot underflow as the owner's balance is necessarily\n        // greater than 1\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[vaultID];\n        delete vaultData[vaultID];\n\n        emit Transfer(owner, address(0), vaultID);\n    }\n\n    /// @notice Transfers `vaultID` from `from` to `to` as opposed to {transferFrom},\n    /// this imposes no restrictions on msg.sender\n    /// @dev `to` cannot be the zero address and `perpetualID` must be owned by `from`\n    /// @dev Emits a {Transfer} event\n    function _transfer(address from, address to, uint256 vaultID) internal {\n        if (_ownerOf(vaultID) != from) revert NotApproved();\n        if (to == address(0)) revert ZeroAddress();\n\n        _beforeTokenTransfer(from, to, vaultID);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), vaultID);\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[vaultID] = to;\n\n        emit Transfer(from, to, vaultID);\n    }\n\n    /// @notice Approves `to` to operate on `vaultID`\n    function _approve(address to, uint256 vaultID) internal {\n        _vaultApprovals[vaultID] = to;\n        emit Approval(_ownerOf(vaultID), to, vaultID);\n    }\n\n    /// @notice Internal version of the `setApprovalForAll` function\n    /// @dev It contains an `approver` field to be used in case someone signs a permit for a particular\n    /// address, and this signature is given to the contract by another address (like a router)\n    function _setApprovalForAll(address approver, address operator, bool approved) internal {\n        if (operator == approver) revert ApprovalToCaller();\n        uint256 approval = approved ? 1 : 0;\n        _operatorApprovals[approver][operator] = approval;\n        emit ApprovalForAll(approver, operator, approved);\n    }\n\n    /// @notice Internal function to invoke {IERC721Receiver-onERC721Received} on a target address\n    /// The call is not executed if the target address is not a contract\n    /// @param from Address representing the previous owner of the given token ID\n    /// @param to Target address that will receive the tokens\n    /// @param vaultID ID of the token to be transferred\n    /// @param _data Bytes optional data to send along with the call\n    /// @return Bool whether the call correctly returned the expected value\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 vaultID,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(msg.sender, from, vaultID, _data) returns (\n                bytes4 retval\n            ) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert NonERC721Receiver();\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /// @notice Hook that is called before any token transfer. This includes minting and burning.\n    ///  Calling conditions:\n    ///\n    ///  - When `from` and `to` are both non-zero, `from`'s `vaultID` will be\n    ///  transferred to `to`.\n    ///  - When `from` is zero, `vaultID` will be minted for `to`.\n    ///  - When `to` is zero, `from`'s `vaultID` will be burned.\n    ///  - `from` and `to` are never both zero.\n    function _beforeTokenTransfer(address from, address to, uint256 vaultID) internal virtual {}\n\n    /// @notice Get `whitelistingActivated` in storage only if needed\n    function _whitelistingActivated() internal view virtual returns (bool) {\n        return whitelistingActivated;\n    }\n}\n"
    },
    "contracts/vaultManager/VaultManagerPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./VaultManagerERC721.sol\";\nimport \"../interfaces/external/IERC1271.sol\";\n\n/// @title VaultManagerPermit\n/// @author Angle Labs, Inc.\n/// @dev Base Implementation of permit functions for the `VaultManager` contract\nabstract contract VaultManagerPermit is Initializable, VaultManagerERC721 {\n    using Address for address;\n\n    mapping(address => uint256) private _nonces;\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private _PERMIT_TYPEHASH;\n    /* solhint-enable var-name-mixedcase */\n\n    error ExpiredDeadline();\n    error InvalidSignature();\n\n    //solhint-disable-next-line\n    function __ERC721Permit_init(string memory _name) internal onlyInitializing {\n        _PERMIT_TYPEHASH = keccak256(\n            \"Permit(address owner,address spender,bool approved,uint256 nonce,uint256 deadline)\"\n        );\n        _HASHED_NAME = keccak256(bytes(_name));\n        _HASHED_VERSION = keccak256(bytes(\"1\"));\n    }\n\n    /// @notice Allows an address to give or revoke approval for all its vaults to another address\n    /// @param owner Address signing the permit and giving (or revoking) its approval for all the controlled vaults\n    /// @param spender Address to give approval to\n    /// @param approved Whether to give or revoke the approval\n    /// @param deadline Deadline parameter for the signature to be valid\n    /// @dev The `v`, `r`, and `s` parameters are used as signature data\n    function permit(\n        address owner,\n        address spender,\n        bool approved,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        if (block.timestamp > deadline) revert ExpiredDeadline();\n        // Additional signature checks performed in the `ECDSAUpgradeable.recover` function\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0 || (v != 27 && v != 28))\n            revert InvalidSignature();\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                _domainSeparatorV4(),\n                keccak256(\n                    abi.encode(\n                        _PERMIT_TYPEHASH,\n                        // 0x3f43a9c6bafb5c7aab4e0cfe239dc5d4c15caf0381c6104188191f78a6640bd8,\n                        owner,\n                        spender,\n                        approved,\n                        _useNonce(owner),\n                        deadline\n                    )\n                )\n            )\n        );\n        if (owner.isContract()) {\n            if (IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) != 0x1626ba7e)\n                revert InvalidSignature();\n        } else {\n            address signer = ecrecover(digest, v, r, s);\n            if (signer != owner || signer == address(0)) revert InvalidSignature();\n        }\n\n        _setApprovalForAll(owner, spender, approved);\n    }\n\n    /// @notice Returns the current nonce for an `owner` address\n    function nonces(address owner) public view returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /// @notice Returns the domain separator for the current chain.\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /// @notice Internal version of the `DOMAIN_SEPARATOR` function\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                    _HASHED_NAME,\n                    _HASHED_VERSION,\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /// @notice Consumes a nonce for an address: returns the current value and increments it\n    function _useNonce(address owner) internal returns (uint256 current) {\n        current = _nonces[owner];\n        _nonces[owner] = current + 1;\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/vaultManager/VaultManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/ISwapper.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IVaultManager.sol\";\nimport \"../interfaces/governance/IVeBoostProxy.sol\";\n\n/// @title VaultManagerStorage\n/// @author Angle Labs, Inc.\n/// @dev Variables, references, parameters and events needed in the `VaultManager` contract\n// solhint-disable-next-line max-states-count\ncontract VaultManagerStorage is IVaultManagerStorage, Initializable, ReentrancyGuardUpgradeable {\n    /// @notice Base used for parameter computation: almost all the parameters of this contract are set in `BASE_PARAMS`\n    uint256 public constant BASE_PARAMS = 10 ** 9;\n    /// @notice Base used for interest rate computation\n    uint256 public constant BASE_INTEREST = 10 ** 27;\n    /// @notice Used for interest rate computation\n    uint256 public constant HALF_BASE_INTEREST = 10 ** 27 / 2;\n\n    // ================================= REFERENCES ================================\n\n    /// @inheritdoc IVaultManagerStorage\n    ITreasury public treasury;\n    /// @inheritdoc IVaultManagerStorage\n    IERC20 public collateral;\n    /// @inheritdoc IVaultManagerStorage\n    IAgToken public stablecoin;\n    /// @inheritdoc IVaultManagerStorage\n    IOracle public oracle;\n    /// @notice Reference to the contract which computes adjusted veANGLE balances for liquidators boosts\n    IVeBoostProxy public veBoostProxy;\n    /// @notice Base of the collateral\n    uint256 internal _collatBase;\n\n    // ================================= PARAMETERS ================================\n    // Unless specified otherwise, parameters of this contract are expressed in `BASE_PARAMS`\n\n    /// @notice Maximum amount of stablecoins that can be issued with this contract (in `BASE_TOKENS`). This parameter should\n    /// not be bigger than `type(uint256).max / BASE_INTEREST` otherwise there may be some overflows in the `increaseDebt` function\n    uint256 public debtCeiling;\n    /// @notice Threshold veANGLE balance values for the computation of the boost for liquidators: the length of this array\n    /// should normally be 2. The base of the x-values in this array should be `BASE_TOKENS`\n    uint256[] public xLiquidationBoost;\n    /// @notice Values of the liquidation boost at the threshold values of x\n    uint256[] public yLiquidationBoost;\n    /// @inheritdoc IVaultManagerStorage\n    uint64 public collateralFactor;\n    /// @notice Maximum Health factor at which a vault can end up after a liquidation (unless it's fully liquidated)\n    uint64 public targetHealthFactor;\n    /// @notice Upfront fee taken when borrowing stablecoins: this fee is optional and should in practice not be used\n    uint64 public borrowFee;\n    /// @notice Upfront fee taken when repaying stablecoins: this fee is optional as well. It should be smaller\n    /// than the liquidation surcharge (cf below) to avoid exploits where people voluntarily get liquidated at a 0\n    /// discount to pay smaller repaying fees\n    uint64 public repayFee;\n    /// @notice Per second interest taken to borrowers taking agToken loans. Contrarily to other parameters, it is set in `BASE_INTEREST`\n    /// that is to say in base 10**27\n    uint64 public interestRate;\n    /// @notice Fee taken by the protocol during a liquidation. Technically, this value is not the fee per se, it's 1 - fee.\n    /// For instance for a 2% fee, `liquidationSurcharge` should be 98%\n    uint64 public liquidationSurcharge;\n    /// @notice Maximum discount given to liquidators\n    uint64 public maxLiquidationDiscount;\n    /// @notice Whether whitelisting is required to own a vault or not\n    bool public whitelistingActivated;\n    /// @notice Whether the contract is paused or not\n    bool public paused;\n\n    // ================================= VARIABLES =================================\n\n    /// @notice Timestamp at which the `interestAccumulator` was updated\n    uint256 public lastInterestAccumulatorUpdated;\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public interestAccumulator;\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public totalNormalizedDebt;\n    /// @notice Surplus accumulated by the contract: surplus is always in stablecoins, and is then reset\n    /// when the value is communicated to the treasury contract\n    uint256 public surplus;\n    /// @notice Bad debt made from liquidated vaults which ended up having no collateral and a positive amount\n    /// of stablecoins\n    uint256 public badDebt;\n\n    // ================================== MAPPINGS =================================\n\n    /// @inheritdoc IVaultManagerStorage\n    mapping(uint256 => Vault) public vaultData;\n    /// @notice Maps an address to 1 if it's whitelisted and can open or own a vault\n    mapping(address => uint256) public isWhitelisted;\n\n    // ================================ ERC721 DATA ================================\n\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public vaultIDCount;\n\n    /// @notice URI\n    string internal _baseURI;\n\n    // Mapping from `vaultID` to owner address\n    mapping(uint256 => address) internal _owners;\n\n    // Mapping from owner address to vault owned count\n    mapping(address => uint256) internal _balances;\n\n    // Mapping from `vaultID` to approved address\n    mapping(uint256 => address) internal _vaultApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => uint256)) internal _operatorApprovals;\n\n    uint256[50] private __gap;\n\n    // =================================== EVENTS ==================================\n\n    event AccruedToTreasury(uint256 surplusEndValue, uint256 badDebtEndValue);\n    event CollateralAmountUpdated(uint256 vaultID, uint256 collateralAmount, uint8 isIncrease);\n    event InterestAccumulatorUpdated(uint256 value, uint256 timestamp);\n    event InternalDebtUpdated(uint256 vaultID, uint256 internalAmount, uint8 isIncrease);\n    event FiledUint64(uint64 param, bytes32 what);\n    event DebtCeilingUpdated(uint256 debtCeiling);\n    event LiquidationBoostParametersUpdated(address indexed _veBoostProxy, uint256[] xBoost, uint256[] yBoost);\n    event LiquidatedVaults(uint256[] vaultIDs);\n    event DebtTransferred(uint256 srcVaultID, uint256 dstVaultID, address dstVaultManager, uint256 amount);\n\n    // =================================== ERRORS ==================================\n\n    error ApprovalToOwner();\n    error ApprovalToCaller();\n    error DustyLeftoverAmount();\n    error DebtCeilingExceeded();\n    error HealthyVault();\n    error IncompatibleLengths();\n    error InsolventVault();\n    error InvalidParameterValue();\n    error InvalidParameterType();\n    error InvalidSetOfParameters();\n    error InvalidTreasury();\n    error NonERC721Receiver();\n    error NonexistentVault();\n    error NotApproved();\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error NotTreasury();\n    error NotWhitelisted();\n    error NotVaultManager();\n    error Paused();\n    error TooHighParameterValue();\n    error TooSmallParameterValue();\n    error ZeroAddress();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}