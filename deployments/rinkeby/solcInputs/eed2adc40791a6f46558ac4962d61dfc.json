{
  "language": "Solidity",
  "sources": {
    "contracts/vaultManager/VaultManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./VaultManagerERC721.sol\";\n\n/// @title VaultManager\n/// @author Angle Core Team\n/// @notice This contract allows people to deposit collateral and open up loans of a given AgToken. It handles all the loan\n/// logic (fees and interest rate) as well as the liquidation logic\n/// @dev This implementation only supports non-rebasing ERC20 tokens as collateral\n/// @dev This contract is encoded as a NFT contract\ncontract VaultManager is VaultManagerERC721, IVaultManagerFunctions {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// @inheritdoc IVaultManagerFunctions\n    function initialize(\n        ITreasury _treasury,\n        IERC20 _collateral,\n        IOracle _oracle,\n        VaultParameters calldata params,\n        string memory _symbol\n    ) external initializer {\n        if (_oracle.treasury() != _treasury) revert InvalidTreasury();\n        treasury = _treasury;\n        collateral = _collateral;\n        _collatBase = 10**(IERC20Metadata(address(collateral)).decimals());\n        stablecoin = IAgToken(_treasury.stablecoin());\n        oracle = _oracle;\n\n        name = string.concat(\"Angle Protocol \", _symbol, \" Vault\");\n        symbol = string.concat(_symbol, \"-vault\");\n\n        interestAccumulator = BASE_INTEREST;\n        lastInterestAccumulatorUpdated = block.timestamp;\n\n        // Checking if the parameters have been correctly initialized\n        if (\n            params.collateralFactor > params.liquidationSurcharge ||\n            params.liquidationSurcharge > BASE_PARAMS ||\n            BASE_PARAMS > params.targetHealthFactor ||\n            params.maxLiquidationDiscount >= BASE_PARAMS ||\n            params.baseBoost == 0\n        ) revert InvalidSetOfParameters();\n\n        debtCeiling = params.debtCeiling;\n        collateralFactor = params.collateralFactor;\n        targetHealthFactor = params.targetHealthFactor;\n        interestRate = params.interestRate;\n        liquidationSurcharge = params.liquidationSurcharge;\n        maxLiquidationDiscount = params.maxLiquidationDiscount;\n        whitelistingActivated = params.whitelistingActivated;\n        yLiquidationBoost = [params.baseBoost];\n        paused = true;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(uint256 dust_, uint256 dustCollateral_) VaultManagerStorage(dust_, dustCollateral_) {}\n\n    // ============================== Modifiers ====================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        if (!treasury.isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!treasury.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` is the treasury contract\n    modifier onlyTreasury() {\n        if (msg.sender != address(treasury)) revert NotTreasury();\n        _;\n    }\n\n    /// @notice Checks whether the contract is paused\n    modifier whenNotPaused() {\n        if (paused) revert Paused();\n        _;\n    }\n\n    // =========================== Vault Functions =================================\n\n    // ========================= External Access Functions =========================\n\n    /// @inheritdoc IVaultManagerFunctions\n    function createVault(address toVault) external whenNotPaused returns (uint256) {\n        return _mint(toVault);\n    }\n\n    /// @inheritdoc IVaultManagerFunctions\n    function angle(\n        ActionType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to\n    ) external payable returns (PaymentData memory) {\n        return angle(actions, datas, from, to, address(0), new bytes(0));\n    }\n\n    /// @inheritdoc IVaultManagerFunctions\n    function angle(\n        ActionType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to,\n        address who,\n        bytes memory repayData\n    ) public payable whenNotPaused nonReentrant returns (PaymentData memory paymentData) {\n        // `newInterestAccumulator` and `oracleValue` are expensive to compute. Therefore, they are computed\n        // only once inside the first action where they are necessary, then they are passed forward to further actions\n        uint256 newInterestAccumulator;\n        uint256 oracleValue;\n        uint256 collateralAmount;\n        uint256 stablecoinAmount;\n        uint256 vaultID;\n        for (uint256 i = 0; i < actions.length; i++) {\n            ActionType action = actions[i];\n            // Processing actions which do not need the value of the oracle or of the `interestAccumulator`\n            if (action == ActionType.createVault) {\n                _mint(abi.decode(datas[i], (address)));\n            } else if (action == ActionType.addCollateral) {\n                (vaultID, collateralAmount) = abi.decode(datas[i], (uint256, uint256));\n                if (vaultID == 0) vaultID = vaultIDCount;\n                _addCollateral(vaultID, collateralAmount);\n                paymentData.collateralAmountToReceive += collateralAmount;\n            } else if (action == ActionType.permit) {\n                address owner;\n                bytes32 r;\n                bytes32 s;\n                // Watch out naming conventions for permit are not respected to save some space and reduce the stack size\n                // `vaultID` is used in place of the `deadline` parameter\n                // Same for `collateralAmount` used in place of `value`\n                // `stablecoinAmount` is used in place of the `v`\n                (owner, collateralAmount, vaultID, stablecoinAmount, r, s) = abi.decode(\n                    datas[i],\n                    (address, uint256, uint256, uint256, bytes32, bytes32)\n                );\n                IERC20PermitUpgradeable(address(collateral)).permit(\n                    owner,\n                    address(this),\n                    collateralAmount,\n                    vaultID,\n                    uint8(stablecoinAmount),\n                    r,\n                    s\n                );\n            } else {\n                // Processing actions which rely on the `interestAccumulator`: first accruing it to make\n                // sure surplus is correctly taken into account between debt changes\n                if (newInterestAccumulator == 0) newInterestAccumulator = _accrue();\n                if (action == ActionType.repayDebt) {\n                    (vaultID, stablecoinAmount) = abi.decode(datas[i], (uint256, uint256));\n                    if (vaultID == 0) vaultID = vaultIDCount;\n                    stablecoinAmount = _repayDebt(vaultID, stablecoinAmount, newInterestAccumulator);\n                    uint256 stablecoinAmountPlusRepayFee = (stablecoinAmount * BASE_PARAMS) / (BASE_PARAMS - repayFee);\n                    surplus += stablecoinAmountPlusRepayFee - stablecoinAmount;\n                    paymentData.stablecoinAmountToReceive += stablecoinAmountPlusRepayFee;\n                } else {\n                    // Processing actions which need the oracle value\n                    if (oracleValue == 0) oracleValue = oracle.read();\n                    if (action == ActionType.closeVault) {\n                        vaultID = abi.decode(datas[i], (uint256));\n                        if (vaultID == 0) vaultID = vaultIDCount;\n                        (stablecoinAmount, collateralAmount) = _closeVault(\n                            vaultID,\n                            oracleValue,\n                            newInterestAccumulator\n                        );\n                        paymentData.collateralAmountToGive += collateralAmount;\n                        paymentData.stablecoinAmountToReceive += stablecoinAmount;\n                    } else if (action == ActionType.removeCollateral) {\n                        (vaultID, collateralAmount) = abi.decode(datas[i], (uint256, uint256));\n                        if (vaultID == 0) vaultID = vaultIDCount;\n                        _removeCollateral(vaultID, collateralAmount, oracleValue, newInterestAccumulator);\n                        paymentData.collateralAmountToGive += collateralAmount;\n                    } else if (action == ActionType.borrow) {\n                        (vaultID, stablecoinAmount) = abi.decode(datas[i], (uint256, uint256));\n                        if (vaultID == 0) vaultID = vaultIDCount;\n                        stablecoinAmount = _borrow(vaultID, stablecoinAmount, oracleValue, newInterestAccumulator);\n                        paymentData.stablecoinAmountToGive += stablecoinAmount;\n                    } else if (action == ActionType.getDebtIn) {\n                        address vaultManager;\n                        uint256 dstVaultID;\n                        (vaultID, vaultManager, dstVaultID, stablecoinAmount) = abi.decode(\n                            datas[i],\n                            (uint256, address, uint256, uint256)\n                        );\n                        if (vaultID == 0) vaultID = vaultIDCount;\n                        _getDebtIn(\n                            vaultID,\n                            IVaultManager(vaultManager),\n                            dstVaultID,\n                            stablecoinAmount,\n                            oracleValue,\n                            newInterestAccumulator\n                        );\n                    }\n                }\n            }\n        }\n\n        // Processing the different cases for the repayment, there are 4 of them:\n        // - (1) Stablecoins to receive + collateral to send\n        // - (2) Stablecoins to receive + collateral to receive\n        // - (3) Stablecoins to send + collateral to send\n        // - (4) Stablecoins to send + collateral to receive\n        if (paymentData.stablecoinAmountToReceive >= paymentData.stablecoinAmountToGive) {\n            uint256 stablecoinPayment = paymentData.stablecoinAmountToReceive - paymentData.stablecoinAmountToGive;\n            if (paymentData.collateralAmountToGive >= paymentData.collateralAmountToReceive) {\n                // In the case where all amounts are null, the function will enter here and nothing will be done\n                // for the repayment\n                _handleRepay(\n                    // Collateral payment is the difference between what to give and what to receive\n                    paymentData.collateralAmountToGive - paymentData.collateralAmountToReceive,\n                    stablecoinPayment,\n                    from,\n                    to,\n                    who,\n                    repayData\n                );\n            } else {\n                if (stablecoinPayment > 0) stablecoin.burnFrom(stablecoinPayment, from, msg.sender);\n                // In this case the collateral amount is necessarily non null\n                collateral.safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    paymentData.collateralAmountToReceive - paymentData.collateralAmountToGive\n                );\n            }\n        } else {\n            uint256 stablecoinPayment = paymentData.stablecoinAmountToGive - paymentData.stablecoinAmountToReceive;\n            // `stablecoinPayment` is strictly positive in this case\n            stablecoin.mint(to, stablecoinPayment);\n            if (paymentData.collateralAmountToGive > paymentData.collateralAmountToReceive) {\n                collateral.safeTransfer(to, paymentData.collateralAmountToGive - paymentData.collateralAmountToReceive);\n            } else {\n                uint256 collateralPayment = paymentData.collateralAmountToReceive - paymentData.collateralAmountToGive;\n                if (collateralPayment > 0) {\n                    if (repayData.length > 0) {\n                        ISwapper(who).swap(\n                            IERC20(address(stablecoin)),\n                            collateral,\n                            msg.sender,\n                            stablecoinPayment,\n                            collateralPayment,\n                            repayData\n                        );\n                    }\n                    collateral.safeTransferFrom(msg.sender, address(this), collateralPayment);\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc IVaultManagerFunctions\n    function getDebtOut(\n        uint256 vaultID,\n        uint256 stablecoinAmount,\n        uint256 senderBorrowFee,\n        uint256 senderRepayFee\n    ) external whenNotPaused {\n        if (!treasury.isVaultManager(msg.sender)) revert NotVaultManager();\n        // Getting debt out of a vault is equivalent to repaying a portion of your debt, and this could leave exploits:\n        // someone could borrow from a vault and transfer its debt to a `VaultManager` contract where debt repayment will\n        // be cheaper: in which case we're making people pay the delta\n        uint256 _repayFee;\n        if (repayFee > senderRepayFee) {\n            _repayFee = repayFee - senderRepayFee;\n        }\n        // Checking the delta of borrow fees to eliminate the risk of exploits here: a similar thing could happen: people\n        // could mint from where it is cheap to mint and then transfer their debt to places where it is more expensive\n        // to mint\n        uint256 _borrowFee;\n        if (senderBorrowFee > borrowFee) {\n            _borrowFee = senderBorrowFee - borrowFee;\n        }\n        // Getting debt out of a vault is equivalent to repaying a portion of your debt: a fee should be paid for this\n        // We're taking the highest of the two repay fees to avoid exploits\n        uint256 stablecoinAmountLessFeePaid = (stablecoinAmount *\n            (BASE_PARAMS - _repayFee) *\n            (BASE_PARAMS - _borrowFee)) / (BASE_PARAMS**2);\n        surplus += stablecoinAmount - stablecoinAmountLessFeePaid;\n        _repayDebt(vaultID, stablecoinAmountLessFeePaid, 0);\n    }\n\n    // ============================= View Functions ================================\n\n    /// @inheritdoc IVaultManagerFunctions\n    function getVaultDebt(uint256 vaultID) external view returns (uint256) {\n        return (vaultData[vaultID].normalizedDebt * _calculateCurrentInterestAccumulator()) / BASE_INTEREST;\n    }\n\n    /// @inheritdoc IVaultManagerFunctions\n    function getTotalDebt() external view returns (uint256) {\n        return (totalNormalizedDebt * _calculateCurrentInterestAccumulator()) / BASE_INTEREST;\n    }\n\n    /// @notice Checks whether a given vault is liquidable and if yes gives information regarding its liquidation\n    /// @param vaultID ID of the vault to check\n    /// @param liquidator Address of the liquidator which will be performing the liquidation\n    /// @return liqOpp Description of the opportunity of liquidation\n    /// @dev This function will revert if it's called on a vault that does not exist\n    function checkLiquidation(uint256 vaultID, address liquidator)\n        external\n        view\n        returns (LiquidationOpportunity memory liqOpp)\n    {\n        liqOpp = _checkLiquidation(\n            vaultData[vaultID],\n            liquidator,\n            oracle.read(),\n            _calculateCurrentInterestAccumulator()\n        );\n    }\n\n    // =================== Internal Utility View Functions =========================\n\n    /// @notice Verifies whether a given vault is solvent (i.e. should be liquidated or not)\n    /// @param vault Data of the vault to check\n    /// @param oracleValue Oracle value at the time of the call (it is in the base of the stablecoin, that is for agTokens 10**18)\n    /// @param newInterestAccumulator Value of the `interestAccumulator` at the time of the call\n    /// @return healthFactor Health factor of the vault: if it's inferior to 1 (`BASE_PARAMS` in fact) this means that the vault can be liquidated\n    /// @return currentDebt Current value of the debt of the vault (taking into account interest)\n    /// @return collateralAmountInStable Collateral in the vault expressed in stablecoin value\n    /// @dev If the oracle value or the interest rate accumulator has not been called at the time of the\n    /// call, this function computes it\n    function _isSolvent(\n        Vault memory vault,\n        uint256 oracleValue,\n        uint256 newInterestAccumulator\n    )\n        internal\n        view\n        returns (\n            uint256 healthFactor,\n            uint256 currentDebt,\n            uint256 collateralAmountInStable\n        )\n    {\n        currentDebt = (vault.normalizedDebt * newInterestAccumulator) / BASE_INTEREST;\n        collateralAmountInStable = (vault.collateralAmount * oracleValue) / _collatBase;\n        if (currentDebt == 0) healthFactor = type(uint256).max;\n        else healthFactor = (collateralAmountInStable * collateralFactor) / currentDebt;\n    }\n\n    /// @notice Calculates the current value of the `interestAccumulator` without updating the value\n    /// in storage\n    /// @dev This function avoids expensive exponentiation and the calculation is performed using a binomial approximation\n    /// (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n    /// @dev The approximation slightly undercharges borrowers with the advantage of a great gas cost reduction\n    /// @dev This function was mostly inspired from Aave implementation\n    function _calculateCurrentInterestAccumulator() internal view returns (uint256) {\n        uint256 exp = block.timestamp - lastInterestAccumulatorUpdated;\n        uint256 ratePerSecond = interestRate;\n        if (exp == 0 || ratePerSecond == 0) return interestAccumulator;\n        uint256 expMinusOne = exp - 1;\n        uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\n        uint256 basePowerTwo = (ratePerSecond * ratePerSecond + HALF_BASE_INTEREST) / BASE_INTEREST;\n        uint256 basePowerThree = (basePowerTwo * ratePerSecond + HALF_BASE_INTEREST) / BASE_INTEREST;\n        uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\n        uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\n        return (interestAccumulator * (BASE_INTEREST + ratePerSecond * exp + secondTerm + thirdTerm)) / BASE_INTEREST;\n    }\n\n    // =============== Internal Utility State-Modifying Functions ==================\n\n    /// @notice Closes a vault without handling the repayment of the concerned address\n    /// @param vaultID ID of the vault to close\n    /// @param oracleValue Oracle value at the start of the call\n    /// @param newInterestAccumulator Interest rate accumulator value at the start of the call\n    /// @return Current debt of the vault to be repaid\n    /// @return Value of the collateral in the vault to reimburse\n    /// @dev The returned values are here to facilitate composability between calls\n    function _closeVault(\n        uint256 vaultID,\n        uint256 oracleValue,\n        uint256 newInterestAccumulator\n    ) internal onlyApprovedOrOwner(msg.sender, vaultID) returns (uint256, uint256) {\n        Vault memory vault = vaultData[vaultID];\n        (uint256 healthFactor, uint256 currentDebt, ) = _isSolvent(vault, oracleValue, newInterestAccumulator);\n        if (healthFactor <= BASE_PARAMS) revert InsolventVault();\n        totalNormalizedDebt -= vault.normalizedDebt;\n        _burn(vaultID);\n        uint256 currentDebtPlusRepayFee = (currentDebt * BASE_PARAMS) / (BASE_PARAMS - repayFee);\n        surplus += currentDebtPlusRepayFee - currentDebt;\n        return (currentDebtPlusRepayFee, vault.collateralAmount);\n    }\n\n    /// @notice Increases the collateral balance of a vault\n    /// @param vaultID ID of the vault to increase the collateral balance of\n    /// @param collateralAmount Amount by which increasing the collateral balance of\n    function _addCollateral(uint256 vaultID, uint256 collateralAmount) internal {\n        vaultData[vaultID].collateralAmount += collateralAmount;\n        emit CollateralAmountUpdated(vaultID, collateralAmount, 1);\n    }\n\n    /// @notice Decreases the collateral balance from a vault (without proceeding to collateral transfers)\n    /// @param vaultID ID of the vault to decrease the collateral balance of\n    /// @param collateralAmount Amount of collateral to reduce the balance of\n    /// @param oracleValue Oracle value at the start of the call (given here to avoid double computations)\n    /// @param interestAccumulator Value of the interest rate accumulator (potentially zero if it has not been\n    /// computed yet)\n    function _removeCollateral(\n        uint256 vaultID,\n        uint256 collateralAmount,\n        uint256 oracleValue,\n        uint256 interestAccumulator\n    ) internal onlyApprovedOrOwner(msg.sender, vaultID) {\n        vaultData[vaultID].collateralAmount -= collateralAmount;\n        (uint256 healthFactor, , ) = _isSolvent(vaultData[vaultID], oracleValue, interestAccumulator);\n        if (healthFactor <= BASE_PARAMS) revert InsolventVault();\n        emit CollateralAmountUpdated(vaultID, collateralAmount, 0);\n    }\n\n    /// @notice Increases the debt balance of a vault and takes into account borrowing fees\n    /// @param vaultID ID of the vault to increase borrow balance of\n    /// @param stablecoinAmount Amount of stablecoins to borrow\n    /// @param oracleValue Oracle value at the start of the call\n    /// @param newInterestAccumulator Value of the interest rate accumulator\n    /// @return toMint Amount of stablecoins to mint\n    function _borrow(\n        uint256 vaultID,\n        uint256 stablecoinAmount,\n        uint256 oracleValue,\n        uint256 newInterestAccumulator\n    ) internal onlyApprovedOrOwner(msg.sender, vaultID) returns (uint256 toMint) {\n        stablecoinAmount = _increaseDebt(vaultID, stablecoinAmount, oracleValue, newInterestAccumulator);\n        uint256 borrowFeePaid = (borrowFee * stablecoinAmount) / BASE_PARAMS;\n        surplus += borrowFeePaid;\n        toMint = stablecoinAmount - borrowFeePaid;\n    }\n\n    /// @notice Gets debt in a vault from another vault potentially in another `VaultManager` contract\n    /// @param srcVaultID ID of the vault from this contract for which growing debt\n    /// @param vaultManager Address of the `VaultManager` where the targeted vault is\n    /// @param dstVaultID ID of the vault in the target contract\n    /// @param stablecoinAmount Amount of stablecoins to grow the debt of. This amount will be converted\n    /// to a normalized value in both `VaultManager` contracts\n    /// @param oracleValue Oracle value at the start of the call (potentially zero if it has not been computed yet)\n    /// @param newInterestAccumulator Value of the interest rate accumulator (potentially zero if it has not been\n    /// computed yet)\n    /// @dev A solvency check is performed after the debt increase in the source `vaultID`\n    /// @dev Only approved addresses by the source vault owner can perform this action, however any vault\n    /// from any vaultManager contract can see its debt reduced by this means\n    function _getDebtIn(\n        uint256 srcVaultID,\n        IVaultManager vaultManager,\n        uint256 dstVaultID,\n        uint256 stablecoinAmount,\n        uint256 oracleValue,\n        uint256 newInterestAccumulator\n    ) internal onlyApprovedOrOwner(msg.sender, srcVaultID) {\n        // The `stablecoinAmount` needs to be rounded down in the `_increaseDebt` function to reduce the room for exploits\n        stablecoinAmount = _increaseDebt(srcVaultID, stablecoinAmount, oracleValue, newInterestAccumulator);\n        if (address(vaultManager) == address(this)) {\n            // No repayFees taken in this case, otherwise the same stablecoin may end up paying fees twice\n            _repayDebt(dstVaultID, stablecoinAmount, newInterestAccumulator);\n        } else {\n            // No need to check the integrity of `VaultManager` here because `_getDebtIn` can be entered only through the\n            // `angle` function which is non reentrant. Also, `getDebtOut` failing would be at the attacker loss, as they\n            // would get their debt increasing in the current vault without decreasing it in the remote vault.\n            vaultManager.getDebtOut(dstVaultID, stablecoinAmount, borrowFee, repayFee);\n        }\n    }\n\n    /// @notice Increases the debt of a given vault and verifies that this vault is still solvent\n    /// @param vaultID ID of the vault to increase the debt of\n    /// @param stablecoinAmount Amount of stablecoin to increase the debt of: this amount is converted in\n    /// normalized debt using the pre-computed (or not) `newInterestAccumulator` value\n    /// @param oracleValue Oracle value at the start of the call (given here to avoid double computations)\n    /// @param newInterestAccumulator Value of the interest rate accumulator (potentially zero if it has not been\n    /// computed yet)\n    /// @return Amount of stablecoins to issue from this debt increase\n    /// @dev The `stablecoinAmount` outputted need to be rounded down with respect to the change amount so that\n    /// amount of stablecoins minted is smaller than the debt increase\n    function _increaseDebt(\n        uint256 vaultID,\n        uint256 stablecoinAmount,\n        uint256 oracleValue,\n        uint256 newInterestAccumulator\n    ) internal returns (uint256) {\n        // We normalize the amount by dividing it by `newInterestAccumulator`. This makes accounting easier, since\n        // it allows us to process all (past and future) debts like debts created at the inception of the contract.\n        uint256 changeAmount = (stablecoinAmount * BASE_INTEREST) / newInterestAccumulator;\n        // if there was no previous debt, we have to check that the debt creation will be higher than `dust`\n        if (vaultData[vaultID].normalizedDebt == 0)\n            if (changeAmount * newInterestAccumulator <= dust * BASE_INTEREST) revert DustyLeftoverAmount();\n        vaultData[vaultID].normalizedDebt += changeAmount;\n        totalNormalizedDebt += changeAmount;\n        if (totalNormalizedDebt * newInterestAccumulator > debtCeiling * BASE_INTEREST) revert DebtCeilingExceeded();\n        (uint256 healthFactor, , ) = _isSolvent(vaultData[vaultID], oracleValue, newInterestAccumulator);\n        if (healthFactor <= BASE_PARAMS) revert InsolventVault();\n        emit InternalDebtUpdated(vaultID, changeAmount, 1);\n        return (changeAmount * newInterestAccumulator) / BASE_INTEREST;\n    }\n\n    /// @notice Decreases the debt of a given vault and verifies that this vault still has an amount of debt superior\n    /// to a dusty amount or no debt at all\n    /// @param vaultID ID of the vault to decrease the debt of\n    /// @param stablecoinAmount Amount of stablecoin to decrease the debt of: this amount is converted in\n    /// normalized debt using the pre-computed (or not) `newInterestAccumulator` value\n    /// To repay the whole debt, one can pass `type(uint256).max`\n    /// @param newInterestAccumulator Value of the interest rate accumulator (potentially zero if it has not been\n    /// computed yet, like in `getDebtOut`)\n    /// @return Amount of stablecoins to be burnt to correctly repay the debt\n    /// @dev If `stablecoinAmount` is `type(uint256).max`, this function will repay all the debt of the vault\n    function _repayDebt(\n        uint256 vaultID,\n        uint256 stablecoinAmount,\n        uint256 newInterestAccumulator\n    ) internal returns (uint256) {\n        if (newInterestAccumulator == 0) newInterestAccumulator = _accrue();\n        uint256 newVaultNormalizedDebt = vaultData[vaultID].normalizedDebt;\n        // To save one variable declaration, `changeAmount` is first expressed in stablecoin amount before being converted\n        // to a normalized amount. Here we first store the maximum amount that can be repaid given the current debt\n        uint256 changeAmount = (newVaultNormalizedDebt * newInterestAccumulator) / BASE_INTEREST;\n        // In some situations (e.g. liquidations), the `stablecoinAmount` is rounded above and we want to make\n        // sure to avoid underflows in all situations\n        if (stablecoinAmount >= changeAmount) {\n            stablecoinAmount = changeAmount;\n            changeAmount = newVaultNormalizedDebt;\n        } else {\n            changeAmount = (stablecoinAmount * BASE_INTEREST) / newInterestAccumulator;\n        }\n        newVaultNormalizedDebt -= changeAmount;\n        totalNormalizedDebt -= changeAmount;\n        if (newVaultNormalizedDebt != 0 && newVaultNormalizedDebt * newInterestAccumulator <= dust * BASE_INTEREST)\n            revert DustyLeftoverAmount();\n        vaultData[vaultID].normalizedDebt = newVaultNormalizedDebt;\n        emit InternalDebtUpdated(vaultID, changeAmount, 0);\n        return stablecoinAmount;\n    }\n\n    /// @notice Handles the simultaneous repayment of stablecoins with a transfer of collateral\n    /// @param collateralAmountToGive Amount of collateral the contract should give\n    /// @param stableAmountToRepay Amount of stablecoins the contract should burn from the call\n    /// @param from Address from which stablecoins should be burnt: it should be the `msg.sender` or at least\n    /// approved by it\n    /// @param to Address to which stablecoins should be sent\n    /// @param who Address which should be notified if needed of the transfer\n    /// @param data Data to pass to the `who` contract for it to successfully give the correct amount of stablecoins\n    /// to the `from` address\n    /// @dev This function allows for capital-efficient liquidations and repayments of loans\n    function _handleRepay(\n        uint256 collateralAmountToGive,\n        uint256 stableAmountToRepay,\n        address from,\n        address to,\n        address who,\n        bytes memory data\n    ) internal {\n        if (collateralAmountToGive > 0) collateral.safeTransfer(to, collateralAmountToGive);\n        if (stableAmountToRepay > 0) {\n            if (data.length > 0) {\n                ISwapper(who).swap(\n                    collateral,\n                    IERC20(address(stablecoin)),\n                    from,\n                    stableAmountToRepay,\n                    collateralAmountToGive,\n                    data\n                );\n            }\n            stablecoin.burnFrom(stableAmountToRepay, from, msg.sender);\n        }\n    }\n\n    // =================== Treasury Relationship Functions =========================\n\n    /// @inheritdoc IVaultManagerFunctions\n    function accrueInterestToTreasury() external onlyTreasury returns (uint256 surplusValue, uint256 badDebtValue) {\n        _accrue();\n        surplusValue = surplus;\n        badDebtValue = badDebt;\n        if (surplusValue >= badDebtValue) {\n            surplusValue -= badDebtValue;\n            badDebtValue = 0;\n            stablecoin.mint(address(treasury), surplusValue);\n        } else {\n            badDebtValue -= surplusValue;\n            surplusValue = 0;\n        }\n        surplus = 0;\n        badDebt = 0;\n        emit AccruedToTreasury(surplusValue, badDebtValue);\n    }\n\n    /// @notice Accrues interest accumulated across all vaults to the surplus and updates the `interestAccumulator`\n    /// @return newInterestAccumulator Computed value of the interest accumulator\n    /// @dev It should also be called when updating the value of the per second interest rate or when the `totalNormalizedDebt`\n    /// value is about to change\n    function _accrue() internal returns (uint256 newInterestAccumulator) {\n        newInterestAccumulator = _calculateCurrentInterestAccumulator();\n        uint256 interestAccrued = (totalNormalizedDebt * (newInterestAccumulator - interestAccumulator)) /\n            BASE_INTEREST;\n        surplus += interestAccrued;\n        interestAccumulator = newInterestAccumulator;\n        lastInterestAccumulatorUpdated = block.timestamp;\n        emit InterestAccumulatorUpdated(newInterestAccumulator, block.timestamp);\n        return newInterestAccumulator;\n    }\n\n    // ============================ Liquidations ===================================\n\n    /// @notice Liquidates an ensemble of vaults specified by their IDs\n    /// @dev This function is a simplified wrapper of the function below. It is built to remove for liquidators the need to specify\n    /// a `who` and a `data` parameters\n    function liquidate(\n        uint256[] memory vaultIDs,\n        uint256[] memory amounts,\n        address from,\n        address to\n    ) external returns (LiquidatorData memory) {\n        return liquidate(vaultIDs, amounts, from, to, address(0), new bytes(0));\n    }\n\n    /// @notice Liquidates an ensemble of vaults specified by their IDs\n    /// @param vaultIDs List of the vaults to liquidate\n    /// @param amounts Amount of stablecoin to bring for the liquidation of each vault\n    /// @param from Address from which the stablecoins for the liquidation should be taken: this address should be the `msg.sender`\n    /// or have received an approval\n    /// @param to Address to which discounted collateral should be sent\n    /// @param who Address of the contract to handle repayment of stablecoins from received collateral\n    /// @param data Data to pass to the repayment contract in case of\n    /// @dev This function will revert if it's called on a vault that cannot be liquidated or that does not exist\n    function liquidate(\n        uint256[] memory vaultIDs,\n        uint256[] memory amounts,\n        address from,\n        address to,\n        address who,\n        bytes memory data\n    ) public whenNotPaused nonReentrant returns (LiquidatorData memory liqData) {\n        // Stores all the data about an ongoing liquidation of multiple vaults\n        if (vaultIDs.length != amounts.length) revert IncompatibleLengths();\n        liqData.oracleValue = oracle.read();\n        liqData.newInterestAccumulator = _accrue();\n        emit LiquidatedVaults(vaultIDs);\n        for (uint256 i = 0; i < vaultIDs.length; i++) {\n            Vault memory vault = vaultData[vaultIDs[i]];\n            // Computing if liquidation can take place for a vault\n            LiquidationOpportunity memory liqOpp = _checkLiquidation(\n                vault,\n                msg.sender,\n                liqData.oracleValue,\n                liqData.newInterestAccumulator\n            );\n\n            // Makes sure not to leave a dusty amount in the vault by either not liquidating too much\n            // or everything\n            if (\n                (liqOpp.thresholdRepayAmount > 0 && amounts[i] > liqOpp.thresholdRepayAmount) ||\n                amounts[i] > liqOpp.maxStablecoinAmountToRepay\n            ) amounts[i] = liqOpp.maxStablecoinAmountToRepay;\n\n            // liqOpp.discount stores in fact `1-discount`\n            uint256 collateralReleased = (amounts[i] * BASE_PARAMS * _collatBase) /\n                (liqOpp.discount * liqData.oracleValue);\n            // Because we're rounding up in some divisions, `collateralReleased` can be greater than the `collateralAmount` of the vault\n            // In this case, `stablecoinAmountToReceive` is still rounded up\n            if (vault.collateralAmount <= collateralReleased) {\n                collateralReleased = vault.collateralAmount;\n                // Remove all the vault's debt (debt repayed + bad debt) from VaultManager totalDebt\n                totalNormalizedDebt -= vault.normalizedDebt;\n                // Reinitializing the `vaultID`: we're not burning the vault in this case for integration purposes\n                delete vaultData[vaultIDs[i]];\n                liqData.badDebtFromLiquidation +=\n                    liqOpp.currentDebt -\n                    (amounts[i] * liquidationSurcharge) /\n                    BASE_PARAMS;\n                // There may be an edge case in which: `amounts[i] = (currentDebt * BASE_PARAMS) / surcharge + 1`\n                // In this case, as long as `surcharge < BASE_PARAMS`, there cannot be any underflow in the operation\n                // above\n                emit InternalDebtUpdated(vaultIDs[i], vault.normalizedDebt, 0);\n            } else {\n                vaultData[vaultIDs[i]].collateralAmount -= collateralReleased;\n                // In the case where the full debt is being repaid, `amounts[i]` must be rounded above\n                _repayDebt(\n                    vaultIDs[i],\n                    (amounts[i] * liquidationSurcharge) / BASE_PARAMS,\n                    liqData.newInterestAccumulator\n                );\n            }\n            liqData.collateralAmountToGive += collateralReleased;\n            liqData.stablecoinAmountToReceive += amounts[i];\n        }\n        // Normalization of good and bad debt is already handled in the `accrueInterestToTreasury` function\n        surplus += (liqData.stablecoinAmountToReceive * (BASE_PARAMS - liquidationSurcharge)) / BASE_PARAMS;\n        badDebt += liqData.badDebtFromLiquidation;\n        _handleRepay(liqData.collateralAmountToGive, liqData.stablecoinAmountToReceive, from, to, who, data);\n    }\n\n    /// @notice Internal version of the `checkLiquidation` function\n    /// @dev This function takes two additional parameters as when entering this function `oracleValue`\n    /// and `newInterestAccumulator` should have always been computed\n    function _checkLiquidation(\n        Vault memory vault,\n        address liquidator,\n        uint256 oracleValue,\n        uint256 newInterestAccumulator\n    ) internal view returns (LiquidationOpportunity memory liqOpp) {\n        // Checking if the vault can be liquidated\n        (uint256 healthFactor, uint256 currentDebt, uint256 collateralAmountInStable) = _isSolvent(\n            vault,\n            oracleValue,\n            newInterestAccumulator\n        );\n        // Health factor of a vault that does not exist is `type(uint256).max`\n        if (healthFactor >= BASE_PARAMS) revert HealthyVault();\n\n        uint256 liquidationDiscount = (_computeLiquidationBoost(liquidator) * (BASE_PARAMS - healthFactor)) /\n            BASE_PARAMS;\n        // In fact `liquidationDiscount` is stored here as 1 minus discount to save some computation costs\n        // This value is necessarily > 0 as `maxLiquidationDiscount < BASE_PARAMS`\n        liquidationDiscount = liquidationDiscount >= maxLiquidationDiscount\n            ? BASE_PARAMS - maxLiquidationDiscount\n            : BASE_PARAMS - liquidationDiscount;\n        // Same for the surcharge here: it's in fact 1 - the fee taken by the protocol\n        uint256 surcharge = liquidationSurcharge;\n        // Checking if we're in a situation where the health factor is an increasing or a decreasing function of the\n        // amount repaid\n        uint256 maxAmountToRepay;\n        uint256 thresholdRepayAmount;\n        // In the first case, the health factor is an increasing function of the stablecoin amount to repay,\n        // this means that the liquidator can bring the vault to the target health ratio\n        if (healthFactor * liquidationDiscount * surcharge >= collateralFactor * BASE_PARAMS**2) {\n            // This is the max amount to repay that will bring the person to the target health factor\n            // Denom is always positive when a vault gets liquidated in this case and when the health factor\n            // is an increasing function of the amount of stablecoins repaid\n            // And given that most parameters are in base 9, the numerator can very hardly overflow here\n            maxAmountToRepay =\n                ((targetHealthFactor * currentDebt - collateralAmountInStable * collateralFactor) *\n                    BASE_PARAMS *\n                    liquidationDiscount) /\n                (surcharge * targetHealthFactor * liquidationDiscount - (BASE_PARAMS**2) * collateralFactor);\n            // The quantity below tends to be rounded in the above direction, which means that governance should\n            // set the `targetHealthFactor` accordingly\n            // Need to check for the dust: liquidating should not leave a dusty amount in the vault\n            if (currentDebt <= (maxAmountToRepay * surcharge) / BASE_PARAMS + dust) {\n                // If liquidating to the target threshold would leave a dusty amount: the liquidator can repay all\n                // We're rounding up the max amount to repay to make sure all the debt ends up being paid\n                // and we're computing again the real value of the debt to avoid propagation of rounding errors\n                maxAmountToRepay =\n                    (vault.normalizedDebt * newInterestAccumulator * BASE_PARAMS) /\n                    (surcharge * BASE_INTEREST) +\n                    1;\n                // In this case the threshold amount is such that it leaves just enough dust\n                // This line cannot underflow as long as the  `dust` parameter is constant: it is always checked that\n                // the debt is greater than the  `dust`. If the `dust` was to increase due to an implementation upgrade\n                // we would need to add some extra checks to avoid underflows\n                // Here the `thresholdRepayAmount` is also rounded down: which means that if a liquidator repays this amount\n                // then there would be more than `dust` left in the vault\n                thresholdRepayAmount = ((currentDebt - dust) * BASE_PARAMS) / surcharge;\n            }\n        } else {\n            // In all cases the liquidator can repay stablecoins such that they'll end up getting exactly the collateral\n            // in the liquidated vault\n            // Rounding up to make sure all gets liquidated in this case: the liquidator will never get more than the collateral\n            // amount in the vault however: we're performing the computation of the `collateralAmountInStable` again to avoid\n            // propagation of rounding errors\n            maxAmountToRepay =\n                (vault.collateralAmount * liquidationDiscount * oracleValue) /\n                (BASE_PARAMS * _collatBase) +\n                1;\n            // It should however make sure not to leave a dusty amount of collateral (in stablecoin value) in the vault\n            if (collateralAmountInStable > _dustCollateral)\n                // There's no issue with this amount being rounded down\n                thresholdRepayAmount =\n                    ((collateralAmountInStable - _dustCollateral) * liquidationDiscount) /\n                    BASE_PARAMS;\n                // If there is from the beginning a dusty amount of collateral, liquidator should repay everything that's left\n            else thresholdRepayAmount = maxAmountToRepay;\n        }\n        liqOpp.maxStablecoinAmountToRepay = maxAmountToRepay;\n        liqOpp.maxCollateralAmountGiven =\n            (maxAmountToRepay * BASE_PARAMS * _collatBase) /\n            (oracleValue * liquidationDiscount);\n        liqOpp.thresholdRepayAmount = thresholdRepayAmount;\n        liqOpp.discount = liquidationDiscount;\n        liqOpp.currentDebt = currentDebt;\n    }\n\n    /// @notice Computes the liquidation boost of a given address, that is the slope of the discount function\n    /// @param liquidator Address for which boost should be computed\n    /// @return The slope of the discount function\n    function _computeLiquidationBoost(address liquidator) internal view returns (uint256) {\n        if (address(veBoostProxy) == address(0)) {\n            return yLiquidationBoost[0];\n        } else {\n            uint256 adjustedBalance = veBoostProxy.adjusted_balance_of(liquidator);\n            if (adjustedBalance >= xLiquidationBoost[1]) return yLiquidationBoost[1];\n            else if (adjustedBalance <= xLiquidationBoost[0]) return yLiquidationBoost[0];\n            else\n                return\n                    yLiquidationBoost[0] +\n                    ((yLiquidationBoost[1] - yLiquidationBoost[0]) * (adjustedBalance - xLiquidationBoost[0])) /\n                    (xLiquidationBoost[1] - xLiquidationBoost[0]);\n        }\n    }\n\n    // ============================== Setters ======================================\n\n    /// @notice Sets parameters encoded as uint64\n    /// @param param Value for the parameter\n    /// @param what Parameter to change\n    /// @dev This function performs the required checks when updating a parameter\n    /// @dev When setting parameters governance should make sure that when `HF < CF/((1-surcharge)(1-discount))`\n    /// and hence when liquidating a vault is going to decrease its health factor, `discount = max discount`.\n    /// Otherwise, it may be profitable for the liquidator to liquidate in multiple times: as it will decrease\n    /// the HF and therefore increase the discount between each time\n    function setUint64(uint64 param, bytes32 what) external onlyGovernorOrGuardian {\n        if (what == \"CF\") {\n            if (param > liquidationSurcharge) revert TooHighParameterValue();\n            collateralFactor = param;\n        } else if (what == \"THF\") {\n            if (param < BASE_PARAMS) revert TooSmallParameterValue();\n            targetHealthFactor = param;\n        } else if (what == \"BF\") {\n            if (param > BASE_PARAMS) revert TooHighParameterValue();\n            borrowFee = param;\n        } else if (what == \"RF\") {\n            // As liquidation surcharge is stored as `1-fee` and as we need `repayFee` to be smaller\n            // then the liquidation surcharge, then we need to have:\n            // `liquidationSurcharge <= BASE_PARAMS - repayFee` and as such `liquidationSurcharge + repayFee <= BASE_PARAMS`\n            if (param + liquidationSurcharge > BASE_PARAMS) revert TooHighParameterValue();\n            repayFee = param;\n        } else if (what == \"IR\") {\n            _accrue();\n            interestRate = param;\n        } else if (what == \"LS\") {\n            if (collateralFactor > param || param + repayFee > BASE_PARAMS) revert InvalidParameterValue();\n            liquidationSurcharge = param;\n        } else if (what == \"MLD\") {\n            if (param > BASE_PARAMS) revert TooHighParameterValue();\n            maxLiquidationDiscount = param;\n        } else {\n            revert InvalidParameterType();\n        }\n        emit FiledUint64(param, what);\n    }\n\n    /// @notice Sets `debtCeiling`\n    /// @param _debtCeiling New value for `debtCeiling`\n    function setDebtCeiling(uint256 _debtCeiling) external onlyGovernorOrGuardian {\n        debtCeiling = _debtCeiling;\n        emit DebtCeilingUpdated(_debtCeiling);\n    }\n\n    /// @notice Sets the parameters for the liquidation booster which encodes the slope of the discount\n    /// @param _veBoostProxy Address which queries veANGLE balances and adjusted balances from delegation\n    /// @param xBoost Threshold values of veANGLE adjusted balances\n    /// @param yBoost Values of the liquidation boost at the threshold values of x\n    /// @dev There are 2 modes:\n    /// When boost is enabled, `xBoost` and `yBoost` should have a length of 2, but if they have a\n    /// higher length contract will still work as expected. Contract will also work as expected if their\n    /// length differ\n    /// When boost is disabled, `_veBoostProxy` needs to be zero address and `yBoost[0]` is the base boost\n    function setLiquidationBoostParameters(\n        address _veBoostProxy,\n        uint256[] memory xBoost,\n        uint256[] memory yBoost\n    ) external onlyGovernorOrGuardian {\n        if (\n            (xBoost.length != yBoost.length) ||\n            (yBoost[0] == 0) ||\n            ((_veBoostProxy != address(0)) && (xBoost[1] <= xBoost[0] || yBoost[1] < yBoost[0]))\n        ) revert InvalidSetOfParameters();\n        veBoostProxy = IVeBoostProxy(_veBoostProxy);\n        xLiquidationBoost = xBoost;\n        yLiquidationBoost = yBoost;\n        emit LiquidationBoostParametersUpdated(_veBoostProxy, xBoost, yBoost);\n    }\n\n    /// @notice Pauses external permissionless functions of the contract\n    function togglePause() external onlyGovernorOrGuardian {\n        paused = !paused;\n    }\n\n    /// @notice Changes the ERC721 metadata URI\n    function setBaseURI(string memory baseURI_) external onlyGovernorOrGuardian {\n        _baseURI = baseURI_;\n    }\n\n    /// @notice Changes the whitelisting of an address\n    /// @param target Address to toggle\n    /// @dev If the `target` address is the zero address then this function toggles whitelisting\n    /// for all addresses\n    function toggleWhitelist(address target) external onlyGovernor {\n        if (target != address(0)) {\n            isWhitelisted[target] = !isWhitelisted[target];\n        } else {\n            whitelistingActivated = !whitelistingActivated;\n        }\n    }\n\n    /// @notice Changes the reference to the oracle contract used to get the price of the oracle\n    /// @param _oracle Reference to the oracle contract\n    function setOracle(address _oracle) external onlyGovernor {\n        if (IOracle(_oracle).treasury() != treasury) revert InvalidTreasury();\n        oracle = IOracle(_oracle);\n    }\n\n    /// @inheritdoc IVaultManagerFunctions\n    function setTreasury(address _treasury) external onlyTreasury {\n        treasury = ITreasury(_treasury);\n        // This function makes sure to propagate the change to the associated contract\n        // even though a single oracle contract could be used in different places\n        oracle.setTreasury(_treasury);\n    }\n}\n"
    },
    "contracts/vaultManager/VaultManagerERC721.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./VaultManagerStorage.sol\";\n\n/// @title VaultManagerERC721\n/// @author Angle Core Team\n/// @dev Base ERC721 Implementation of VaultManager\nabstract contract VaultManagerERC721 is IERC721MetadataUpgradeable, VaultManagerStorage {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// @inheritdoc IERC721MetadataUpgradeable\n    string public name;\n    /// @inheritdoc IERC721MetadataUpgradeable\n    string public symbol;\n\n    // ============================== Modifiers ====================================\n\n    /// @notice Checks if the person interacting with the vault with `vaultID` is approved\n    /// @param caller Address of the person seeking to interact with the vault\n    /// @param vaultID ID of the concerned vault\n    modifier onlyApprovedOrOwner(address caller, uint256 vaultID) {\n        if (!_isApprovedOrOwner(caller, vaultID)) revert NotApproved();\n        _;\n    }\n\n    // =============================== ERC721 Logic ================================\n\n    /// @notice Returns all the vaults owned or controlled (under the form of approval) by an address\n    /// @param spender Address for which vault ownerships should be checked\n    /// @return List of `vaultID` controlled by this address\n    /// @return Count of vaults owned by the address\n    /// @dev This function is never to be called on-chain since it iterates over all vaultIDs. It is here\n    /// to reduce dependency on an external graph to link an ID to its owner\n    function getControlledVaults(address spender) external view returns (uint256[] memory, uint256) {\n        uint256 arraySize = vaultIDCount;\n        uint256[] memory vaultsControlled = new uint256[](arraySize);\n        address owner;\n        uint256 count;\n        for (uint256 i = 1; i <= arraySize; i++) {\n            owner = _owners[i];\n            if (spender == owner || _getApproved(i) == spender || _operatorApprovals[owner][spender]) {\n                vaultsControlled[count] = i;\n                count += 1;\n            }\n        }\n        return (vaultsControlled, count);\n    }\n\n    /// @notice Checks whether a given address is approved for a vault or owns this vault\n    /// @param spender Address for which vault ownership should be checked\n    /// @param vaultID ID of the vault to check\n    /// @return Whether the `spender` address owns or is approved for `vaultID`\n    function isApprovedOrOwner(address spender, uint256 vaultID) external view returns (bool) {\n        return _isApprovedOrOwner(spender, vaultID);\n    }\n\n    /// @inheritdoc IERC721MetadataUpgradeable\n    function tokenURI(uint256 vaultID) external view returns (string memory) {\n        if (!_exists(vaultID)) revert NonexistentVault();\n        // There is no vault with `vaultID` equal to 0, so the following variable is\n        // always greater than zero\n        uint256 temp = vaultID;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (vaultID != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(vaultID % 10)));\n            vaultID /= 10;\n        }\n        return bytes(_baseURI).length > 0 ? string(abi.encodePacked(_baseURI, string(buffer))) : \"\";\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function balanceOf(address owner) external view returns (uint256) {\n        if (owner == address(0)) revert ZeroAddress();\n        return _balances[owner];\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function ownerOf(uint256 vaultID) external view returns (address) {\n        return _ownerOf(vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function approve(address to, uint256 vaultID) external {\n        address owner = _ownerOf(vaultID);\n        if (to == owner) revert ApprovalToOwner();\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert NotApproved();\n\n        _approve(to, vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function getApproved(uint256 vaultID) external view returns (address) {\n        if (!_exists(vaultID)) revert NonexistentVault();\n        return _getApproved(vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function setApprovalForAll(address operator, bool approved) external {\n        if (operator == msg.sender) revert ApprovalToCaller();\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function transferFrom(\n        address from,\n        address to,\n        uint256 vaultID\n    ) external onlyApprovedOrOwner(msg.sender, vaultID) {\n        _transfer(from, to, vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 vaultID\n    ) external {\n        safeTransferFrom(from, to, vaultID, \"\");\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 vaultID,\n        bytes memory _data\n    ) public onlyApprovedOrOwner(msg.sender, vaultID) {\n        _safeTransfer(from, to, vaultID, _data);\n    }\n\n    // =============================== ERC165 logic ================================\n\n    /// @inheritdoc IERC165Upgradeable\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IVaultManager).interfaceId ||\n            interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    // ============== Internal Functions for the ERC721 Logic ======================\n\n    /// @notice Internal version of the `ownerOf` function\n    function _ownerOf(uint256 vaultID) internal view returns (address owner) {\n        owner = _owners[vaultID];\n        if (owner == address(0)) revert NonexistentVault();\n    }\n\n    /// @notice Internal version of the `getApproved` function\n    function _getApproved(uint256 vaultID) internal view returns (address) {\n        return _vaultApprovals[vaultID];\n    }\n\n    /// @notice Internal version of the `safeTransferFrom` function (with the data parameter)\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 vaultID,\n        bytes memory _data\n    ) internal {\n        _transfer(from, to, vaultID);\n        if (!_checkOnERC721Received(from, to, vaultID, _data)) revert NonERC721Receiver();\n    }\n\n    /// @notice Checks whether a vault exists\n    /// @param vaultID ID of the vault to check\n    /// @return Whether `vaultID` has been created\n    function _exists(uint256 vaultID) internal view returns (bool) {\n        return _owners[vaultID] != address(0);\n    }\n\n    /// @notice Internal version of the `isApprovedOrOwner` function\n    function _isApprovedOrOwner(address spender, uint256 vaultID) internal view returns (bool) {\n        // The following checks if the vault exists\n        address owner = _ownerOf(vaultID);\n        return (spender == owner || _getApproved(vaultID) == spender || _operatorApprovals[owner][spender]);\n    }\n\n    /// @notice Internal version of the `createVault` function\n    /// Mints `vaultID` and transfers it to `to`\n    /// @dev This method is equivalent to the `_safeMint` method used in OpenZeppelin ERC721 contract\n    /// @dev Emits a {Transfer} event\n    function _mint(address to) internal returns (uint256 vaultID) {\n        if (whitelistingActivated && (!isWhitelisted[to] || !isWhitelisted[msg.sender])) revert NotWhitelisted();\n        unchecked {\n            vaultIDCount += 1;\n            _balances[to] += 1;\n        }\n        vaultID = vaultIDCount;\n        _owners[vaultID] = to;\n        emit Transfer(address(0), to, vaultID);\n        if (!_checkOnERC721Received(address(0), to, vaultID, \"\")) revert NonERC721Receiver();\n    }\n\n    /// @notice Destroys `vaultID`\n    /// @dev `vaultID` must exist\n    /// @dev Emits a {Transfer} event\n    function _burn(uint256 vaultID) internal {\n        address owner = _ownerOf(vaultID);\n\n        // Clear approvals\n        _approve(address(0), vaultID);\n        // The following line cannot underflow as the owner's balance is necessarily\n        // greater than 1\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[vaultID];\n        delete vaultData[vaultID];\n\n        emit Transfer(owner, address(0), vaultID);\n    }\n\n    /// @notice Transfers `vaultID` from `from` to `to` as opposed to {transferFrom},\n    /// this imposes no restrictions on msg.sender\n    /// @dev `to` cannot be the zero address and `perpetualID` must be owned by `from`\n    /// @dev Emits a {Transfer} event\n    /// @dev A whitelist check is performed if necessary on the `to` address\n    function _transfer(\n        address from,\n        address to,\n        uint256 vaultID\n    ) internal {\n        if (_ownerOf(vaultID) != from) revert NotApproved();\n        if (to == address(0)) revert ZeroAddress();\n        if (whitelistingActivated && !isWhitelisted[to]) revert NotWhitelisted();\n        // Clear approvals from the previous owner\n        _approve(address(0), vaultID);\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[vaultID] = to;\n\n        emit Transfer(from, to, vaultID);\n    }\n\n    /// @notice Approves `to` to operate on `vaultID`\n    function _approve(address to, uint256 vaultID) internal {\n        _vaultApprovals[vaultID] = to;\n        emit Approval(_ownerOf(vaultID), to, vaultID);\n    }\n\n    /// @notice Internal function to invoke {IERC721Receiver-onERC721Received} on a target address\n    /// The call is not executed if the target address is not a contract\n    /// @param from Address representing the previous owner of the given token ID\n    /// @param to Target address that will receive the tokens\n    /// @param vaultID ID of the token to be transferred\n    /// @param _data Bytes optional data to send along with the call\n    /// @return Bool whether the call correctly returned the expected value\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 vaultID,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(msg.sender, from, vaultID, _data) returns (\n                bytes4 retval\n            ) {\n                return retval == IERC721ReceiverUpgradeable(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert NonERC721Receiver();\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n}\n"
    },
    "contracts/vaultManager/VaultManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/ISwapper.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IVaultManager.sol\";\nimport \"../interfaces/governance/IVeBoostProxy.sol\";\n\n/// @title VaultManagerStorage\n/// @author Angle Core Team\n/// @dev Variables, references, parameters and events needed in the `VaultManager` contract\n// solhint-disable-next-line max-states-count\ncontract VaultManagerStorage is IVaultManagerStorage, Initializable, ReentrancyGuardUpgradeable {\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_PARAMS = 10**9;\n    /// @notice Base used for interest rate computation\n    uint256 public constant BASE_INTEREST = 10**27;\n    /// @notice Used for interest rate computation\n    uint256 public constant HALF_BASE_INTEREST = 10**27 / 2;\n\n    // =============================== References ==================================\n\n    /// @inheritdoc IVaultManagerStorage\n    ITreasury public treasury;\n    /// @inheritdoc IVaultManagerStorage\n    IERC20 public collateral;\n    /// @inheritdoc IVaultManagerStorage\n    IAgToken public stablecoin;\n    /// @inheritdoc IVaultManagerStorage\n    IOracle public oracle;\n    /// @notice Reference to the contract which computes adjusted veANGLE balances for liquidators boosts\n    IVeBoostProxy public veBoostProxy;\n    /// @notice Base of the collateral\n    uint256 internal _collatBase;\n\n    // =============================== Parameters ==================================\n\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public immutable dust;\n    /// @notice Minimum amount of collateral (in stablecoin value) that can be left in a vault during a liquidation\n    /// where the health factor function is decreasing\n    uint256 internal immutable _dustCollateral;\n    /// @notice Maximum amount of stablecoins that can be issued with this contract\n    uint256 public debtCeiling;\n    /// @notice Threshold veANGLE balance values for the computation of the boost for liquidators: the length of this array\n    /// should be 2\n    uint256[] public xLiquidationBoost;\n    /// @notice Values of the liquidation boost at the threshold values of x\n    uint256[] public yLiquidationBoost;\n    /// @inheritdoc IVaultManagerStorage\n    uint64 public collateralFactor;\n    /// @notice Maximum Health factor at which a vault can end up after a liquidation (unless it's fully liquidated)\n    uint64 public targetHealthFactor;\n    /// @notice Upfront fee taken when borrowing stablecoins: this fee is optional and should in practice not be used\n    uint64 public borrowFee;\n    /// @notice Upfront fee taken when repaying stablecoins: this fee is optional as well. It should be smaller\n    /// than the liquidation surcharge (cf below) to avoid exploits where people voluntarily get liquidated at a 0\n    /// discount to pay smaller repaying fees\n    uint64 public repayFee;\n    /// @notice Per second interest taken to borrowers taking agToken loans\n    uint64 public interestRate;\n    /// @notice Fee taken by the protocol during a liquidation. Technically, this value is not the fee per se, it's 1 - fee.\n    /// For instance for a 2% fee, `liquidationSurcharge` should be 98%\n    uint64 public liquidationSurcharge;\n    /// @notice Maximum discount given to liquidators\n    uint64 public maxLiquidationDiscount;\n    /// @notice Whether whitelisting is required to own a vault or not\n    bool public whitelistingActivated;\n    /// @notice Whether the contract is paused or not\n    bool public paused;\n\n    // =============================== Variables ===================================\n\n    /// @notice Timestamp at which the `interestAccumulator` was updated\n    uint256 public lastInterestAccumulatorUpdated;\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public interestAccumulator;\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public totalNormalizedDebt;\n    /// @notice Surplus accumulated by the contract: surplus is always in stablecoins, and is then reset\n    /// when the value is communicated to the treasury contract\n    uint256 public surplus;\n    /// @notice Bad debt made from liquidated vaults which ended up having no collateral and a positive amount\n    /// of stablecoins\n    uint256 public badDebt;\n\n    // ================================ Mappings ===================================\n\n    /// @inheritdoc IVaultManagerStorage\n    mapping(uint256 => Vault) public vaultData;\n    /// @notice Maps an address to whether it's whitelisted and can open or own a vault\n    mapping(address => bool) public isWhitelisted;\n\n    // ================================ ERC721 Data ================================\n\n    /// @notice Counter to generate a unique `vaultID` for each vault: `vaultID` acts as `tokenID` in basic ERC721\n    /// contracts\n    uint256 public vaultIDCount;\n\n    /// @notice URI\n    string internal _baseURI;\n\n    // Mapping from `vaultID` to owner address\n    mapping(uint256 => address) internal _owners;\n\n    // Mapping from owner address to vault owned count\n    mapping(address => uint256) internal _balances;\n\n    // Mapping from `vaultID` to approved address\n    mapping(uint256 => address) internal _vaultApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\n\n    uint256[50] private __gap;\n\n    // =============================== Events ======================================\n\n    event AccruedToTreasury(uint256 surplusEndValue, uint256 badDebtEndValue);\n    event CollateralAmountUpdated(uint256 vaultID, uint256 collateralAmount, uint8 isIncrease);\n    event InterestAccumulatorUpdated(uint256 value, uint256 timestamp);\n    event InternalDebtUpdated(uint256 vaultID, uint256 internalAmount, uint8 isIncrease);\n    event FiledUint64(uint64 param, bytes32 what);\n    event DebtCeilingUpdated(uint256 debtCeiling);\n    event LiquidationBoostParametersUpdated(address indexed _veBoostProxy, uint256[] xBoost, uint256[] yBoost);\n    event LiquidatedVaults(uint256[] vaultIDs);\n\n    // =============================== Errors ======================================\n\n    error ApprovalToOwner();\n    error ApprovalToCaller();\n    error DustyLeftoverAmount();\n    error DebtCeilingExceeded();\n    error HealthyVault();\n    error IncompatibleLengths();\n    error InsolventVault();\n    error InvalidParameterValue();\n    error InvalidParameterType();\n    error InvalidSetOfParameters();\n    error InvalidTreasury();\n    error NonERC721Receiver();\n    error NonexistentVault();\n    error NotApproved();\n    error NotGovernor();\n    error NotGovernorOrGuardian();\n    error NotTreasury();\n    error NotWhitelisted();\n    error NotVaultManager();\n    error Paused();\n    error TooHighParameterValue();\n    error TooSmallParameterValue();\n    error ZeroAddress();\n\n    /// @param _dust Minimum amount of debt a vault from this implementation can have\n    /// @param dustCollateral_ Minimum amount of collateral (in stablecoin value) that can be left in a vault during a liquidation\n    /// where the health factor function is decreasing\n    /// @dev Run only at the implementation level\n    constructor(uint256 _dust, uint256 dustCollateral_) initializer {\n        dust = _dust;\n        _dustCollateral = dustCollateral_;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IAgToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @title IAgToken\n/// @author Angle Core Team\n/// @notice Interface for the stablecoins `AgToken` contracts\n/// @dev This interface only contains functions of the `AgToken` contract which are called by other contracts\n/// of this module or of the first module of the Angle Protocol\ninterface IAgToken is IERC20Upgradeable {\n    // ======================= Minter Role Only Functions ===========================\n\n    /// @notice Lets the `StableMaster` contract or another whitelisted contract mint agTokens\n    /// @param account Address to mint to\n    /// @param amount Amount to mint\n    /// @dev The contracts allowed to issue agTokens are the `StableMaster` contract, `VaultManager` contracts\n    /// associated to this stablecoin as well as the flash loan module (if activated) and potentially contracts\n    /// whitelisted by governance\n    function mint(address account, uint256 amount) external;\n\n    /// @notice Burns `amount` tokens from a `burner` address after being asked to by `sender`\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @param sender Address which requested the burn from `burner`\n    /// @dev This method is to be called by a contract with the minter right after being requested\n    /// to do so by a `sender` address willing to burn tokens from another `burner` address\n    /// @dev The method checks the allowance between the `sender` and the `burner`\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external;\n\n    /// @notice Burns `amount` tokens from a `burner` address\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @dev This method is to be called by a contract with a minter right on the AgToken after being\n    /// requested to do so by an address willing to burn tokens from its address\n    function burnSelf(uint256 amount, address burner) external;\n\n    // ========================= Treasury Only Functions ===========================\n\n    /// @notice Adds a minter in the contract\n    /// @param minter Minter address to add\n    /// @dev Zero address checks are performed directly in the `Treasury` contract\n    function addMinter(address minter) external;\n\n    /// @notice Removes a minter from the contract\n    /// @param minter Minter address to remove\n    /// @dev This function can also be called by a minter wishing to revoke itself\n    function removeMinter(address minter) external;\n\n    /// @notice Sets a new treasury contract\n    /// @param _treasury New treasury address\n    function setTreasury(address _treasury) external;\n\n    // ========================= External functions ================================\n\n    /// @notice Checks whether an address has the right to mint agTokens\n    /// @param minter Address for which the minting right should be checked\n    /// @return Whether the address has the right to mint agTokens or not\n    function isMinter(address minter) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./ITreasury.sol\";\n\n/// @title IOracle\n/// @author Angle Core Team\n/// @notice Interface for the `Oracle` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module\ninterface IOracle {\n    /// @notice Reads the rate from the Chainlink circuit and other data provided\n    /// @return quoteAmount The current rate between the in-currency and out-currency in the base\n    /// of the out currency\n    /// @dev For instance if the out currency is EUR (and hence agEUR), then the base of the returned\n    /// value is 10**18\n    function read() external view returns (uint256);\n\n    /// @notice Changes the treasury contract\n    /// @param _treasury Address of the new treasury contract\n    /// @dev This function can be called by an approved `VaultManager` contract which can call\n    /// this function after being requested to do so by a `treasury` contract\n    /// @dev In some situations (like reactor contracts), the `VaultManager` may not directly be linked\n    /// to the `oracle` contract and as such we may need governors to be able to call this function as well\n    function setTreasury(address _treasury) external;\n\n    /// @notice Reference to the `treasury` contract handling this `VaultManager`\n    function treasury() external view returns (ITreasury treasury);\n}\n"
    },
    "contracts/interfaces/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title ISwapper\n/// @author Angle Core Team\n/// @notice Interface for Swapper contracts\n/// @dev This interface defines the key functions `Swapper` contracts should have when interacting with\n/// Angle\ninterface ISwapper {\n    /// @notice Notifies a contract that an address should be given `outToken` from `inToken`\n    /// @param inToken Address of the token received\n    /// @param outToken Address of the token to obtain\n    /// @param outTokenRecipient Address to which the outToken should be sent\n    /// @param outTokenOwed Amount of outToken owed to the address\n    /// @param inTokenObtained Amount of collateral obtained by a related address prior\n    /// to the call to this function\n    /// @param data Extra data needed (to encode Uniswap swaps for instance)\n    function swap(\n        IERC20 inToken,\n        IERC20 outToken,\n        address outTokenRecipient,\n        uint256 outTokenOwed,\n        uint256 inTokenObtained,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./IAgToken.sol\";\nimport \"./ICoreBorrow.sol\";\nimport \"./IFlashAngle.sol\";\n\n/// @title ITreasury\n/// @author Angle Core Team\n/// @notice Interface for the `Treasury` contract\n/// @dev This interface only contains functions of the `Treasury` which are called by other contracts\n/// of this module\ninterface ITreasury {\n    /// @notice Stablecoin handled by this `treasury` contract\n    function stablecoin() external view returns (IAgToken);\n\n    /// @notice Checks whether a given address has the  governor role\n    /// @param admin Address to check\n    /// @return Whether the address has the governor role\n    /// @dev Access control is only kept in the `CoreBorrow` contract\n    function isGovernor(address admin) external view returns (bool);\n\n    /// @notice Checks whether a given address has the guardian or the governor role\n    /// @param admin Address to check\n    /// @return Whether the address has the guardian or the governor role\n    /// @dev Access control is only kept in the `CoreBorrow` contract which means that this function\n    /// queries the `CoreBorrow` contract\n    function isGovernorOrGuardian(address admin) external view returns (bool);\n\n    /// @notice Checks whether a given address has well been initialized in this contract\n    /// as a `VaultManager``\n    /// @param _vaultManager Address to check\n    /// @return Whether the address has been initialized or not\n    function isVaultManager(address _vaultManager) external view returns (bool);\n\n    /// @notice Sets a new flash loan module for this stablecoin\n    /// @param _flashLoanModule Reference to the new flash loan module\n    /// @dev This function removes the minting right to the old flash loan module and grants\n    /// it to the new module\n    function setFlashLoanModule(address _flashLoanModule) external;\n}\n"
    },
    "contracts/interfaces/IVaultManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ITreasury.sol\";\nimport \"./IOracle.sol\";\n\n// ========================= Key Structs and Enums =============================\n\n/// @notice Parameters associated to a given `VaultManager` contract: these all correspond\n/// to parameters which signification is detailed in the `VaultManagerStorage` file\nstruct VaultParameters {\n    uint256 debtCeiling;\n    uint64 collateralFactor;\n    uint64 targetHealthFactor;\n    uint64 interestRate;\n    uint64 liquidationSurcharge;\n    uint64 maxLiquidationDiscount;\n    bool whitelistingActivated;\n    uint256 baseBoost;\n}\n\n/// @notice Data stored to track someone's loan (or equivalently called position)\nstruct Vault {\n    // Amount of collateral deposited in the vault\n    uint256 collateralAmount;\n    // Normalized value of the debt (that is to say of the stablecoins borrowed)\n    uint256 normalizedDebt;\n}\n\n/// @notice For a given `vaultID`, this encodes a liquidation opportunity that is to say details about the maximum\n/// amount that could be repaid by liquidating the position\n/// @dev All the values are null in the case of a vault which cannot be liquidated under these conditions\nstruct LiquidationOpportunity {\n    // Maximum stablecoin amount that can be repaid upon liquidating the vault\n    uint256 maxStablecoinAmountToRepay;\n    // Collateral amount given to the person in the case where the maximum amount to repay is given\n    uint256 maxCollateralAmountGiven;\n    // Threshold value of stablecoin amount to repay: it is ok for a liquidator to repay below threshold,\n    // but if this threshold is non null and the liquidator wants to repay more than threshold, it should repay\n    // the max stablecoin amount given in this vault\n    uint256 thresholdRepayAmount;\n    // Discount proposed to the liquidator on the collateral\n    uint256 discount;\n    // Amount of debt in the vault\n    uint256 currentDebt;\n}\n\n/// @notice Data stored during a liquidation process to keep in memory what's due to a liquidator and some\n/// essential data for vaults being liquidated\nstruct LiquidatorData {\n    // Current amount of stablecoins the liquidator should give to the contract\n    uint256 stablecoinAmountToReceive;\n    // Current amount of collateral the contract should give to the liquidator\n    uint256 collateralAmountToGive;\n    // Bad debt accrued across the liquidation process\n    uint256 badDebtFromLiquidation;\n    // Oracle value (in stablecoin base) at the time of the liquidation\n    uint256 oracleValue;\n    // Value of the `interestAccumulator` at the time of the call\n    uint256 newInterestAccumulator;\n}\n\n/// @notice Data to track during a series of action the amount to give or receive in stablecoins and collateral\n/// to the caller or associated addresses\nstruct PaymentData {\n    // Stablecoin amount the contract should give\n    uint256 stablecoinAmountToGive;\n    // Stablecoin amount owed to the contract\n    uint256 stablecoinAmountToReceive;\n    // Collateral amount the contract should give\n    uint256 collateralAmountToGive;\n    // Collateral amount owed to the contract\n    uint256 collateralAmountToReceive;\n}\n\n/// @notice Actions possible when composing calls to the different entry functions proposed\nenum ActionType {\n    createVault,\n    closeVault,\n    addCollateral,\n    removeCollateral,\n    repayDebt,\n    borrow,\n    getDebtIn,\n    permit\n}\n\n// ========================= Interfaces =============================\n\n/// @title IVaultManagerFunctions\n/// @author Angle Core Team\n/// @notice Interface for the `VaultManager` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module (without getters)\ninterface IVaultManagerFunctions {\n    /// @notice Accrues interest accumulated across all vaults to the surplus and sends the surplus to the treasury\n    /// @return surplusValue Value of the surplus communicated to the `Treasury`\n    /// @return badDebtValue Value of the bad debt communicated to the `Treasury`\n    /// @dev `surplus` and `badDebt` should be reset to 0 once their current value have been given to the `treasury` contract\n    function accrueInterestToTreasury() external returns (uint256 surplusValue, uint256 badDebtValue);\n\n    /// @notice Removes debt from a vault after being requested to do so by another `VaultManager` contract\n    /// @param vaultID ID of the vault to remove debt from\n    /// @param amountStablecoins Amount of stablecoins to remove from the debt: this amount is to be converted to an\n    /// internal debt amount\n    /// @param senderBorrowFee Borrowing fees from the contract which requested this: this is to make sure that people are not\n    /// arbitraging difference in minting fees\n    /// @param senderRepayFee Repay fees from the contract which requested this: this is to make sure that people are not arbitraging\n    /// differences in repay fees\n    /// @dev This function can only be called from a vaultManager registered in the same Treasury\n    function getDebtOut(\n        uint256 vaultID,\n        uint256 amountStablecoins,\n        uint256 senderBorrowFee,\n        uint256 senderRepayFee\n    ) external;\n\n    /// @notice Gets the current debt of a vault\n    /// @param vaultID ID of the vault to check\n    /// @return Debt of the vault\n    function getVaultDebt(uint256 vaultID) external view returns (uint256);\n\n    /// @notice Gets the total debt across all vaults\n    /// @return Total debt across all vaults, taking into account the interest accumulated\n    /// over time\n    function getTotalDebt() external view returns (uint256);\n\n    /// @notice Sets the treasury contract\n    /// @param _treasury New treasury contract\n    /// @dev All required checks when setting up a treasury contract are performed in the contract\n    /// calling this function\n    function setTreasury(address _treasury) external;\n\n    /// @notice Creates a vault\n    /// @param toVault Address for which the va\n    /// @return vaultID ID of the vault created\n    /// @dev This function just creates the vault without doing any collateral or\n    function createVault(address toVault) external returns (uint256);\n\n    /// @notice Allows composability between calls to the different entry points of this module. Any user calling\n    /// this function can perform any of the allowed actions in the order of their choice\n    /// @param actions Set of actions to perform\n    /// @param datas Data to be decoded for each action: it can include like the `vaultID` or the `stablecoinAmount` to borrow\n    /// @param from Address from which stablecoins will be taken if one action includes burning stablecoins. This address\n    /// should either be the `msg.sender` or be approved by the latter\n    /// @param to Address to which stablecoins and/or collateral will be sent in case of\n    /// @param who Address of the contract to handle in case of repayment of stablecoins from received collateral\n    /// @param repayData Data to pass to the repayment contract in case of\n    /// @return paymentData Struct containing the final transfers executed\n    /// @dev This function is optimized to reduce gas cost due to payment from or to the user and that expensive calls\n    /// or computations (like `oracleValue`) are done only once\n    function angle(\n        ActionType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to,\n        address who,\n        bytes memory repayData\n    ) external payable returns (PaymentData memory paymentData);\n\n    /// @notice This function is a wrapper built on top of the function above. It enables users to interact with the contract\n    /// without having to provide `who` and `repayData` parameters\n    function angle(\n        ActionType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to\n    ) external payable returns (PaymentData memory paymentData);\n\n    /// @notice Initializes the `VaultManager` contract\n    /// @param _treasury Treasury address handling the contract\n    /// @param _collateral Collateral supported by this contract\n    /// @param _oracle Oracle contract used\n    /// @param _symbol Symbol used to define the `VaultManager` name and symbol\n    /// @dev The parameters and the oracle are the only elements which could be modified once the\n    /// contract has been initialized\n    /// @dev For the contract to be fully initialized, governance needs to set the parameters for the liquidation\n    /// boost\n    function initialize(\n        ITreasury _treasury,\n        IERC20 _collateral,\n        IOracle _oracle,\n        VaultParameters calldata params,\n        string memory _symbol\n    ) external;\n}\n\n/// @title IVaultManagerStorage\n/// @author Angle Core Team\n/// @notice Interface for the `VaultManager` contract\n/// @dev This interface contains getters of the contract's public variables used by other contracts\n/// of this module\ninterface IVaultManagerStorage {\n    /// @notice Minimum amount of debt a vault can have\n    function dust() external view returns (uint256);\n\n    /// @notice Encodes the maximum ratio stablecoin/collateral a vault can have before being liquidated. It's what\n    /// determines the minimum collateral ratio of a position\n    function collateralFactor() external view returns (uint64);\n\n    /// @notice Stablecoin handled by this contract. Another `VaultManager` contract could have\n    /// the same rights as this `VaultManager` on the stablecoin contract\n    function stablecoin() external view returns (IAgToken);\n\n    /// @notice Reference to the `treasury` contract handling this `VaultManager`\n    function treasury() external view returns (ITreasury);\n\n    /// @notice Oracle contract to get access to the price of the collateral with respect to the stablecoin\n    function oracle() external view returns (IOracle);\n\n    /// @notice The `interestAccumulator` variable keeps track of the interest that should accrue to the protocol.\n    /// The stored value is not necessarily the true value: this one is recomputed every time an action takes place\n    /// within the protocol\n    function interestAccumulator() external view returns (uint256);\n\n    /// @notice Reference to the collateral handled by this `VaultManager`\n    function collateral() external view returns (IERC20);\n\n    /// @notice Total normalized amount of stablecoins borrowed, not taking into account the potential bad debt accumulated\n    function totalNormalizedDebt() external view returns (uint256);\n\n    /// @notice Maximum amount of stablecoins that can be issued with this contract\n    function debtCeiling() external view returns (uint256);\n\n    /// @notice Maps a `vaultID` to its data (namely collateral amount and normalized debt)\n    function vaultData(uint256 vaultID) external view returns (uint256 collateralAmount, uint256 normalizedDebt);\n}\n\n/// @title IVaultManager\n/// @author Angle Core Team\n/// @notice Interface for the `VaultManager` contract\ninterface IVaultManager is IVaultManagerFunctions, IVaultManagerStorage, IERC721Metadata {\n\n}\n"
    },
    "contracts/interfaces/governance/IVeBoostProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title IVeBoostProxy\n/// @author Angle Core Team\n/// @notice Interface for the `VeBoostProxy` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module\n/// @dev The `veBoostProxy` contract used by Angle is a full fork of Curve Finance implementation\ninterface IVeBoostProxy {\n    /// @notice Reads the adjusted veANGLE balance of an address (adjusted by delegation)\n    //solhint-disable-next-line\n    function adjusted_balance_of(address) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/ICoreBorrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title ICoreBorrow\n/// @author Angle Core Team\n/// @notice Interface for the `CoreBorrow` contract\n/// @dev This interface only contains functions of the `CoreBorrow` contract which are called by other contracts\n/// of this module\ninterface ICoreBorrow {\n    /// @notice Checks if an address corresponds to a treasury of a stablecoin with a flash loan\n    /// module initialized on it\n    /// @param treasury Address to check\n    /// @return Whether the address has the `FLASHLOANER_TREASURY_ROLE` or not\n    function isFlashLoanerTreasury(address treasury) external view returns (bool);\n\n    /// @notice Checks whether an address is governor of the Angle Protocol or not\n    /// @param admin Address to check\n    /// @return Whether the address has the `GOVERNOR_ROLE` or not\n    function isGovernor(address admin) external view returns (bool);\n\n    /// @notice Checks whether an address is governor or a guardian of the Angle Protocol or not\n    /// @param admin Address to check\n    /// @return Whether the address has the `GUARDIAN_ROLE` or not\n    /// @dev Governance should make sure when adding a governor to also give this governor the guardian\n    /// role by calling the `addGovernor` function\n    function isGovernorOrGuardian(address admin) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IFlashAngle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./IAgToken.sol\";\nimport \"./ICoreBorrow.sol\";\n\n/// @title IFlashAngle\n/// @author Angle Core Team\n/// @notice Interface for the `FlashAngle` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module\ninterface IFlashAngle {\n    /// @notice Reference to the `CoreBorrow` contract managing the FlashLoan module\n    function core() external view returns (ICoreBorrow);\n\n    /// @notice Sends the fees taken from flash loans to the treasury contract associated to the stablecoin\n    /// @param stablecoin Stablecoin from which profits should be sent\n    /// @return balance Amount of profits sent\n    /// @dev This function can only be called by the treasury contract\n    function accrueInterestToTreasury(IAgToken stablecoin) external returns (uint256 balance);\n\n    /// @notice Adds support for a stablecoin\n    /// @param _treasury Treasury associated to the stablecoin to add support for\n    /// @dev This function can only be called by the `CoreBorrow` contract\n    function addStablecoinSupport(address _treasury) external;\n\n    /// @notice Removes support for a stablecoin\n    /// @param _treasury Treasury associated to the stablecoin to remove support for\n    /// @dev This function can only be called by the `CoreBorrow` contract\n    function removeStablecoinSupport(address _treasury) external;\n\n    /// @notice Sets a new core contract\n    /// @param _core Core contract address to set\n    /// @dev This function can only be called by the `CoreBorrow` contract\n    function setCore(address _core) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721Metadata.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}