{
  "language": "Solidity",
  "sources": {
    "contracts/agToken/AgToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/IStableMaster.sol\";\nimport \"../interfaces/ITreasury.sol\";\n// OpenZeppelin may update its version of the ERC20PermitUpgradeable token\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\n/// @title AgToken\n/// @author Angle Core Team\n/// @notice Base contract for agToken, that is to say Angle's stablecoins\n/// @dev This contract is used to create and handle the stablecoins of Angle protocol\n/// @dev It is still possible for any address to burn its agTokens without redeeming collateral in exchange\n/// @dev This contract is the upgraded version of the AgToken that was first deployed on Ethereum mainnet\ncontract AgToken is IAgToken, ERC20PermitUpgradeable {\n    // ========================= References to other contracts =====================\n\n    /// @notice Reference to the `StableMaster` contract associated to this `AgToken`\n    address public stableMaster;\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializes the `AgToken` contract\n    /// @param name_ Name of the token\n    /// @param symbol_ Symbol of the token\n    /// @param stableMaster_ Reference to the `StableMaster` contract associated to this agToken\n    /// @dev By default, agTokens are ERC-20 tokens with 18 decimals\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address stableMaster_\n    ) external initializer {\n        __ERC20Permit_init(name_);\n        __ERC20_init(name_, symbol_);\n        require(stableMaster_ != address(0), \"0\");\n        stableMaster = stableMaster_;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ======= Added Parameters and Variables from the first implementation ========\n\n    /// @inheritdoc IAgToken\n    mapping(address => bool) public isMinter;\n    /// @notice Reference to the treasury contract which can grant minting rights\n    ITreasury public treasury;\n    /// @notice Boolean to check whether the contract has been reinitialized after its upgrade\n    bool public treasuryInitialized;\n\n    // =============================== Added Events ================================\n\n    event TreasuryUpdated(address indexed _treasury);\n    event MinterToggled(address indexed minter);\n\n    // =============================== Setup Function ==============================\n\n    /// @notice Sets up the treasury contract in this AgToken contract\n    /// @param _treasury Treasury contract to add\n    /// @dev The address calling this function has to be hard-coded in the contract\n    function setUpTreasury(address _treasury) external {\n        require(msg.sender == 0xdC4e6DFe07EFCa50a197DF15D9200883eF4Eb1c8, \"1\");\n        require(address(ITreasury(_treasury).stablecoin()) == address(this), \"6\");\n        require(!treasuryInitialized, \"34\");\n        treasury = ITreasury(_treasury);\n        treasuryInitialized = true;\n        isMinter[stableMaster] = true;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // =============================== Modifiers ===================================\n\n    /// @notice Checks to see if it is the `StableMaster` calling this contract\n    /// @dev There is no Access Control here, because it can be handled cheaply through this modifier\n    modifier onlyTreasury() {\n        require(msg.sender == address(treasury), \"1\");\n        _;\n    }\n\n    /// @notice Checks whether the sender has the minting right\n    modifier onlyMinter() {\n        require(isMinter[msg.sender], \"35\");\n        _;\n    }\n\n    // ========================= External Functions ================================\n    // The following functions allow anyone to burn stablecoins without redeeming collateral\n    // in exchange for that\n\n    /// @notice Destroys `amount` token from the caller without giving collateral back\n    /// @param amount Amount to burn\n    /// @param poolManager Reference to the `PoolManager` contract for which the `stocksUsers` will\n    /// need to be updated\n    /// @dev When calling this function, people should specify the `poolManager` for which they want to decrease\n    /// the `stocksUsers`: this a way for the protocol to maintain healthy accounting variables\n    function burnNoRedeem(uint256 amount, address poolManager) external {\n        _burn(msg.sender, amount);\n        IStableMaster(stableMaster).updateStocksUsers(amount, poolManager);\n    }\n\n    /// @notice Burns `amount` of agToken on behalf of another account without redeeming collateral back\n    /// @param account Account to burn on behalf of\n    /// @param amount Amount to burn\n    /// @param poolManager Reference to the `PoolManager` contract for which the `stocksUsers` will need to be updated\n    function burnFromNoRedeem(\n        address account,\n        uint256 amount,\n        address poolManager\n    ) external {\n        _burnFromNoRedeem(amount, account, msg.sender);\n        IStableMaster(stableMaster).updateStocksUsers(amount, poolManager);\n    }\n\n    /// @notice Allows anyone to burn agToken without redeeming collateral back\n    /// @param amount Amount of stablecoins to burn\n    /// @dev This function can typically be called if there is a settlement mechanism to burn stablecoins\n    function burnStablecoin(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    // ======================= Minter Role Only Functions ==========================\n\n    /// @inheritdoc IAgToken\n    function burnSelf(uint256 amount, address burner) external onlyMinter {\n        _burn(burner, amount);\n    }\n\n    /// @inheritdoc IAgToken\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external onlyMinter {\n        _burnFromNoRedeem(amount, burner, sender);\n    }\n\n    /// @inheritdoc IAgToken\n    function mint(address account, uint256 amount) external onlyMinter {\n        _mint(account, amount);\n    }\n\n    // ======================= Treasury Only Functions =============================\n\n    /// @inheritdoc IAgToken\n    function addMinter(address minter) external onlyTreasury {\n        require(minter != address(0), \"0\");\n        isMinter[minter] = true;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function removeMinter(address minter) external {\n        // The `treasury` contract cannot remove the `stableMaster`\n        require((msg.sender == address(treasury) && minter != stableMaster) || msg.sender == minter, \"36\");\n        isMinter[minter] = false;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function setTreasury(address _treasury) external onlyTreasury {\n        treasury = ITreasury(_treasury);\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // ============================ Internal Function ==============================\n\n    /// @notice Internal version of the function `burnFromNoRedeem`\n    /// @param amount Amount to burn\n    /// @dev It is at the level of this function that allowance checks are performed\n    function _burnFromNoRedeem(\n        uint256 amount,\n        address burner,\n        address sender\n    ) internal {\n        if (burner != sender) {\n            uint256 currentAllowance = allowance(burner, sender);\n            require(currentAllowance >= amount, \"23\");\n            _approve(burner, sender, currentAllowance - amount);\n        }\n        _burn(burner, amount);\n    }\n}\n"
    },
    "contracts/interfaces/IAgToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @title IAgToken\n/// @author Angle Core Team\n/// @notice Interface for the stablecoins `AgToken` contracts\n/// @dev This interface only contains functions of the `AgToken` contract which are called by other contracts\n/// of this module or of the first module of the Angle Protocol\ninterface IAgToken is IERC20Upgradeable {\n    // ======================= Minter Role Only Functions ===========================\n\n    /// @notice Lets the `StableMaster` contract or another whitelisted contract mint agTokens\n    /// @param account Address to mint to\n    /// @param amount Amount to mint\n    /// @dev The contracts allowed to issue agTokens are the `StableMaster` contract, `VaultManager` contracts\n    /// associated to this stablecoin as well as the flash loan module (if activated) and potentially contracts\n    /// whitelisted by governance\n    function mint(address account, uint256 amount) external;\n\n    /// @notice Burns `amount` tokens from a `burner` address after being asked to by `sender`\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @param sender Address which requested the burn from `burner`\n    /// @dev This method is to be called by a contract with the minter right after being requested\n    /// to do so by a `sender` address willing to burn tokens from another `burner` address\n    /// @dev The method checks the allowance between the `sender` and the `burner`\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external;\n\n    /// @notice Burns `amount` tokens from a `burner` address\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @dev This method is to be called by a contract with a minter right on the AgToken after being\n    /// requested to do so by an address willing to burn tokens from its address\n    function burnSelf(uint256 amount, address burner) external;\n\n    // ========================= Treasury Only Functions ===========================\n\n    /// @notice Adds a minter in the contract\n    /// @param minter Minter address to add\n    /// @dev Zero address checks are performed directly in the `Treasury` contract\n    function addMinter(address minter) external;\n\n    /// @notice Removes a minter from the contract\n    /// @param minter Minter address to remove\n    /// @dev This function can also be called by a minter wishing to revoke itself\n    function removeMinter(address minter) external;\n\n    /// @notice Sets a new treasury contract\n    /// @param _treasury New treasury address\n    function setTreasury(address _treasury) external;\n\n    // ========================= External functions ================================\n\n    /// @notice Checks whether an address has the right to mint agTokens\n    /// @param minter Address for which the minting right should be checked\n    /// @return Whether the address has the right to mint agTokens or not\n    function isMinter(address minter) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IStableMaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title IStableMaster\n/// @author Angle Core Team\n/// @notice Interface for the `StableMaster` contract\n/// @dev This interface only contains functions of the `StableMaster` contract which are called by other contracts\n/// of this module\ninterface IStableMaster {\n    function updateStocksUsers(uint256 amount, address poolManager) external;\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./IAgToken.sol\";\nimport \"./ICoreBorrow.sol\";\nimport \"./IFlashAngle.sol\";\n\n/// @title ITreasury\n/// @author Angle Core Team\n/// @notice Interface for the `Treasury` contract\n/// @dev This interface only contains functions of the `Treasury` which are called by other contracts\n/// of this module\ninterface ITreasury {\n    /// @notice Stablecoin handled by this `treasury` contract\n    function stablecoin() external view returns (IAgToken);\n\n    /// @notice Checks whether a given address has the  governor role\n    /// @param admin Address to check\n    /// @return Whether the address has the governor role\n    /// @dev Access control is only kept in the `CoreBorrow` contract\n    function isGovernor(address admin) external view returns (bool);\n\n    /// @notice Checks whether a given address has the guardian or the governor role\n    /// @param admin Address to check\n    /// @return Whether the address has the guardian or the governor role\n    /// @dev Access control is only kept in the `CoreBorrow` contract which means that this function\n    /// queries the `CoreBorrow` contract\n    function isGovernorOrGuardian(address admin) external view returns (bool);\n\n    /// @notice Checks whether a given address has well been initialized in this contract\n    /// as a `VaultManager``\n    /// @param _vaultManager Address to check\n    /// @return Whether the address has been initialized or not\n    function isVaultManager(address _vaultManager) external view returns (bool);\n\n    /// @notice Sets a new flash loan module for this stablecoin\n    /// @param _flashLoanModule Reference to the new flash loan module\n    /// @dev This function removes the minting right to the old flash loan module and grants\n    /// it to the new module\n    function setFlashLoanModule(address _flashLoanModule) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal onlyInitializing {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/ICoreBorrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title ICoreBorrow\n/// @author Angle Core Team\n/// @notice Interface for the `CoreBorrow` contract\n/// @dev This interface only contains functions of the `CoreBorrow` contract which are called by other contracts\n/// of this module\ninterface ICoreBorrow {\n    /// @notice Checks if an address corresponds to a treasury of a stablecoin with a flash loan\n    /// module initialized on it\n    /// @param treasury Address to check\n    /// @return Whether the address has the `FLASHLOANER_TREASURY_ROLE` or not\n    function isFlashLoanerTreasury(address treasury) external view returns (bool);\n\n    /// @notice Checks whether an address is governor of the Angle Protocol or not\n    /// @param admin Address to check\n    /// @return Whether the address has the `GOVERNOR_ROLE` or not\n    function isGovernor(address admin) external view returns (bool);\n\n    /// @notice Checks whether an address is governor or a guardian of the Angle Protocol or not\n    /// @param admin Address to check\n    /// @return Whether the address has the `GUARDIAN_ROLE` or not\n    /// @dev Governance should make sure when adding a governor to also give this governor the guardian\n    /// role by calling the `addGovernor` function\n    function isGovernorOrGuardian(address admin) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IFlashAngle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./IAgToken.sol\";\nimport \"./ICoreBorrow.sol\";\n\n/// @title IFlashAngle\n/// @author Angle Core Team\n/// @notice Interface for the `FlashAngle` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module\ninterface IFlashAngle {\n    /// @notice Reference to the `CoreBorrow` contract managing the FlashLoan module\n    function core() external view returns (ICoreBorrow);\n\n    /// @notice Sends the fees taken from flash loans to the treasury contract associated to the stablecoin\n    /// @param stablecoin Stablecoin from which profits should be sent\n    /// @return balance Amount of profits sent\n    /// @dev This function can only be called by the treasury contract\n    function accrueInterestToTreasury(IAgToken stablecoin) external returns (uint256 balance);\n\n    /// @notice Adds support for a stablecoin\n    /// @param _treasury Treasury associated to the stablecoin to add support for\n    /// @dev This function can only be called by the `CoreBorrow` contract\n    function addStablecoinSupport(address _treasury) external;\n\n    /// @notice Removes support for a stablecoin\n    /// @param _treasury Treasury associated to the stablecoin to remove support for\n    /// @dev This function can only be called by the `CoreBorrow` contract\n    function removeStablecoinSupport(address _treasury) external;\n\n    /// @notice Sets a new core contract\n    /// @param _core Core contract address to set\n    /// @dev This function can only be called by the `CoreBorrow` contract\n    function setCore(address _core) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/agToken/AgTokenSideChain.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/IStableMaster.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\n/// @title AgTokenSideChain\n/// @author Angle Core Team\n/// @notice Contract for Angle agTokens to be deployed on any other chain than Ethereum mainnet\n/// @dev This contract is used to create and handle the stablecoins of Angle protocol\n/// @dev It is still possible for any address to burn its agTokens without redeeming collateral in exchange\ncontract AgTokenSideChain is IAgToken, ERC20PermitUpgradeable {\n    // ======================= Parameters and Variables ============================\n\n    /// @inheritdoc IAgToken\n    mapping(address => bool) public isMinter;\n    /// @notice Reference to the treasury contract which can grant minting rights\n    ITreasury public treasury;\n\n    // ================================== Events ===================================\n\n    event TreasuryUpdated(address indexed _treasury);\n    event MinterToggled(address indexed minter);\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializes the `AgToken` contract\n    /// @param name_ Name of the token\n    /// @param symbol_ Symbol of the token\n    /// @param _treasury Reference to the `Treasury` contract associated to this agToken\n    /// @dev By default, agTokens are ERC-20 tokens with 18 decimals\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        ITreasury _treasury\n    ) external initializer {\n        __ERC20Permit_init(name_);\n        __ERC20_init(name_, symbol_);\n        require(address(ITreasury(_treasury).stablecoin()) == address(this), \"6\");\n        treasury = ITreasury(_treasury);\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // =============================== Modifiers ===================================\n\n    /// @notice Checks to see if it is the `StableMaster` calling this contract\n    /// @dev There is no Access Control here, because it can be handled cheaply through this modifier\n    modifier onlyTreasury() {\n        require(msg.sender == address(treasury), \"1\");\n        _;\n    }\n\n    /// @notice Checks whether the sender has the minting right\n    modifier onlyMinter() {\n        require(isMinter[msg.sender], \"35\");\n        _;\n    }\n\n    // =========================== External Function ===============================\n\n    /// @notice Allows anyone to burn agToken without redeeming collateral back\n    /// @param amount Amount of stablecoins to burn\n    /// @dev This function can typically be called if there is a settlement mechanism to burn stablecoins\n    function burnStablecoin(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    // ======================= Minter Role Only Functions ==========================\n\n    /// @inheritdoc IAgToken\n    function burnSelf(uint256 amount, address burner) external onlyMinter {\n        _burn(burner, amount);\n    }\n\n    /// @inheritdoc IAgToken\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external onlyMinter {\n        _burnFromNoRedeem(amount, burner, sender);\n    }\n\n    /// @inheritdoc IAgToken\n    function mint(address account, uint256 amount) external onlyMinter {\n        _mint(account, amount);\n    }\n\n    // ======================= Treasury Only Functions =============================\n\n    /// @inheritdoc IAgToken\n    function addMinter(address minter) external onlyTreasury {\n        require(minter != address(0), \"0\");\n        isMinter[minter] = true;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function removeMinter(address minter) external {\n        require(msg.sender == address(treasury) || msg.sender == minter, \"36\");\n        isMinter[minter] = false;\n        emit MinterToggled(minter);\n    }\n\n    /// @inheritdoc IAgToken\n    function setTreasury(address _treasury) external onlyTreasury {\n        treasury = ITreasury(_treasury);\n        emit TreasuryUpdated(_treasury);\n    }\n\n    // ============================ Internal Function ==============================\n\n    /// @notice Internal version of the function `burnFromNoRedeem`\n    /// @param amount Amount to burn\n    /// @dev It is at the level of this function that allowance checks are performed\n    function _burnFromNoRedeem(\n        uint256 amount,\n        address burner,\n        address sender\n    ) internal {\n        if (burner != sender) {\n            uint256 currentAllowance = allowance(burner, sender);\n            require(currentAllowance >= amount, \"23\");\n            _approve(burner, sender, currentAllowance - amount);\n        }\n        _burn(burner, amount);\n    }\n}\n"
    },
    "contracts/vaultManager/VaultManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IRepayCallee.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IVaultManager.sol\";\nimport \"../interfaces/IVeBoostProxy.sol\";\n\n/// @title VaultManagerStorage\n/// @author Angle Core Team\n/// @dev Variables, references, parameters and events needed in the `VaultManager` contract\n// solhint-disable-next-line max-states-count\ncontract VaultManagerStorage is IVaultManagerStorage, Initializable, ReentrancyGuardUpgradeable {\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_PARAMS = 10**9;\n    /// @notice Base used for interest rate computation\n    uint256 public constant BASE_INTEREST = 10**27;\n    /// @notice Used for interest rate computation\n    uint256 public constant HALF_BASE_INTEREST = 10**27 / 2;\n\n    // =============================== References ==================================\n\n    /// @inheritdoc IVaultManagerStorage\n    ITreasury public treasury;\n    /// @inheritdoc IVaultManagerStorage\n    IERC20 public collateral;\n    /// @inheritdoc IVaultManagerStorage\n    IAgToken public stablecoin;\n    /// @inheritdoc IVaultManagerStorage\n    IOracle public oracle;\n    /// @notice Reference to the contract which computes adjusted veANGLE balances for liquidators boosts\n    IVeBoostProxy public veBoostProxy;\n    /// @notice Base of the collateral\n    uint256 internal _collatBase;\n\n    // =============================== Parameters ==================================\n\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public immutable dust;\n    /// @notice Minimum amount of collateral (in stablecoin value) that can be left in a vault during a liquidation\n    /// where the health factor function is decreasing\n    uint256 internal immutable _dustCollateral;\n    /// @notice Maximum amount of stablecoins that can be issued with this contract\n    uint256 public debtCeiling;\n    /// @notice Threshold veANGLE balance values for the computation of the boost for liquidators: the length of this array\n    /// should be 2\n    uint256[] public xLiquidationBoost;\n    /// @notice Values of the liquidation boost at the threshold values of x\n    uint256[] public yLiquidationBoost;\n    /// @inheritdoc IVaultManagerStorage\n    uint64 public collateralFactor;\n    /// @notice Maximum Health factor at which a vault can end up after a liquidation (unless it's fully liquidated)\n    uint64 public targetHealthFactor;\n    /// @notice Upfront fee taken when borrowing stablecoins\n    uint64 public borrowFee;\n    /// @notice Per second interest taken to borrowers taking agToken loans\n    uint64 public interestRate;\n    /// @notice Fee taken by the protocol during a liquidation. Technically, this value is not the fee per se, it's 1 - fee.\n    /// For instance for a 2% fee, `liquidationSurcharge` should be 98%\n    uint64 public liquidationSurcharge;\n    /// @notice Maximum discount given to liquidators\n    uint64 public maxLiquidationDiscount;\n\n    // =============================== Variables ===================================\n\n    /// @notice Timestamp at which the `interestAccumulator` was updated\n    uint256 public lastInterestAccumulatorUpdated;\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public interestAccumulator;\n    /// @inheritdoc IVaultManagerStorage\n    uint256 public totalNormalizedDebt;\n    /// @notice Surplus accumulated by the contract: surplus is always in stablecoins, and is then reset\n    /// when the value is communicated to the treasury contract\n    uint256 public surplus;\n    /// @notice Bad debt made from liquidated vaults which ended up having no collateral and a positive amount\n    /// of stablecoins\n    uint256 public badDebt;\n\n    // ================================ Mappings ===================================\n\n    /// @inheritdoc IVaultManagerStorage\n    mapping(uint256 => Vault) public vaultData;\n    /// @notice Maps an address to whether it's whitelisted and can open or own a vault\n    mapping(address => bool) public isWhitelisted;\n\n    // =============================== Parameters ==================================\n\n    /// @notice Whether whitelisting is required to own a vault or not\n    bool public whitelistingActivated;\n\n    /// @notice Whether the vault paused or not\n    bool public paused;\n\n    // ================================ ERC721 Data ================================\n\n    /// @notice URI\n    string internal _baseURI;\n\n    /// @notice Counter to generate a unique `vaultID` for each vault: `vaultID` acts as `tokenID` in basic ERC721\n    /// contracts\n    uint256 internal _vaultIDCount;\n\n    // Mapping from `vaultID` to owner address\n    mapping(uint256 => address) internal _owners;\n\n    // Mapping from owner address to vault owned count\n    mapping(address => uint256) internal _balances;\n\n    // Mapping from `vaultID` to approved address\n    mapping(uint256 => address) internal _vaultApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\n\n    uint256[50] private __gap;\n\n    // =============================== Events ======================================\n\n    event AccruedToTreasury(uint256 surplusEndValue, uint256 badDebtEndValue);\n    event CollateralAmountUpdated(uint256 vaultID, uint256 collateralAmount, uint8 isIncrease);\n    event InterestRateAccumulatorUpdated(uint256 value, uint256 timestamp);\n    event InternalDebtUpdated(uint256 vaultID, uint256 internalAmount, uint8 isIncrease);\n    event FiledUint64(uint64 param, bytes32 what);\n    event DebtCeilingUpdated(uint256 debtCeiling);\n    event LiquidationBoostParametersUpdated(address indexed _veBoostProxy, uint256[] xBoost, uint256[] yBoost);\n    event OracleUpdated(address indexed _oracle);\n    event ToggledWhitelisting(bool);\n\n    /// @param _dust Minimum amount of debt a vault from this implementation can have\n    /// @param dustCollateral_ Minimum amount of collateral (in stablecoin value) that can be left in a vault during a liquidation\n    /// where the health factor function is decreasing\n    /// @dev Run only at the implementation level\n    constructor(uint256 _dust, uint256 dustCollateral_) initializer {\n        dust = _dust;\n        _dustCollateral = dustCollateral_;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./ITreasury.sol\";\n\n/// @title IOracle\n/// @author Angle Core Team\n/// @notice Interface for the `Oracle` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module\ninterface IOracle {\n    /// @notice Reads the rate from the Chainlink circuit\n    /// @return quoteAmount The current rate between the in-currency and out-currency in the base\n    /// of the out currency\n    /// @dev For instance if the out currency is EUR (and hence agEUR), then the base of the returned\n    /// value is 10**18\n    function read() external view returns (uint256);\n\n    /// @notice Changes the treasury contract\n    /// @param _treasury Address of the new treasury contract\n    /// @dev This function can be called by an approved `vaultManager` contract which can call\n    /// this function after being requested to do so by a `treasury` contract\n    /// @dev In some situations (like reactor contracts), the `vaultManager` may not directly be linked\n    /// to the `oracle` contract and as such we may need governors to be able to call this function as well\n    function setTreasury(address _treasury) external;\n\n    /// @notice Reference to the `treasury` contract handling this `VaultManager`\n    function treasury() external view returns (ITreasury treasury);\n}\n"
    },
    "contracts/interfaces/IRepayCallee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title IRepayCallee\n/// @author Angle Core Team\n/// @notice Interface for RepayCallee contracts\n/// @dev This interface defines the key functions `RepayCallee` contracts should have when interacting with\n/// Angle\ninterface IRepayCallee {\n    /// @notice Notifies a contract that an address should be given stablecoins\n    /// @param stablecoinRecipient Address to which stablecoins should be sent\n    /// @param stablecoinOwed Amount of stablecoins owed to the address\n    /// @param collateralObtained Amount of collateral obtained by a related address prior\n    /// to the call to this function\n    /// @param data Extra data needed (to encode Uniswap swaps for instance)\n    function repayCallStablecoin(\n        address stablecoinRecipient,\n        uint256 stablecoinOwed,\n        uint256 collateralObtained,\n        bytes calldata data\n    ) external;\n\n    /// @notice Notifies a contract that an address should be given collateral\n    /// @param collateralRecipient Address to which collateral should be sent\n    /// @param stablecoinObtained Amount of stablecoins received by the related address prior to this call\n    /// @param collateralOwed Amount of collateral owed by the address\n    /// @param data Extra data needed (to encode Uniswap swaps for instance)\n    function repayCallCollateral(\n        address collateralRecipient,\n        uint256 stablecoinObtained,\n        uint256 collateralOwed,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/IVaultManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ITreasury.sol\";\nimport \"./IOracle.sol\";\n\n// ========================= Key Structs and Enums =============================\n\n/// @notice Parameters associated to a given `VaultManager` contract: these all correspond\n/// to parameters which signification is detailed in the `VaultManagerStorage` file\nstruct VaultParameters {\n    uint256 debtCeiling;\n    uint64 collateralFactor;\n    uint64 targetHealthFactor;\n    uint64 borrowFee;\n    uint64 interestRate;\n    uint64 liquidationSurcharge;\n    uint64 maxLiquidationDiscount;\n    bool whitelistingActivated;\n    uint256 baseBoost;\n}\n\n/// @notice Data stored to track someone's loan (or equivalently called position)\nstruct Vault {\n    // Amount of collateral deposited in the vault\n    uint256 collateralAmount;\n    // Normalized value of the debt (that is to say of the stablecoins borrowed)\n    uint256 normalizedDebt;\n}\n\n/// @notice For a given `vaultID`, this encodes a liquidation opportunity that is to say details about the maximum\n/// amount that could be repaid by liquidating the position\n/// @dev All the values are null in the case of a vault which cannot be liquidated under these conditions\nstruct LiquidationOpportunity {\n    // Maximum stablecoin amount that can be repaid upon liquidating the vault\n    uint256 maxStablecoinAmountToRepay;\n    // Collateral amount given to the person in the case where the maximum amount to repay is given\n    uint256 maxCollateralAmountGiven;\n    // Threshold value of stablecoin amount to repay: it is ok for a liquidator to repay below threshold,\n    // but if this threshold is non null and the liquidator wants to repay more than threshold, it should repay\n    // the max stablecoin amount given in this vault\n    uint256 thresholdRepayAmount;\n    // Discount proposed to the liquidator on the collateral\n    uint256 discount;\n    // Amount of debt in the vault\n    uint256 currentDebt;\n}\n\n/// @notice Data stored during a liquidation process to keep in memory what's due to a liquidator and some\n/// essential data for vaults being liquidated\nstruct LiquidatorData {\n    // Current amount of stablecoins the liquidator should give to the contract\n    uint256 stablecoinAmountToReceive;\n    // Current amount of collateral the contract should give to the liquidator\n    uint256 collateralAmountToGive;\n    // Bad debt accrued across the liquidation process\n    uint256 badDebtFromLiquidation;\n    // Oracle value (in stablecoin base) at the time of the liquidation\n    uint256 oracleValue;\n    // Value of the interestRateAccumulator at the time of the call\n    uint256 newInterestRateAccumulator;\n}\n\n/// @notice Data to track during a series of action the amount to give or receive in stablecoins and collateral\n/// to the caller or associated addresses\nstruct PaymentData {\n    // Stablecoin amount the contract should give\n    uint256 stablecoinAmountToGive;\n    // Stablecoin amount owed to the contract\n    uint256 stablecoinAmountToReceive;\n    // Collateral amount the contract should give\n    uint256 collateralAmountToGive;\n    // Collateral amount owed to the contract\n    uint256 collateralAmountToReceive;\n}\n\n/// @notice Actions possible when composing calls to the different entry functions proposed\nenum ActionType {\n    createVault,\n    closeVault,\n    addCollateral,\n    removeCollateral,\n    repayDebt,\n    borrow,\n    getDebtIn,\n    permit\n}\n\n// ========================= Interfaces =============================\n\n/// @title IVaultManagerFunctions\n/// @author Angle Core Team\n/// @notice Interface for the `VaultManager` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module (without getters)\ninterface IVaultManagerFunctions {\n    /// @notice Accrues interest accumulated across all vaults to the surplus and sends the surplus to the treasury\n    /// @return surplusValue Value of the surplus communicated to the `Treasury`\n    /// @return badDebtValue Value of the bad debt communicated to the `Treasury`\n    /// @dev `surplus` and `badDebt` should be reset to 0 once their current value have been given to the `treasury` contract\n    function accrueInterestToTreasury() external returns (uint256 surplusValue, uint256 badDebtValue);\n\n    /// @notice Removes debt from a vault after being requested to do so by another `vaultManager` contract\n    /// @param vaultID ID of the vault to remove debt from\n    /// @param amountStablecoins Amount of stablecoins to remove from the debt: this amount is to be converted to an\n    /// internal debt amount\n    /// @param senderBorrowFee Borrowing fees from the contract which requested this: this is to make sure that people are not\n    /// arbitraging difference in minting fees\n    function getDebtOut(\n        uint256 vaultID,\n        uint256 amountStablecoins,\n        uint256 senderBorrowFee\n    ) external;\n\n    /// @notice Gets the current debt of a vault\n    /// @param vaultID ID of the vault to check\n    /// @return Debt of the vault\n    function getVaultDebt(uint256 vaultID) external view returns (uint256);\n\n    /// @notice Sets the treasury contract\n    /// @param _treasury New treasury contract\n    /// @dev All required checks when setting up a treasury contract are performed in the contract\n    /// calling this function\n    function setTreasury(address _treasury) external;\n\n    /// @notice Creates a vault\n    /// @param toVault Address for which the va\n    /// @return vaultID ID of the vault created\n    /// @dev This function just creates the vault without doing any collateral or\n    function createVault(address toVault) external returns (uint256);\n\n    /// @notice Allows composability between calls to the different entry points of this module. Any user calling\n    /// this function can perform any of the allowed actions in the order of their choice\n    /// @param actions Set of actions to perform\n    /// @param datas Data to be decoded for each action: it can include like the `vaultID` or the\n    /// @param from Address from which stablecoins will be taken if one action includes burning stablecoins. This address\n    /// should either be the `msg.sender` or be approved by the latter\n    /// @param to Address to which stablecoins and/or collateral will be sent in case of\n    /// @return paymentData Struct containing the final transfers executed\n    /// @dev This function is optimized to reduce gas cost due to payment from or to the user and that expensive calls\n    /// or computations (like `oracleValue`) are done only once\n    function angle(\n        ActionType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to\n    ) external payable returns (PaymentData memory paymentData);\n\n    /// @notice Allows composability between calls to the different entry points of this module. Any user calling\n    /// this function can perform any of the allowed actions in the order of their choice\n    /// @param actions Set of actions to perform\n    /// @param datas Data to be decoded for each action: it can include like the `vaultID` or the\n    /// @param from Address from which stablecoins will be taken if one action includes burning stablecoins. This address\n    /// should either be the `msg.sender` or be approved by the latter\n    /// @param to Address to which stablecoins and/or collateral will be sent in case of\n    /// @param who Address of the contract to handle in case of repayment of stablecoins from received collateral\n    /// @param repayData Data to pass to the repayment contract in case of\n    /// @return paymentData Struct containing the final transfers executed\n    /// @dev This function is optimized to reduce gas cost due to payment from or to the user and that expensive calls\n    /// or computations (like `oracleValue`) are done only once\n    function angle(\n        ActionType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to,\n        address who,\n        bytes memory repayData\n    ) external payable returns (PaymentData memory paymentData);\n\n    /// @notice Initializes the `VaultManager` contract\n    /// @param _treasury Treasury address handling the contract\n    /// @param _collateral Collateral supported by this contract\n    /// @param _oracle Oracle contract used\n    /// @param _symbol Symbol used to define the `VaultManager` name and symbol\n    /// @dev The parameters and the oracle are the only elements which could be modified once the\n    /// contract has been initialized\n    /// @dev For the contract to be fully initialized, governance needs to set the parameters for the liquidation\n    /// boost\n    function initialize(\n        ITreasury _treasury,\n        IERC20 _collateral,\n        IOracle _oracle,\n        VaultParameters calldata params,\n        string memory _symbol\n    ) external;\n}\n\n/// @title IVaultManagerStorage\n/// @author Angle Core Team\n/// @notice Interface for the `VaultManager` contract\n/// @dev This interface contains getters of the contract's public variables used by other contracts\n/// of this module\ninterface IVaultManagerStorage {\n    /// @notice Minimum amount of debt a vault can have\n    function dust() external view returns (uint256);\n\n    /// @notice Encodes the maximum ratio stablecoin/collateral a vault can have before being liquidated. It's what\n    /// determines the minimum collateral ratio of a position\n    function collateralFactor() external view returns (uint64);\n\n    /// @notice Stablecoin handled by this contract. Another `VaultManager` contract could have\n    /// the same rights as this `VaultManager` on the stablecoin contract\n    function stablecoin() external view returns (IAgToken);\n\n    /// @notice Reference to the `treasury` contract handling this `VaultManager`\n    function treasury() external view returns (ITreasury);\n\n    /// @notice Oracle contract to get access to the price of the collateral with respect to the stablecoin\n    function oracle() external view returns (IOracle);\n\n    /// @notice The `interestAccumulator` variable keeps track of the interest that should accrue to the protocol.\n    /// The stored value is not necessarily the true value: this one is recomputed every time an action takes place\n    /// within the protocol\n    function interestAccumulator() external view returns (uint256);\n\n    /// @notice Reference to the collateral handled by this `VaultManager`\n    function collateral() external view returns (IERC20);\n\n    /// @notice Total normalized amount of stablecoins borrowed\n    function totalNormalizedDebt() external view returns (uint256);\n\n    /// @notice Maps a `vaultID` to its data (namely collateral amount and normalized debt)\n    function vaultData(uint256 vaultID) external view returns (uint256 collateralAmount, uint256 normalizedDebt);\n}\n\n/// @title IVaultManager\n/// @author Angle Core Team\n/// @notice Interface for the `VaultManager` contract\ninterface IVaultManager is IVaultManagerFunctions, IVaultManagerStorage, IERC721Metadata {\n\n}\n"
    },
    "contracts/interfaces/IVeBoostProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title IVeBoostProxy\n/// @author Angle Core Team\n/// @notice Interface for the `VeBoostProxy` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module\n/// @dev The `veBoostProxy` contract used by Angle is a full fork of Curve Finance implementation\ninterface IVeBoostProxy {\n    /// @notice Reads the adjusted veANGLE balance of an address (adjusted by delegation)\n    //solhint-disable-next-line\n    function adjusted_balance_of(address) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721Metadata.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/mock/MockVeBoostProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IVeBoostProxy.sol\";\n\ncontract MockVeBoostProxy is IVeBoostProxy {\n    //solhint-disable-next-line\n    mapping(address => uint256) public adjusted_balance_of;\n\n    constructor() {}\n\n    function setBalance(address concerned, uint256 balance) external {\n        adjusted_balance_of[concerned] = balance;\n    }\n}\n"
    },
    "contracts/treasury/Treasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IVaultManager.sol\";\n\n/// @title Treasury\n/// @author Angle Core Team\n/// @notice Treasury of Angle Borrowing Module doing the accounting across all VaultManagers for\n/// a given stablecoin\ncontract Treasury is ITreasury, Initializable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    // =============================== References ==================================\n\n    /// @notice Reference to the Core contract of the module which handles all AccessControl logic\n    ICoreBorrow public core;\n    /// @notice Flash Loan Module with a minter right on the stablecoin\n    IFlashAngle public flashLoanModule;\n    /// @inheritdoc ITreasury\n    IAgToken public stablecoin;\n    /// @notice Address responsible for handling the surplus made by the treasury\n    address public surplusManager;\n    /// @notice List of the accepted `VaultManager` of the protocol\n    address[] public vaultManagerList;\n    /// @notice Maps an address to whether it was initialized as a `VaultManager` contract\n    mapping(address => bool) public vaultManagerMap;\n\n    // =============================== Variables ===================================\n\n    /// @notice Amount of bad debt (unbacked stablecoin) accumulated across all `VaultManager` contracts\n    /// linked to this stablecoin\n    uint256 public badDebt;\n    /// @notice Surplus amount accumulated by the contract waiting to be distributed to governance. Technically\n    /// only a share of this `surplusBuffer` will go to governance. Once a share of the surplus buffer has been\n    /// given to governance, then this surplus is reset\n    uint256 public surplusBuffer;\n\n    // =============================== Parameter ===================================\n\n    /// @notice Share of the `surplusBuffer` distributed to governance (in `BASE_PARAMS`)\n    uint64 public surplusForGovernance;\n\n    // =============================== Events ======================================\n\n    event BadDebtUpdated(uint256 badDebtValue);\n    event CoreUpdated(address indexed _core);\n    event NewTreasurySet(address indexed _treasury);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event SurplusBufferUpdated(uint256 surplusBufferValue);\n    event SurplusForGovernanceUpdated(uint64 _surplusForGovernance);\n    event SurplusManagerUpdated(address indexed _surplusManager);\n    event VaultManagerToggled(address indexed vaultManager);\n\n    // =============================== Modifier ====================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        require(core.isGovernor(msg.sender), \"1\");\n        _;\n    }\n\n    /// @notice Initializes the treasury contract\n    /// @param _core Address of the `CoreBorrow` contract of the module\n    /// @param _stablecoin Address of the stablecoin\n    function initialize(ICoreBorrow _core, IAgToken _stablecoin) public initializer {\n        require(address(_stablecoin) != address(0) && address(_core) != address(0), \"O\");\n        core = _core;\n        stablecoin = _stablecoin;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ========================= View Functions ====================================\n\n    /// @inheritdoc ITreasury\n    function isGovernor(address admin) external view returns (bool) {\n        return core.isGovernor(admin);\n    }\n\n    /// @inheritdoc ITreasury\n    function isGovernorOrGuardian(address admin) external view returns (bool) {\n        return core.isGovernorOrGuardian(admin);\n    }\n\n    /// @inheritdoc ITreasury\n    function isVaultManager(address _vaultManager) external view returns (bool) {\n        return vaultManagerMap[_vaultManager];\n    }\n\n    // ============= External Permissionless Functions =============================\n\n    /// @notice Fetches the surplus accrued across all the `VaultManager` contracts controlled by this\n    /// `Treasury` contract as well as from the fees of the `FlashLoan` module\n    /// @return Surplus buffer value at the end of the call\n    /// @return Bad debt value at the end of the call\n    /// @dev This function pools surplus and bad debt across all contracts and then updates the `surplusBuffer`\n    /// (or the `badDebt` if more losses were made than profits)\n    function fetchSurplusFromAll() external returns (uint256, uint256) {\n        return _fetchSurplusFromAll();\n    }\n\n    /// @notice Fetches the surplus accrued in the flash loan module and updates the `surplusBuffer`\n    /// @return Surplus buffer value at the end of the call\n    /// @return Bad debt value at the end of the call\n    /// @dev This function fails if the `flashLoanModule` has not been initialized yet\n    function fetchSurplusFromFlashLoan() external returns (uint256, uint256) {\n        uint256 surplusBufferValue = surplusBuffer + flashLoanModule.accrueInterestToTreasury(stablecoin);\n        return _updateSurplusBadDebt(surplusBufferValue, badDebt);\n    }\n\n    /// @notice Fetches surplus a list of vaultManager contracts\n    /// @return Surplus buffer value at the end of the call\n    /// @return Bad debt value at the end of the call\n    /// TODO: could be removed or not?\n    function fetchSurplusFromVaultManagers(address[] memory vaultManagers) external returns (uint256, uint256) {\n        (uint256 surplusBufferValue, uint256 badDebtValue) = _fetchSurplusFromList(vaultManagers);\n        return _updateSurplusBadDebt(surplusBufferValue, badDebtValue);\n    }\n\n    /// @notice Pushes the surplus buffer to the `surplusManager` contract\n    /// @return governanceAllocation Amount transferred to governance\n    /// @dev This function will fail if the `surplusManager` has not been initialized yet\n    /// @dev It makes sure to fetch the surplus from all the contracts handled by this treasury to avoid\n    /// the situation where rewards are still distributed to governance even though a `VaultManager` has made\n    /// a big loss\n    /// @dev Typically this function is to be called once every week by a keeper to distribute rewards to veANGLE\n    /// holders\n    /// @dev `stablecoin` must be an AgToken and hence `transfer` reverts if the call is not successful\n    function pushSurplus() external returns (uint256 governanceAllocation) {\n        address _surplusManager = surplusManager;\n        require(_surplusManager != address(0), \"0\");\n        (uint256 surplusBufferValue, ) = _fetchSurplusFromAll();\n        surplusBuffer = 0;\n        emit SurplusBufferUpdated(0);\n        governanceAllocation = (surplusForGovernance * surplusBufferValue) / BASE_PARAMS;\n        stablecoin.transfer(_surplusManager, governanceAllocation);\n    }\n\n    /// @notice Updates the bad debt of the protocol in case where the protocol has accumulated some revenue\n    /// from an external source\n    /// @param amount Amount to reduce the bad debt of\n    /// @return badDebtValue Value of the bad debt at the end of the call\n    /// @dev If the protocol has made a loss and managed to make some profits to recover for this loss (through\n    /// a program like Olympus Pro), then this function needs to be called\n    /// @dev `badDebt` is simply reduced here by burning stablecoins\n    /// @dev It is impossible to burn more than the `badDebt` otherwise this function could be used to manipulate\n    /// the `surplusBuffer` and hence the amount going to governance\n    function updateBadDebt(uint256 amount) external returns (uint256 badDebtValue) {\n        badDebtValue = badDebt;\n        require(amount <= badDebtValue, \"4\");\n        stablecoin.burnSelf(amount, address(this));\n        badDebtValue -= amount;\n        badDebt = badDebtValue;\n        emit BadDebtUpdated(badDebtValue);\n    }\n\n    // ==================== Internal Utility Functions =============================\n\n    /// @notice Internal version of the `fetchSurplusFromAll` function\n    function _fetchSurplusFromAll() internal returns (uint256 surplusBufferValue, uint256 badDebtValue) {\n        (surplusBufferValue, badDebtValue) = _fetchSurplusFromList(vaultManagerList);\n        // It will fail anyway if the `flashLoanModule` is the zero address\n        if (address(flashLoanModule) != address(0))\n            surplusBufferValue += flashLoanModule.accrueInterestToTreasury(stablecoin);\n        (surplusBufferValue, badDebtValue) = _updateSurplusBadDebt(surplusBufferValue, badDebtValue);\n    }\n\n    /// @notice Fetches the surplus from a list of `VaultManager` addresses without modifying the\n    /// `surplusBuffer` and `badDebtValue`\n    /// @return surplusBufferValue Value the `surplusBuffer` should have after the call if it was updated\n    /// @return badDebtValue Value the `badDebt` should have after the call if it was updated\n    /// @dev This internal function is never to be called alone, and should always be called in conjunction\n    /// with the `_updateSurplusBadDebt` function\n    function _fetchSurplusFromList(address[] memory vaultManagers)\n        internal\n        returns (uint256 surplusBufferValue, uint256 badDebtValue)\n    {\n        badDebtValue = badDebt;\n        surplusBufferValue = surplusBuffer;\n        uint256 newSurplus;\n        uint256 newBadDebt;\n        for (uint256 i = 0; i < vaultManagers.length; i++) {\n            (newSurplus, newBadDebt) = IVaultManager(vaultManagers[i]).accrueInterestToTreasury();\n            surplusBufferValue += newSurplus;\n            badDebtValue += newBadDebt;\n        }\n    }\n\n    /// @notice Updates the `surplusBuffer` and the `badDebt` from updated values after calling the flash loan module\n    /// and/or a list of `VaultManager` contracts\n    /// @param surplusBufferValue Value of the surplus buffer after the calls to the different modules\n    /// @param badDebtValue Value of the bad debt after the calls to the different modules\n    /// @return Value of the `surplusBuffer` corrected from the `badDebt``\n    /// @return Value of the `badDebt` corrected from the `surplusBuffer` and from the surplus the treasury had accumulated\n    /// previously\n    /// @dev When calling this function, it is possible that there is a positive `surplusBufferValue` and `badDebtValue`,\n    /// this function tries to reconcile both values and makes sure that we either have surplus or bad debt but not both\n    /// at the same time\n    function _updateSurplusBadDebt(uint256 surplusBufferValue, uint256 badDebtValue)\n        internal\n        returns (uint256, uint256)\n    {\n        if (badDebtValue > 0) {\n            // If we have bad debt we need to burn stablecoins that accrued to the protocol\n            // We still need to make sure that we're not burning too much or as much as we can if the debt is big\n            uint256 balance = stablecoin.balanceOf(address(this));\n            if (balance < badDebtValue) {\n                stablecoin.burnSelf(balance, address(this));\n                surplusBufferValue = 0;\n                badDebtValue -= balance;\n            } else {\n                stablecoin.burnSelf(badDebtValue, address(this));\n                surplusBufferValue = badDebtValue >= surplusBufferValue ? 0 : surplusBufferValue - badDebtValue;\n                badDebtValue = 0;\n            }\n        }\n        surplusBuffer = surplusBufferValue;\n        badDebt = badDebtValue;\n        emit SurplusBufferUpdated(surplusBufferValue);\n        emit BadDebtUpdated(badDebtValue);\n        return (surplusBufferValue, badDebtValue);\n    }\n\n    // ============================ Governor Functions =============================\n\n    /// @notice Adds a new minter for the stablecoin\n    /// @param minter Minter address to add\n    function addMinter(address minter) external onlyGovernor {\n        require(minter != address(0), \"0\");\n        stablecoin.addMinter(minter);\n    }\n\n    /// @notice Adds a new `vaultManager`\n    /// @param vaultManager `VaultManager` contract to add\n    /// @dev This contract should have already been initialized with a correct treasury address\n    /// @dev It's this function that gives the minter right to the `vaultManager`\n    function addVaultManager(address vaultManager) external onlyGovernor {\n        require(!vaultManagerMap[vaultManager], \"5\");\n        require(address(IVaultManager(vaultManager).treasury()) == address(this), \"6\");\n        vaultManagerMap[vaultManager] = true;\n        vaultManagerList.push(vaultManager);\n        emit VaultManagerToggled(vaultManager);\n        stablecoin.addMinter(vaultManager);\n    }\n\n    /// @notice Removes a minter from the stablecoin contract\n    /// @param minter Minter address to remove\n    function removeMinter(address minter) external onlyGovernor {\n        // To remove the minter role to a `vaultManager` you have to go through the `removeVaultManager` function\n        require(!vaultManagerMap[minter], \"36\");\n        stablecoin.removeMinter(minter);\n    }\n\n    /// @notice Removes a `vaultManager`\n    /// @param vaultManager `VaultManager` contract to remove\n    /// @dev A removed `vaultManager` loses its minter right on the stablecoin\n    function removeVaultManager(address vaultManager) external onlyGovernor {\n        require(vaultManagerMap[vaultManager], \"3\");\n        delete vaultManagerMap[vaultManager];\n        uint256 vaultManagerListLength = vaultManagerList.length;\n        for (uint256 i = 0; i < vaultManagerListLength - 1; i++) {\n            if (vaultManagerList[i] == vaultManager) {\n                vaultManagerList[i] = vaultManagerList[vaultManagerListLength - 1];\n                break;\n            }\n        }\n        vaultManagerList.pop();\n        emit VaultManagerToggled(vaultManager);\n        stablecoin.removeMinter(vaultManager);\n    }\n\n    /// @notice Allows to recover any ERC20 token, including the stablecoin handled by this contract, and to send it\n    /// to a contract\n    /// @param tokenAddress Address of the token to recover\n    /// @param to Address of the contract to send collateral to\n    /// @param amountToRecover Amount of collateral to transfer\n    /// @dev It is impossible to recover the stablecoin of the protocol if there is some bad debt for it\n    /// @dev In this case, the function makes sure to fetch the surplus/bad debt from all the `VaultManager` contracts\n    /// and from the flash loan module\n    /// @dev If the token to recover is the stablecoin, tokens recovered are fetched\n    /// from the surplus and not from the `surplusBuffer`\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyGovernor {\n        // Cannot recover stablecoin if badDebt or tap into the surplus buffer\n        if (tokenAddress == address(stablecoin)) {\n            _fetchSurplusFromAll();\n            // If balance is non zero then this means, after the call to `fetchSurplusFromAll` that\n            // bad debt is necessarily null\n            uint256 balance = stablecoin.balanceOf(address(this));\n            require(amountToRecover + surplusBuffer <= balance, \"4\");\n            stablecoin.transfer(to, amountToRecover);\n        } else {\n            IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        }\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Changes the treasury contract and communicates this change to all `VaultManager` contract\n    /// @param _treasury New treasury address for this stablecoin\n    /// @dev This function is basically a way to remove rights to this contract and grant them to a new one\n    /// @dev It could be used to set a new core contract\n    function setTreasury(address _treasury) external onlyGovernor {\n        require(ITreasury(_treasury).stablecoin() == stablecoin, \"6\");\n        // Flash loan role should be removed before calling this function\n        require(!core.isFlashLoanerTreasury(address(this)), \"7\");\n        emit NewTreasurySet(_treasury);\n        for (uint256 i = 0; i < vaultManagerList.length; i++) {\n            IVaultManager(vaultManagerList[i]).setTreasury(_treasury);\n        }\n        // A `TreasuryUpdated` event is triggered in the stablecoin\n        stablecoin.setTreasury(_treasury);\n    }\n\n    /// @notice Sets the `surplusForGovernance` parameter\n    /// @param _surplusForGovernance New value of the parameter\n    /// @dev To pause surplus distribution, governance needs to set a zero value for `surplusForGovernance`\n    /// which means\n    function setSurplusForGovernance(uint64 _surplusForGovernance) external onlyGovernor {\n        require(_surplusForGovernance <= BASE_PARAMS, \"9\");\n        surplusForGovernance = _surplusForGovernance;\n        emit SurplusForGovernanceUpdated(_surplusForGovernance);\n    }\n\n    /// @notice Sets the `surplusManager` contract responsible for handling the surplus of the\n    /// protocol\n    /// @param _surplusManager New address responsible for handling the surplus\n    function setSurplusManager(address _surplusManager) external onlyGovernor {\n        require(_surplusManager != address(0), \"0\");\n        surplusManager = _surplusManager;\n        emit SurplusManagerUpdated(_surplusManager);\n    }\n\n    /// @notice Sets a new `Core` contract\n    /// @dev This function should typically be called on all treasury contracts after the `setCore`\n    /// function has been called on the `Core` contract\n    /// @dev One sanity check that can be performed here is to verify whether at least the governor\n    /// calling the contract is still a governor in the new core\n    function setCore(ICoreBorrow _core) external onlyGovernor {\n        require(_core.isGovernor(msg.sender), \"1\");\n        core = ICoreBorrow(_core);\n        emit CoreUpdated(address(_core));\n    }\n\n    /// @inheritdoc ITreasury\n    function setFlashLoanModule(address _flashLoanModule) external {\n        require(msg.sender == address(core), \"10\");\n        address oldFlashLoanModule = address(flashLoanModule);\n        if (oldFlashLoanModule != address(0)) {\n            stablecoin.removeMinter(oldFlashLoanModule);\n        }\n        // We may want to cancel the module\n        if (_flashLoanModule != address(0)) {\n            stablecoin.addMinter(_flashLoanModule);\n        }\n        flashLoanModule = IFlashAngle(_flashLoanModule);\n    }\n}\n"
    },
    "contracts/mock/MockTreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/IVaultManager.sol\";\n\ncontract MockTreasury is ITreasury {\n    IAgToken public override stablecoin;\n    address public governor;\n    address public guardian;\n    address public vaultManager1;\n    address public vaultManager2;\n    address public flashLoanModule;\n\n    constructor(\n        IAgToken _stablecoin,\n        address _governor,\n        address _guardian,\n        address _vaultManager1,\n        address _vaultManager2,\n        address _flashLoanModule\n    ) {\n        stablecoin = _stablecoin;\n        governor = _governor;\n        guardian = _guardian;\n        vaultManager1 = _vaultManager1;\n        vaultManager2 = _vaultManager2;\n        flashLoanModule = _flashLoanModule;\n    }\n\n    function isGovernor(address admin) external view override returns (bool) {\n        return (admin == governor);\n    }\n\n    function isGovernorOrGuardian(address admin) external view override returns (bool) {\n        return (admin == governor || admin == guardian);\n    }\n\n    function isVaultManager(address _vaultManager) external view override returns (bool) {\n        return (_vaultManager == vaultManager1 || _vaultManager == vaultManager2);\n    }\n\n    function setFlashLoanModule(address _flashLoanModule) external override {\n        flashLoanModule = _flashLoanModule;\n    }\n\n    function setGovernor(address _governor) external {\n        governor = _governor;\n    }\n\n    function setVaultManager(address _vaultManager) external {\n        vaultManager1 = _vaultManager;\n    }\n\n    function setVaultManager2(address _vaultManager) external {\n        vaultManager2 = _vaultManager;\n    }\n\n    function setTreasury(address _agTokenOrVaultManager, address _treasury) external {\n        IAgToken(_agTokenOrVaultManager).setTreasury(_treasury);\n    }\n\n    function addMinter(IAgToken _agToken, address _minter) external {\n        _agToken.addMinter(_minter);\n    }\n\n    function removeMinter(IAgToken _agToken, address _minter) external {\n        _agToken.removeMinter(_minter);\n    }\n\n    function accrueInterestToTreasury(IFlashAngle flashAngle) external returns (uint256 balance) {\n        balance = flashAngle.accrueInterestToTreasury(stablecoin);\n    }\n\n    function accrueInterestToTreasuryVaultManager(IVaultManager _vaultManager) external returns (uint256, uint256) {\n        return _vaultManager.accrueInterestToTreasury();\n    }\n}\n"
    },
    "contracts/mock/MockFlashLoanModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ICoreBorrow.sol\";\n\ncontract MockFlashLoanModule is IFlashAngle {\n    ICoreBorrow public override core;\n    mapping(address => bool) public stablecoinsSupported;\n    mapping(IAgToken => uint256) public interestAccrued;\n    uint256 public surplusValue;\n\n    constructor(ICoreBorrow _core) {\n        core = _core;\n    }\n\n    function accrueInterestToTreasury(IAgToken stablecoin) external override returns (uint256 balance) {\n        balance = surplusValue;\n        interestAccrued[stablecoin] += balance;\n    }\n\n    function addStablecoinSupport(address _treasury) external override {\n        stablecoinsSupported[_treasury] = true;\n    }\n\n    function removeStablecoinSupport(address _treasury) external override {\n        stablecoinsSupported[_treasury] = false;\n    }\n\n    function setCore(address _core) external override {\n        core = ICoreBorrow(_core);\n    }\n\n    function setSurplusValue(uint256 _surplusValue) external {\n        surplusValue = _surplusValue;\n    }\n}\n"
    },
    "contracts/mock/MockCoreBorrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\ncontract MockCoreBorrow is ICoreBorrow {\n    mapping(address => bool) public flashLoaners;\n    mapping(address => bool) public governors;\n    mapping(address => bool) public guardians;\n\n    function isFlashLoanerTreasury(address treasury) external view override returns (bool) {\n        return flashLoaners[treasury];\n    }\n\n    function isGovernor(address admin) external view override returns (bool) {\n        return governors[admin];\n    }\n\n    function isGovernorOrGuardian(address admin) external view override returns (bool) {\n        return guardians[admin];\n    }\n\n    function toggleGovernor(address admin) external {\n        governors[admin] = !governors[admin];\n    }\n\n    function toggleGuardian(address admin) external {\n        guardians[admin] = !guardians[admin];\n    }\n\n    function toggleFlashLoaners(address admin) external {\n        flashLoaners[admin] = !flashLoaners[admin];\n    }\n\n    function addStablecoinSupport(IFlashAngle flashAngle, address _treasury) external {\n        flashAngle.addStablecoinSupport(_treasury);\n    }\n\n    function removeStablecoinSupport(IFlashAngle flashAngle, address _treasury) external {\n        flashAngle.removeStablecoinSupport(_treasury);\n    }\n\n    function setCore(IFlashAngle flashAngle, address _core) external {\n        flashAngle.setCore(_core);\n    }\n\n    function setFlashLoanModule(ITreasury _treasury, address _flashLoanModule) external {\n        _treasury.setFlashLoanModule(_flashLoanModule);\n    }\n}\n"
    },
    "contracts/flashloan/FlashAngle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\n/// @title FlashAngle\n/// @author Angle Core Team\n/// @notice Contract to take flash loans on top of several AgToken contracts\ncontract FlashAngle is IERC3156FlashLender, IFlashAngle, Initializable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_PARAMS = 10**9;\n    /// @notice Success message received when calling a `FlashBorrower` contract\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// @notice Struct encoding for a given stablecoin the parameters\n    struct StablecoinData {\n        // Treasury address responsible\n        address treasury;\n        // Maximum amount borrowable for this stablecoin\n        uint256 maxBorrowable;\n        // Flash loan fee taken by the protocol for a flash loan on this stablecoin\n        uint64 flashLoanFee;\n    }\n\n    // ======================= Parameters and References ===========================\n\n    /// @notice Maps a stablecoin to the data and parameters for flash loans\n    mapping(IAgToken => StablecoinData) public stablecoinMap;\n    /// @inheritdoc IFlashAngle\n    ICoreBorrow public core;\n\n    /// @notice Initializes the contract\n    /// @param _core Core address handling this module\n    function initialize(ICoreBorrow _core) public initializer {\n        require(address(_core) != address(0), \"0\");\n        core = _core;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // =================================== Modifiers ===============================\n\n    /// @notice Checks whether the sender is the core contract\n    modifier onlyCore() {\n        require(msg.sender == address(core), \"10\");\n        _;\n    }\n\n    /// @notice Checks whether a given stablecoin has been initialized in this contract\n    /// @param stablecoin Stablecoin to check\n    /// @dev To check whether a stablecoin has been initialized, we just need to check whether its associated\n    /// `treasury` address is not null in the `stablecoinMap`. This is what's checked in the `CoreBorrow` contract\n    /// when adding support for a stablecoin\n    modifier onlyExistingStablecoin(IAgToken stablecoin) {\n        require(stablecoinMap[stablecoin].treasury != address(0), \"13\");\n        _;\n    }\n\n    // ================================ ERC3156 Spec ===============================\n\n    /// @inheritdoc IERC3156FlashLender\n    function flashFee(address token, uint256 amount) external view returns (uint256) {\n        return _flashFee(token, amount);\n    }\n\n    /// @inheritdoc IERC3156FlashLender\n    function maxFlashLoan(address token) external view returns (uint256) {\n        // It will be 0 anyway if the token was not added\n        return stablecoinMap[IAgToken(token)].maxBorrowable;\n    }\n\n    /// @inheritdoc IERC3156FlashLender\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external nonReentrant returns (bool) {\n        uint256 fee = _flashFee(token, amount);\n        require(amount <= stablecoinMap[IAgToken(token)].maxBorrowable, \"4\");\n        IAgToken(token).mint(address(receiver), amount);\n        require(receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS, \"39\");\n        // Token must be an agToken here so normally no need to use `safeTransferFrom`, but out of safety\n        // and in case governance whitelists an agToken which does not have a correct implementation, we prefer\n        // to use `safeTransferFrom` here\n        IERC20(token).safeTransferFrom(address(receiver), address(this), amount + fee);\n        IAgToken(token).burnSelf(amount, address(this));\n        return true;\n    }\n\n    /// @notice Internal function to compute the fee induced for taking a flash loan of `amount` of `token`\n    /// @param token The loan currency\n    /// @param amount The amount of tokens lent\n    /// @dev This function will revert if the `token` requested is not whitelisted here\n    function _flashFee(address token, uint256 amount)\n        internal\n        view\n        onlyExistingStablecoin(IAgToken(token))\n        returns (uint256)\n    {\n        return (amount * stablecoinMap[IAgToken(token)].flashLoanFee) / BASE_PARAMS;\n    }\n\n    // ============================ Treasury Only Function =========================\n\n    /// @inheritdoc IFlashAngle\n    function accrueInterestToTreasury(IAgToken stablecoin) external returns (uint256 balance) {\n        address treasury = stablecoinMap[stablecoin].treasury;\n        require(msg.sender == treasury, \"14\");\n        balance = stablecoin.balanceOf(address(this));\n        IERC20(address(stablecoin)).safeTransfer(treasury, balance);\n    }\n\n    // =========================== Governance Only Function ========================\n\n    /// @notice Sets the parameters for a given stablecoin\n    /// @param stablecoin Stablecoin to change the parameters for\n    /// @param _flashLoanFee New flash loan fee for this stablecoin\n    /// @param _maxBorrowable Maximum amount that can be borrowed in a single flash loan\n    /// @dev Setting a `maxBorrowable` parameter equal to 0 is a way to pause the functionality\n    /// @dev Parameters can only be modified for whitelisted stablecoins\n    function setFlashLoanParameters(\n        IAgToken stablecoin,\n        uint64 _flashLoanFee,\n        uint256 _maxBorrowable\n    ) external onlyExistingStablecoin(stablecoin) {\n        require(core.isGovernorOrGuardian(msg.sender), \"2\");\n        require(_flashLoanFee <= BASE_PARAMS, \"9\");\n        stablecoinMap[stablecoin].flashLoanFee = _flashLoanFee;\n        stablecoinMap[stablecoin].maxBorrowable = _maxBorrowable;\n    }\n\n    // =========================== CoreBorrow Only Functions =======================\n\n    /// @inheritdoc IFlashAngle\n    function addStablecoinSupport(address _treasury) external onlyCore {\n        stablecoinMap[IAgToken(ITreasury(_treasury).stablecoin())].treasury = _treasury;\n    }\n\n    /// @inheritdoc IFlashAngle\n    function removeStablecoinSupport(address _treasury) external onlyCore {\n        delete stablecoinMap[IAgToken(ITreasury(_treasury).stablecoin())];\n    }\n\n    /// @inheritdoc IFlashAngle\n    function setCore(address _core) external onlyCore {\n        core = ICoreBorrow(_core);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "contracts/settlement/Settlement.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/IRepayCallee.sol\";\nimport \"../interfaces/IVaultManager.sol\";\n\n/// @title Settlement\n/// @author Angle Core Team\n/// @notice Settlement Contract for a VaultManager\n/// @dev This settlement contract should be activated by a careful governance which needs to have performed\n/// some key operations before activating this contract\n/// @dev In case of global settlement, there should be one settlement contract per `VaultManager`\ncontract Settlement {\n    using SafeERC20 for IERC20;\n\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_PARAMS = 10**9;\n    /// @notice Base used for interest computation\n    uint256 public constant BASE_INTEREST = 10**27;\n    /// @notice Base used for exchange rate computation. It is assumed\n    /// that stablecoins have this base\n    uint256 public constant BASE_STABLECOIN = 10**18;\n    /// @notice Duration of the claim period for over-collateralized vaults\n    uint256 public constant OVER_COLLATERALIZED_CLAIM_DURATION = 3 * 24 * 3600;\n\n    // =============== Immutable references set in the constructor =================\n\n    /// @notice `VaultManager` of this settlement contract\n    IVaultManager public immutable vaultManager;\n    /// @notice Reference to the stablecoin supported by the `VaultManager` contract\n    IAgToken public immutable stablecoin;\n    /// @notice Reference to the collateral supported by the `VaultManager`\n    IERC20 public immutable collateral;\n    /// @notice Base of the collateral\n    uint256 internal immutable _collatBase;\n\n    // ================ Variables frozen at settlement activation ==================\n\n    /// @notice Value of the oracle for the collateral/stablecoin pair\n    uint256 public oracleValue;\n    /// @notice Value of the interest accumulator at settlement activation\n    uint256 public interestAccumulator;\n    /// @notice Timestamp at which settlement was activated\n    uint256 public activationTimestamp;\n    /// @notice Collateral factor of the `VaultManager`\n    uint64 public collateralFactor;\n\n    // =================== Variables updated during the process ====================\n\n    /// @notice How much collateral you can get from stablecoins\n    uint256 public collateralStablecoinExchangeRate;\n    /// @notice Amount of collateral that will be left over at the end of the process\n    uint256 public leftOverCollateral;\n    /// @notice Whether the `collateralStablecoinExchangeRate` has been computed\n    bool public exchangeRateComputed;\n    /// @notice Maps a vault to whether it was claimed or not by its owner\n    mapping(uint256 => bool) public vaultCheck;\n\n    // ================================ Events =====================================\n\n    event GlobalClaimPeriodActivated(uint256 _collateralStablecoinExchangeRate);\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n    event SettlementActivated(uint256 startTimestamp);\n    event VaultClaimed(uint256 vaultID, uint256 stablecoinAmount, uint256 collateralAmount);\n\n    /// @notice Constructor of the contract\n    /// @param _vaultManager Address of the `VaultManager` associated to this `Settlement` contract\n    /// @dev Out of safety, this constructor reads values from the `VaultManager` contract directly\n    constructor(IVaultManager _vaultManager) {\n        vaultManager = _vaultManager;\n        stablecoin = _vaultManager.stablecoin();\n        collateral = _vaultManager.collateral();\n        _collatBase = 10**(IERC20Metadata(address(collateral)).decimals());\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        require(vaultManager.treasury().isGovernor(msg.sender), \"1\");\n        _;\n    }\n\n    /// @notice Activates the settlement contract\n    /// @dev When calling this function governance should make sure to have:\n    /// 1. Accrued the interest rate on the contract\n    /// 2. Paused the contract\n    /// 3. Recovered all the collateral available in the `VaultManager` contract either\n    /// by doing a contract upgrade or by calling a `recoverERC20` method if supported\n    function activateSettlement() external onlyGovernor {\n        oracleValue = (vaultManager.oracle()).read();\n        interestAccumulator = vaultManager.interestAccumulator();\n        activationTimestamp = block.timestamp;\n        collateralFactor = vaultManager.collateralFactor();\n        emit SettlementActivated(block.timestamp);\n    }\n\n    /// @notice Allows the owner of an over-collateralized vault to claim its collateral upon bringing back all owed stablecoins\n    /// @param vaultID ID of the vault to claim\n    /// @param to Address to which collateral should be sent\n    /// @param who Address which should be notified if needed of the transfer of stablecoins and collateral\n    /// @param data Data to pass to the `who` contract for it to successfully give the correct amount of stablecoins\n    /// to the `msg.sender` address\n    /// @return Amount of collateral sent to the `to` address\n    /// @return Amount of stablecoins sent to the contract\n    /// @dev Claiming can only happen short after settlement activation\n    /// @dev A vault cannot be claimed twice and only the owner of the vault can claim it (regardless of the approval logic)\n    /// @dev Only over-collateralized vaults can be claimed from this medium\n    function claimOverCollateralizedVault(\n        uint256 vaultID,\n        address to,\n        address who,\n        bytes memory data\n    ) external returns (uint256, uint256) {\n        require(\n            activationTimestamp != 0 && block.timestamp <= activationTimestamp + OVER_COLLATERALIZED_CLAIM_DURATION,\n            \"46\"\n        );\n        require(!vaultCheck[vaultID], \"48\");\n        require(vaultManager.ownerOf(vaultID) == msg.sender, \"47\");\n        (uint256 collateralAmount, uint256 normalizedDebt) = vaultManager.vaultData(vaultID);\n        uint256 vaultDebt = (normalizedDebt * interestAccumulator) / BASE_INTEREST;\n        require(collateralAmount * oracleValue * collateralFactor >= vaultDebt * BASE_PARAMS * _collatBase, \"21\");\n        vaultCheck[vaultID] = true;\n        emit VaultClaimed(vaultID, vaultDebt, collateralAmount);\n        return _handleRepay(collateralAmount, vaultDebt, to, who, data);\n    }\n\n    /// @notice Activates the global claim period by setting the `collateralStablecoinExchangeRate` which is going to\n    /// dictate how much of collateral will be recoverable for each stablecoin\n    /// @dev This function can only be called by the governor in order to allow it in case multiple settlements happen across\n    /// different `VaultManager` to rebalance the amount of stablecoins on each to make sure that across all settlement contracts\n    /// a similar value of collateral can be obtained against a similar value of stablecoins\n    function activateGlobalClaimPeriod() external onlyGovernor {\n        require(\n            activationTimestamp != 0 && block.timestamp > activationTimestamp + OVER_COLLATERALIZED_CLAIM_DURATION,\n            \"49\"\n        );\n        uint256 collateralBalance = collateral.balanceOf(address(this));\n        uint256 leftOverDebt = (vaultManager.totalNormalizedDebt() * interestAccumulator) / BASE_INTEREST;\n        uint256 stablecoinBalance = stablecoin.balanceOf(address(this));\n        // How much 1 of stablecoin will give you in collateral\n        uint256 _collateralStablecoinExchangeRate;\n\n        if (stablecoinBalance < leftOverDebt) {\n            // The left over debt is the total debt minus the stablecoins which have already been accumulated\n            // in the first phase\n            leftOverDebt -= stablecoinBalance;\n            // If you control all the debt, then you are entitled to get all the collateral left in the protocol\n            _collateralStablecoinExchangeRate = (collateralBalance * BASE_STABLECOIN) / leftOverDebt;\n            // But at the same time, you cannot get more collateral than the value of the stablecoins you brought\n            uint256 maxExchangeRate = (BASE_STABLECOIN * _collatBase) / oracleValue;\n            if (_collateralStablecoinExchangeRate >= maxExchangeRate) {\n                // In this situation, we're sure that `leftOverCollateral` will be positive\n                leftOverCollateral = collateralBalance - (leftOverDebt * _collatBase) / oracleValue;\n                _collateralStablecoinExchangeRate = maxExchangeRate;\n            }\n        }\n        exchangeRateComputed = true;\n        // In the else case where there is no debt left, you cannot get anything from your stablecoins\n        // and so the `collateralStablecoinExchangeRate` is null\n        collateralStablecoinExchangeRate = _collateralStablecoinExchangeRate;\n        emit GlobalClaimPeriodActivated(_collateralStablecoinExchangeRate);\n    }\n\n    /// @notice Allows to claim collateral from stablecoins\n    /// @param to Address to which collateral should be sent\n    /// @param who Address which should be notified if needed of the transfer of stablecoins and collateral\n    /// @param data Data to pass to the `who` contract for it to successfully give the correct amount of stablecoins\n    /// to the `msg.sender` address\n    /// @return Amount of collateral sent to the `to` address\n    /// @return Amount of stablecoins sent to the contract\n    /// @dev This function reverts if the `collateralStablecoinExchangeRate` is null and hence if the global claim period has\n    /// not been activated\n    function claimCollateralFromStablecoins(\n        uint256 stablecoinAmount,\n        address to,\n        address who,\n        bytes memory data\n    ) external returns (uint256, uint256) {\n        require(exchangeRateComputed, \"50\");\n        return\n            _handleRepay(\n                (stablecoinAmount * collateralStablecoinExchangeRate) / BASE_STABLECOIN,\n                stablecoinAmount,\n                to,\n                who,\n                data\n            );\n    }\n\n    /// @notice Handles the simultaneous repayment of stablecoins with a transfer of collateral\n    /// @param collateralAmountToGive Amount of collateral the contract should give\n    /// @param stableAmountToRepay Amount of stablecoins the contract should burn from the call\n    /// @param to Address to which stablecoins should be sent\n    /// @param who Address which should be notified if needed of the transfer\n    /// @param data Data to pass to the `who` contract for it to successfully give the correct amount of stablecoins\n    /// to the `msg.sender` address\n    /// @dev This function allows for capital-efficient claims of collateral from stablecoins\n    function _handleRepay(\n        uint256 collateralAmountToGive,\n        uint256 stableAmountToRepay,\n        address to,\n        address who,\n        bytes memory data\n    ) internal returns (uint256, uint256) {\n        collateral.safeTransfer(to, collateralAmountToGive);\n        if (data.length > 0) {\n            IRepayCallee(who).repayCallStablecoin(msg.sender, stableAmountToRepay, collateralAmountToGive, data);\n        }\n        stablecoin.transferFrom(msg.sender, address(this), stableAmountToRepay);\n        return (collateralAmountToGive, stableAmountToRepay);\n    }\n\n    /// @notice Recovers leftover tokens from the contract or tokens that were mistakenly sent to the contract\n    /// @param tokenAddress Address of the token to recover\n    /// @param to Address to send the remaining tokens to\n    /// @param amountToRecover Amount to recover from the contract\n    /// @dev Governors cannot recover more collateral than what would be leftover from the contract\n    /// @dev This function can be used to rebalance stablecoin balances across different settlement contracts\n    /// to make sure every stablecoin can be redeemed for the same value of collateral\n    /// @dev It can also be used to recover tokens that are mistakenly sent to this contract\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyGovernor {\n        if (tokenAddress == address(collateral)) {\n            require(exchangeRateComputed, \"50\");\n            leftOverCollateral -= amountToRecover;\n            collateral.safeTransfer(to, amountToRecover);\n        } else {\n            IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        }\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n}\n"
    },
    "contracts/mock/MockRepayCallee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IRepayCallee.sol\";\n\ncontract MockRepayCallee is IRepayCallee {\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    uint256 public counter;\n\n    constructor() {}\n\n    function repayCallStablecoin(\n        address,\n        uint256,\n        uint256,\n        bytes calldata data\n    ) external {\n        counter += 1;\n        data;\n    }\n\n    function repayCallCollateral(\n        address,\n        uint256,\n        uint256,\n        bytes calldata data\n    ) external {\n        counter += 1;\n        data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/mock/MockVaultManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IVaultManager.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockVaultManager {\n    ITreasury public treasury;\n    mapping(uint256 => Vault) public vaultData;\n    mapping(uint256 => address) public ownerOf;\n    uint256 public surplus;\n    uint256 public badDebt;\n    IAgToken public token;\n    address public oracle = address(this);\n\n    address public governor;\n    address public collateral;\n    address public stablecoin;\n    uint256 public oracleValue;\n    uint256 public interestAccumulator;\n    uint256 public collateralFactor;\n    uint256 public totalNormalizedDebt;\n\n    constructor(address _treasury) {\n        treasury = ITreasury(_treasury);\n    }\n\n    function accrueInterestToTreasury() external returns (uint256, uint256) {\n        // Avoid the function to be view\n        if (surplus >= badDebt) {\n            token.mint(msg.sender, surplus - badDebt);\n        }\n        return (surplus, badDebt);\n    }\n\n    function read() external view returns (uint256) {\n        return oracleValue;\n    }\n\n    function setParams(\n        address _governor,\n        address _collateral,\n        address _stablecoin,\n        uint256 _oracleValue,\n        uint256 _interestAccumulator,\n        uint256 _collateralFactor,\n        uint256 _totalNormalizedDebt\n    ) external {\n        governor = _governor;\n        collateral = _collateral;\n        stablecoin = _stablecoin;\n        interestAccumulator = _interestAccumulator;\n        collateralFactor = _collateralFactor;\n        totalNormalizedDebt = _totalNormalizedDebt;\n        oracleValue = _oracleValue;\n    }\n\n    function setOwner(uint256 vaultID, address owner) external {\n        ownerOf[vaultID] = owner;\n    }\n\n    function setVaultData(\n        uint256 normalizedDebt,\n        uint256 collateralAmount,\n        uint256 vaultID\n    ) external {\n        vaultData[vaultID].normalizedDebt = normalizedDebt;\n        vaultData[vaultID].collateralAmount = collateralAmount;\n    }\n\n    function isGovernor(address admin) external view returns (bool) {\n        return admin == governor;\n    }\n\n    function setSurplusBadDebt(\n        uint256 _surplus,\n        uint256 _badDebt,\n        IAgToken _token\n    ) external {\n        surplus = _surplus;\n        badDebt = _badDebt;\n        token = _token;\n    }\n\n    function getDebtOut(\n        uint256 vaultID,\n        uint256 amountStablecoins,\n        uint256 senderBorrowFee\n    ) external {}\n\n    function setTreasury(address _treasury) external {\n        treasury = ITreasury(_treasury);\n    }\n\n    function getVaultDebt(uint256 vaultID) external view returns (uint256) {\n        vaultID;\n        token;\n        return 0;\n    }\n\n    function createVault(address toVault) external view returns (uint256) {\n        toVault;\n        token;\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/mock/MockTokenPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\ncontract MockTokenPermit is ERC20Permit {\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    uint8 internal _decimal;\n    mapping(address => bool) public minters;\n    address public treasury;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) ERC20Permit(name_) ERC20(name_,symbol_) {\n        _decimal = decimal_;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimal;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function setAllowance(address from, address to) public {\n        _approve(from, to, type(uint256).max);\n    }\n\n    function burnSelf(uint256 amount, address account) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function addMinter(address minter) public {\n        minters[minter] = true;\n    }\n\n    function removeMinter(address minter) public {\n        minters[minter] = false;\n    }\n\n    function setTreasury(address _treasury) public {\n        treasury = _treasury;\n    }\n}\n"
    },
    "contracts/mock/MockToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    uint8 internal _decimal;\n    mapping(address => bool) public minters;\n    address public treasury;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) ERC20(name_, symbol_) {\n        _decimal = decimal_;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimal;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function setAllowance(address from, address to) public {\n        _approve(from, to, type(uint256).max);\n    }\n\n    function burnSelf(uint256 amount, address account) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function addMinter(address minter) public {\n        minters[minter] = true;\n    }\n\n    function removeMinter(address minter) public {\n        minters[minter] = false;\n    }\n\n    function setTreasury(address _treasury) public {\n        treasury = _treasury;\n    }\n}\n"
    },
    "contracts/mock/MockFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\n\ncontract MockFlashLoanReceiver is IERC3156FlashBorrower {\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    constructor() {}\n\n    function onFlashLoan(\n        address,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external override returns (bytes32) {\n        IERC20(token).approve(msg.sender, amount + fee);\n        if (amount >= 10**21) return keccak256(\"error\");\n        if (amount == 2 * 10**18) {\n            IERC3156FlashLender(msg.sender).flashLoan(IERC3156FlashBorrower(address(this)), token, amount, data);\n            return keccak256(\"reentrant\");\n        } else return CALLBACK_SUCCESS;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/external/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n * This contract was fully forked from OpenZeppelin `ProxyAdmin`\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{ value: msg.value }(implementation, data);\n    }\n}\n"
    },
    "contracts/external/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin. It is fully forked from OpenZeppelin\n * `TransparentUpgradeableProxy`\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice Minimal IERC4646 tokenized Vault interface.\n/// @author Forked from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @dev Do not use in production! ERC-4626 is still in the review stage and is subject to change.\ninterface IERC4626 {\n    event Deposit(address indexed from, address indexed to, uint256 amount, uint256 shares);\n    event Withdraw(address indexed from, address indexed to, uint256 amount, uint256 shares);\n\n    /// @notice Transfers a given amount of asset to the reactor and mint shares accordingly\n    /// @param amount Given amount of asset\n    /// @param to Address to mint shares to\n    /// @return shares Amount of shares minted to `to`\n    function deposit(uint256 amount, address to) external returns (uint256 shares);\n\n    /// @notice Mints a given amount of shares to the reactor and transfer assets accordingly\n    /// @param shares Given amount of shares\n    /// @param to Address to mint shares to\n    /// @return amount Amount of `asset` taken to the `msg.sender` to mint `shares`\n    function mint(uint256 shares, address to) external returns (uint256 amount);\n\n    /// @notice Transfers a given amount of asset from the reactor and burn shares accordingly\n    /// @param amount Given amount of asset\n    /// @param to Address to transfer assets to\n    /// @param from Address to burn shares from\n    /// @return shares Amount of shares burnt in the operation\n    function withdraw(\n        uint256 amount,\n        address to,\n        address from\n    ) external returns (uint256 shares);\n\n    /// @notice Burns a given amount of shares to the reactor and transfer assets accordingly\n    /// @param shares Given amount of shares\n    /// @param to Address to transfer assets to\n    /// @param from Address to burn shares from\n    /// @return amount Amount of assets redeemed in the operation\n    function redeem(\n        uint256 shares,\n        address to,\n        address from\n    ) external returns (uint256 amount);\n\n    /// @notice Returns the total assets managed by this reactor\n    function totalAssets() external view returns (uint256);\n\n    /// @notice Converts an amount of assets to the corresponding amount of reactor shares\n    /// @param assets Amount of asset to convert\n    /// @return Shares corresponding to the amount of assets obtained\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    /// @notice Converts an amount of shares to its current value in asset\n    /// @param shares Amount of shares to convert\n    /// @return Amount of assets corresponding to the amount of assets given\n    function convertToAssets(uint256 shares) external view returns (uint256);\n\n    /// @notice Computes how many shares one would get by depositing `assets`\n    /// @param assets Amount of asset to convert\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    /// @notice Computes how many assets one would need to mint `shares`\n    /// @param shares Amount of shares required\n    function previewMint(uint256 shares) external view returns (uint256);\n\n    /// @notice Computes how many shares one would need to withdraw assets\n    /// @param assets Amount of asset to withdraw\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    /// @notice Computes how many assets one would get by burning shares\n    /// @param shares Amount of shares to burn\n    function previewRedeem(uint256 shares) external view returns (uint256);\n\n    /// @notice Max deposit allowed for a user\n    /// @param user Address of the user to check\n    function maxDeposit(address user) external returns (uint256);\n\n    /// @notice Max mint allowed for a user\n    /// @param user Address of the user to check\n    function maxMint(address user) external returns (uint256);\n\n    /// @notice Max withdraw allowed for a user\n    /// @param user Address of the user to check\n    function maxWithdraw(address user) external returns (uint256);\n\n    /// @notice Max redeem allowed for a user\n    /// @param user Address of the user to check\n    function maxRedeem(address user) external returns (uint256);\n}\n"
    },
    "contracts/reactor/BaseReactorStorage.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../interfaces/IERC4626.sol\";\nimport \"../interfaces/IVaultManager.sol\";\n\n/// @title BaseReactorStorage\n/// @author Angle Core Team\n/// @dev Variables, references, parameters and events needed in the `BaseReactor` contract\n// solhint-disable-next-line max-states-count\ncontract BaseReactorStorage is Initializable, ReentrancyGuardUpgradeable {\n    /// @notice Base used for parameter computation\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    // =============================== References ==================================\n\n    /// @notice Reference to the asset controlled by this reactor\n    IERC20 public asset;\n    /// @notice Reference to the stablecoin this reactor handles\n    IAgToken public stablecoin;\n    /// @notice Oracle giving the price of the asset with respect to the stablecoin\n    IOracle public oracle;\n    /// @notice Treasury contract handling access control\n    ITreasury public treasury;\n    /// @notice VaultManager contract on which this contract has a vault. All references should\n    /// be fetched from here\n    IVaultManager public vaultManager;\n    /// @notice ID of the vault handled by this contract\n    uint256 public vaultID;\n    /// @notice Dust parameter for the stablecoins in a vault in `VaultManager`\n    uint256 public vaultManagerDust;\n    /// @notice Base of the `asset`. While it is assumed in this contract that the base of the stablecoin is 18,\n    /// the base of the `asset` may not be 18\n    uint256 internal _assetBase;\n\n    // =============================== Parameters ==================================\n\n    /// @notice Lower value of the collateral factor: below this the reactor can borrow stablecoins\n    uint64 public lowerCF;\n    /// @notice Value of the collateral factor targeted by this vault\n    uint64 public targetCF;\n    /// @notice Value of the collateral factor above which stablecoins should be repaid to avoid liquidations\n    uint64 public upperCF;\n\n    // =============================== Variables ===================================\n\n    /// @notice Rewards (in stablecoin) claimable by depositors of the reactor\n    uint256 public claimableRewards;\n    /// @notice Loss (in stablecoin) accumulated by the reactor: it's going to prevent the reactor from\n    /// repaying its debt\n    uint256 public currentLoss;\n\n    /// @notice Used to track rewards accumulated by all depositors of the reactor\n    uint256 public rewardsAccumulator;\n    /// @notice Tracks rewards already claimed by all depositors\n    uint256 public claimedRewardsAccumulator;\n    /// @notice Last time rewards were claimed in the reactor\n    uint256 public lastTime;\n    /// @notice Last known stable debt to the `vaultManager`\n    uint256 public lastDebt;\n\n    /// @notice Maps an address to the last time it claimed its rewards\n    mapping(address => uint256) public lastTimeOf;\n    /// @notice Maps an address to a quantity depending on time and shares of the reactors used\n    /// to compute the rewards an address can claim\n    mapping(address => uint256) public rewardsAccumulatorOf;\n\n    uint256[50] private __gap;\n\n    // =============================== Events ======================================\n\n    event FiledUint64(uint64 param, bytes32 what);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/coreBorrow/CoreBorrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/ICoreBorrow.sol\";\nimport \"../interfaces/IFlashAngle.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\n/// @title CoreBorrow\n/// @author Angle Core Team\n/// @notice Core contract of the borrowing module. This contract handles the access control across all contracts\n/// (it is read by all treasury contracts), and manages the `flashLoanModule`. It has no minting rights over the\n/// stablecoin contracts\ncontract CoreBorrow is ICoreBorrow, Initializable, AccessControlEnumerableUpgradeable {\n    /// @notice Role for guardians\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    /// @notice Role for governors\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    /// @notice Role for treasury contract\n    bytes32 public constant FLASHLOANER_TREASURY_ROLE = keccak256(\"FLASHLOANER_TREASURY_ROLE\");\n\n    // ============================= Reference =====================================\n\n    /// @notice Reference to the `flashLoanModule` with minting rights over the different stablecoins of the protocol\n    address public flashLoanModule;\n\n    // =============================== Events ======================================\n\n    event FlashLoanModuleUpdated(address indexed _flashloanModule);\n    event CoreUpdated(address indexed _core);\n\n    /// @notice Initializes the `CoreBorrow` contract and the access control of the borrowing module\n    /// @param governor Address of the governor of the Angle Protocol\n    /// @param guardian Guardian address of the protocol\n    function initialize(address governor, address guardian) public initializer {\n        require(governor != address(0) && guardian != address(0), \"O\");\n        require(governor != guardian, \"12\");\n        _setupRole(GOVERNOR_ROLE, governor);\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setupRole(GUARDIAN_ROLE, governor);\n        _setRoleAdmin(GUARDIAN_ROLE, GUARDIAN_ROLE);\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(FLASHLOANER_TREASURY_ROLE, GOVERNOR_ROLE);\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // =========================== View Functions ==================================\n\n    /// @inheritdoc ICoreBorrow\n    function isFlashLoanerTreasury(address treasury) external view returns (bool) {\n        return hasRole(FLASHLOANER_TREASURY_ROLE, treasury);\n    }\n\n    /// @inheritdoc ICoreBorrow\n    function isGovernor(address admin) external view returns (bool) {\n        return hasRole(GOVERNOR_ROLE, admin);\n    }\n\n    /// @inheritdoc ICoreBorrow\n    function isGovernorOrGuardian(address admin) external view returns (bool) {\n        return hasRole(GUARDIAN_ROLE, admin);\n    }\n\n    // =========================== Governor Functions ==============================\n\n    /// @notice Grants the `FLASHLOANER_TREASURY_ROLE` to a `treasury` contract\n    /// @param treasury Contract to grant the role to\n    /// @dev This function can be used to allow flash loans on a stablecoin of the protocol\n    function addFlashLoanerTreasuryRole(address treasury) external {\n        address _flashLoanModule = flashLoanModule;\n        grantRole(FLASHLOANER_TREASURY_ROLE, treasury);\n        if (_flashLoanModule != address(0)) {\n            // This call will revert if `treasury` is the zero address or if it is not linked\n            // to this `CoreBorrow` contract\n            ITreasury(treasury).setFlashLoanModule(_flashLoanModule);\n            IFlashAngle(_flashLoanModule).addStablecoinSupport(treasury);\n        }\n    }\n\n    /// @notice Adds a governor in the protocol\n    /// @param governor Address to grant the role to\n    /// @dev It is necessary to call this function to grant a governor role to make sure\n    /// all governors also have the guardian role\n    function addGovernor(address governor) external {\n        grantRole(GOVERNOR_ROLE, governor);\n        grantRole(GUARDIAN_ROLE, governor);\n    }\n\n    /// @notice Revokes the flash loan ability for a stablecoin\n    /// @param treasury Treasury address associated with the stablecoin for which flash loans\n    /// should no longer be available\n    function removeFlashLoanerTreasuryRole(address treasury) external {\n        revokeRole(FLASHLOANER_TREASURY_ROLE, treasury);\n        ITreasury(treasury).setFlashLoanModule(address(0));\n        address _flashLoanModule = flashLoanModule;\n        if (_flashLoanModule != address(0)) {\n            IFlashAngle(flashLoanModule).removeStablecoinSupport(treasury);\n        }\n    }\n\n    /// @notice Revokes a governor from the protocol\n    /// @param governor Address to remove the role to\n    /// @dev It is necessary to call this function to remove a governor role to make sure\n    /// the address also loses its guardian role\n    function removeGovernor(address governor) external {\n        require(getRoleMemberCount(GOVERNOR_ROLE) > 1, \"38\");\n        revokeRole(GOVERNOR_ROLE, governor);\n        revokeRole(GUARDIAN_ROLE, governor);\n    }\n\n    /// @notice Changes the `flashLoanModule` of the protocol\n    /// @param _flashLoanModule Address of the new flash loan module\n    function setFlashLoanModule(address _flashLoanModule) external onlyRole(GOVERNOR_ROLE) {\n        if (_flashLoanModule != address(0)) {\n            require(address(IFlashAngle(_flashLoanModule).core()) == address(this), \"11\");\n        }\n        uint256 count = getRoleMemberCount(FLASHLOANER_TREASURY_ROLE);\n        for (uint256 i = 0; i < count; i++) {\n            ITreasury(getRoleMember(FLASHLOANER_TREASURY_ROLE, i)).setFlashLoanModule(_flashLoanModule);\n        }\n        flashLoanModule = _flashLoanModule;\n        emit FlashLoanModuleUpdated(_flashLoanModule);\n    }\n\n    /// @notice Changes the core contract of the protocol\n    /// @param _core New core contract\n    /// @dev This function verifies that the governors of the new core contract are exactly\n    /// the same as those of this one. It also notifies the `flashLoanModule` of the change\n    /// @dev Governance wishing to change the core contract should also make sure to call `setCore`\n    /// in the different treasury contracts\n    function setCore(ICoreBorrow _core) external onlyRole(GOVERNOR_ROLE) {\n        uint256 count = getRoleMemberCount(GOVERNOR_ROLE);\n        bool success;\n        for (uint256 i = 0; i < count; i++) {\n            success = _core.isGovernor(getRoleMember(GOVERNOR_ROLE, i));\n            if (!success) break;\n        }\n        require(success, \"11\");\n        address _flashLoanModule = flashLoanModule;\n        if (_flashLoanModule != address(0)) IFlashAngle(_flashLoanModule).setCore(address(_core));\n        emit CoreUpdated(address(_core));\n    }\n}\n"
    },
    "contracts/reactor/BaseReactor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.12;\n\nimport \"./BaseReactorStorage.sol\";\n\n/// @title BaseReactor\n/// @notice Reactor for using a token as collateral for agTokens. ERC4646 tokenized Vault implementation.\n/// @author Angle Core Team, based on Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @dev A token used as an asset built to exploit this reactor could perform reentrancy attacks if not enough checks\n/// are performed: as such the protocol implements reentrancy checks on all external entry point\nabstract contract BaseReactor is BaseReactorStorage, ERC20Upgradeable, IERC721ReceiverUpgradeable, IERC4626 {\n    using SafeERC20 for IERC20;\n\n    /// @notice Initializes the `BaseReactor` contract and\n    /// the underlying `VaultManager`\n    /// @param _name Name of the ERC4626 token\n    /// @param _symbol Symbol of the ERC4626 token\n    /// @param _vaultManager Underlying `VaultManager` used to borrow stablecoin\n    /// @param _lowerCF Lower Collateral Factor accepted without rebalancing\n    /// @param _targetCF Target Collateral Factor\n    /// @param _upperCF Upper Collateral Factor accepted without rebalancing\n    function _initialize(\n        string memory _name,\n        string memory _symbol,\n        IVaultManager _vaultManager,\n        uint64 _lowerCF,\n        uint64 _targetCF,\n        uint64 _upperCF\n    ) internal initializer {\n        __ERC20_init(_name, _symbol);\n        vaultManager = _vaultManager;\n        stablecoin = _vaultManager.stablecoin();\n        IERC20 _asset = _vaultManager.collateral();\n        treasury = _vaultManager.treasury();\n        oracle = _vaultManager.oracle();\n        vaultManagerDust = _vaultManager.dust();\n        asset = _asset;\n        _assetBase = 10**(IERC20Metadata(address(_asset)).decimals());\n        lastTime = block.timestamp;\n\n        vaultID = _vaultManager.createVault(address(this));\n\n        require(\n            0 < _lowerCF &&\n                _lowerCF <= _targetCF &&\n                _targetCF <= _upperCF &&\n                _upperCF <= _vaultManager.collateralFactor(),\n            \"15\"\n        );\n        lowerCF = _lowerCF;\n        targetCF = _targetCF;\n        upperCF = _upperCF;\n\n        asset.approve(address(vaultManager), type(uint256).max);\n    }\n\n    // ============================== Modifiers ====================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        require(treasury.isGovernor(msg.sender), \"1\");\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        require(treasury.isGovernorOrGuardian(msg.sender), \"2\");\n        _;\n    }\n\n    // ========================= External Access Functions =========================\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets, address to) public nonReentrant returns (uint256 shares) {\n        (uint256 usedAssets, uint256 looseAssets) = _getAssets();\n        shares = _convertToShares(assets, usedAssets + looseAssets);\n        require(shares != 0, \"ZERO_SHARES\");\n        _deposit(assets, shares, to, usedAssets, looseAssets + assets);\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address to) public nonReentrant returns (uint256 assets) {\n        (uint256 usedAssets, uint256 looseAssets) = _getAssets();\n        assets = _convertToAssets(shares, usedAssets + looseAssets);\n        _deposit(assets, shares, to, usedAssets, looseAssets + assets);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev The amount of assets specified should be smaller than the amount of assets controlled by the\n    /// reactor\n    function withdraw(\n        uint256 assets,\n        address to,\n        address from\n    ) public nonReentrant returns (uint256 shares) {\n        (uint256 usedAssets, uint256 looseAssets) = _getAssets();\n        shares = _convertToShares(assets, usedAssets + looseAssets);\n        _withdraw(assets, shares, to, from, usedAssets, looseAssets);\n    }\n\n    /// @notice Rebalances the underlying vault\n    function rebalance() external nonReentrant {\n        (uint256 usedAssets, uint256 looseAssets) = _getAssets();\n        _rebalance(0, usedAssets, looseAssets);\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(\n        uint256 shares,\n        address to,\n        address from\n    ) public nonReentrant returns (uint256 assets) {\n        (uint256 usedAssets, uint256 looseAssets) = _getAssets();\n        require((assets = _convertToAssets(shares, usedAssets + looseAssets)) != 0, \"ZERO_ASSETS\");\n        _withdraw(assets, shares, to, from, usedAssets, looseAssets);\n    }\n\n    /// @notice Claims earned rewards\n    /// @param from Address to claim for\n    /// @return Amount claimed\n    function claim(address from) public nonReentrant returns (uint256) {\n        _updateAccumulator(from);\n        return _claim(from);\n    }\n\n    // ============================= View Functions ================================\n\n    /// @inheritdoc IERC4626\n    function totalAssets() public view returns (uint256 assets) {\n        (uint256 usedAssets, uint256 looseAssets) = _getAssets();\n        assets = usedAssets + looseAssets;\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        return _convertToShares(assets, totalAssets());\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        return _convertToAssets(shares, totalAssets());\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets) public view returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares) public view returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /// @notice Computes how many shares one would need to withdraw assets\n    /// @param assets Amount of asset to withdraw\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) public view returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @notice Computes how many assets one would get by burning shares\n    /// @param shares Amount of shares to burn\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares) public view returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev Technically, the maximum deposit could be less than the max uint256\n    /// if there is a `debtCeiling` in the associated `vaultManager`. This implementation\n    /// assumes that the `vaultManager` does not have any debt ceiling\n    function maxDeposit(address) public pure returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) public pure returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    // TODO worth completing with restrictions based on current harvest\n    function maxWithdraw(address user) public view virtual returns (uint256) {\n        return convertToShares(balanceOf(user));\n    }\n\n    /// @inheritdoc IERC4626\n    // TODO worth completing with restrictions based on current harvest\n    function maxRedeem(address user) public view virtual returns (uint256) {\n        return balanceOf(user);\n    }\n\n    /// @inheritdoc IERC721ReceiverUpgradeable\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) external view returns (bytes4) {\n        require(msg.sender == address(vaultManager), \"3\");\n        return this.onERC721Received.selector;\n    }\n\n    // =========================== Internal Functions ==============================\n\n    /// @notice Gets the assets controlled by the reactor: those in the associated vaultManager\n    /// as well as those in the contract\n    /// @return usedAssets Amount of the `asset` in the associated `vaultManager`\n    /// @return looseAssets Amount of the `asset` in the contract\n    function _getAssets() internal view returns (uint256 usedAssets, uint256 looseAssets) {\n        (usedAssets, ) = vaultManager.vaultData(vaultID);\n        looseAssets = asset.balanceOf(address(this));\n    }\n\n    /// @notice Converts an amount of assets to shares of the reactor from an amount of assets controlled by the vault\n    /// @param assets Amount of assets to convert\n    /// @param totalAssetAmount Total amount of asset controlled by the vault\n    /// @return Corresponding amount of shares\n    function _convertToShares(uint256 assets, uint256 totalAssetAmount) internal view returns (uint256) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? assets : (assets * supply) / totalAssetAmount;\n    }\n\n    /// @notice Converts an amount of shares of the reactor to assets\n    /// @param shares Amount of shares to convert\n    /// @param totalAssetAmount Total amount of asset controlled by the vault\n    /// @return Corresponding amount of assets\n    /// @dev It is at the level of this function that losses from liquidations are taken into account, because this\n    /// reduces the totalAssetAmount and hence the amount of assets you are entitled to get from your shares\n    function _convertToAssets(uint256 shares, uint256 totalAssetAmount) internal view returns (uint256) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? shares : (shares * totalAssetAmount) / supply;\n    }\n\n    /// @notice Handles the new value of the debt: propagates a loss to the claimable rewards\n    /// or a gain depending on the evolution of this debt\n    /// @param currentDebt Current value of the debt\n    /// @notice In the case where you get liquidated, you actually record a gain in stablecoin,\n    /// which is normal to compensate for the decrease of the collateral in the vault\n    /// @dev In case where a loss (like from interest taken by the `vaultManager`) is planned, then stakeholders\n    /// are incentivized to front run it and claim their rewards in advance. In normal times, this reactor therefore\n    /// works well mostly with `vaultManager` on which there are no interest taken (and no borrowing fees)\n    function _handleCurrentDebt(uint256 currentDebt) internal {\n        if (lastDebt >= currentDebt) {\n            // This happens if you have been liquidated or if debt has been paid on your behalf\n            _handleGain(lastDebt - currentDebt);\n        } else {\n            uint256 loss = currentDebt - lastDebt;\n            if (claimableRewards >= loss) {\n                claimableRewards -= loss;\n            } else {\n                currentLoss += loss - claimableRewards;\n                claimableRewards = 0;\n            }\n        }\n    }\n\n    /// @notice Propagates a gain to the claimable rewards\n    /// @param gain Gain to propagate\n    function _handleGain(uint256 gain) internal {\n        uint256 currentLossVariable = currentLoss;\n        if (currentLossVariable >= gain) {\n            currentLoss -= gain;\n        } else {\n            claimableRewards += gain - currentLossVariable;\n            currentLoss = 0;\n        }\n    }\n\n    /// @notice Rebalances the underlying vault\n    /// @param toWithdraw Amount of assets to withdraw\n    /// @param usedAssets Amount of assets in the vault\n    /// @param looseAssets Amount of assets already in the contract\n    /// @dev `toWithdraw` is always lower than managed assets (`= usedAssets+looseAssets`): indeed if it was superior\n    /// it would mean either\n    /// - that the `withdraw` function was called with an amount of assets greater than the amount of asset controlled\n    /// by the reactor\n    /// - or that the `redeem` function was called with an amount of shares greater than the total supply\n    /// @dev `usedAssets` and `looseAssets` are passed as parameters here to avoid performing the same calculation twice\n    function _rebalance(\n        uint256 toWithdraw,\n        uint256 usedAssets,\n        uint256 looseAssets\n    ) internal {\n        uint256 debt = vaultManager.getVaultDebt(vaultID);\n        _handleCurrentDebt(debt);\n        lastDebt = debt;\n\n        uint256 collateralFactor;\n        uint256 toRepay;\n        uint256 toBorrow;\n\n        // We're first using as an intermediate in this variable something that does not correspond\n        // to the future amount of stablecoins borrowed in the vault: it is the future collateral amount in\n        // the vault expressed in stablecoin value and in a custom base\n        uint256 futureStablecoinsInVault = (usedAssets + looseAssets - toWithdraw) * oracle.read();\n        // The function will revert above if `toWithdraw` is too big\n\n        if (futureStablecoinsInVault == 0) collateralFactor = type(uint256).max;\n        else {\n            collateralFactor = (BASE_PARAMS * _assetBase * debt) / futureStablecoinsInVault;\n        }\n        // This is the targeted debt at the end of the call, which might not be reached if the collateral\n        // factor is not moved enough\n        futureStablecoinsInVault = (futureStablecoinsInVault * targetCF) / (_assetBase * BASE_PARAMS);\n        uint16 len = 1;\n        (collateralFactor >= upperCF) ? len += 1 : 0; // Needs to repay\n        (collateralFactor <= lowerCF && futureStablecoinsInVault > vaultManagerDust) ? len += 1 : 0; // Needs to borrow\n\n        ActionType[] memory actions = new ActionType[](len);\n        bytes[] memory datas = new bytes[](len);\n\n        len = 0;\n\n        if (toWithdraw <= looseAssets) {\n            // Add Collateral\n            actions[len] = ActionType.addCollateral;\n            datas[len] = abi.encodePacked(vaultID, looseAssets - toWithdraw);\n            len += 1;\n        }\n\n        // Dust is also handled here to avoid reverting calls: if repaying the debt would leave a dusty\n        // amount then all the debt is repaid\n        // If borrowing would only create a dusty debt amount, then nothing happens\n        if (collateralFactor >= upperCF) {\n            // If the `collateralFactor` is too high, then too much has been borrowed\n            // and stablecoins should be repaid\n            actions[len] = ActionType.repayDebt;\n            toRepay = debt - futureStablecoinsInVault;\n            lastDebt -= toRepay;\n            if (futureStablecoinsInVault <= vaultManagerDust) {\n                // If this happens in a moment at which the reactor has a loss, then it will not be able\n                // to repay it all, and the function will revert\n                toRepay = type(uint256).max;\n                lastDebt = 0;\n            }\n            datas[len] = abi.encodePacked(vaultID, toRepay);\n            len += 1;\n        } else if (collateralFactor <= lowerCF && futureStablecoinsInVault > vaultManagerDust) {\n            // If the `collateralFactor` is too low, then stablecoins can be borrowed and later\n            // invested in strategies\n            toBorrow = futureStablecoinsInVault - debt;\n            actions[len] = ActionType.borrow;\n            datas[len] = abi.encodePacked(vaultID, toBorrow);\n            lastDebt += toBorrow;\n            len += 1;\n        }\n\n        if (toWithdraw > looseAssets) {\n            // Removes Collateral\n            actions[len] = ActionType.removeCollateral;\n            datas[len] = abi.encodePacked(vaultID, toWithdraw - looseAssets);\n        }\n\n        if (toRepay > 0) _pull(toRepay);\n        vaultManager.angle(actions, datas, address(this), address(this), address(this), \"\");\n        if (toBorrow > 0) _push(toBorrow);\n    }\n\n    /// @notice Virtual function to invest stablecoins\n    /// @param amount Amount of new stablecoins managed\n    /// @return amountInvested Amount invested in the strategy\n    /// @dev Calling this function should eventually trigger something regarding strategies depending\n    /// on a threshold\n    function _push(uint256 amount) internal virtual returns (uint256 amountInvested) {}\n\n    /// @notice Virtual function to withdraw stablecoins\n    /// @param amount Amount needed at the end of the call\n    /// @return amountAvailable Amount available in the contracts, it's like a new `looseAssets` value\n    /// @dev Eventually actually triggers smthg depending on a threshold\n    /// @dev Calling this function should eventually trigger something regarding strategies depending\n    /// on a threshold\n    function _pull(uint256 amount) internal virtual returns (uint256 amountAvailable) {}\n\n    /// @notice Claims rewards earned by a user\n    /// @param from Address to claim rewards from\n    /// @return amount Amount claimed by the user\n    /// @dev Function will revert if there has been no mint\n    function _claim(address from) internal returns (uint256 amount) {\n        amount = (claimableRewards * rewardsAccumulatorOf[from]) / (rewardsAccumulator - claimedRewardsAccumulator);\n\n        claimedRewardsAccumulator += rewardsAccumulatorOf[from];\n        rewardsAccumulatorOf[from] = 0;\n        lastTimeOf[from] = block.timestamp;\n\n        claimableRewards -= amount;\n\n        amount = _pull(amount);\n        stablecoin.transfer(from, amount);\n    }\n\n    /// @notice Updates global and `msg.sender` accumulator and rewards share\n    /// @param from Address balance changed\n    function _updateAccumulator(address from) internal {\n        rewardsAccumulator += (block.timestamp - lastTime) * totalSupply();\n        lastTime = block.timestamp;\n\n        rewardsAccumulatorOf[from] += (block.timestamp - lastTimeOf[from]) * balanceOf(from);\n        lastTimeOf[from] = block.timestamp;\n    }\n\n    /// @notice Internal function for `deposit` and `mint`\n    /// @dev This function takes `usedAssets` and `looseAssets` as parameters to avoid repeated external calls\n    function _deposit(\n        uint256 assets,\n        uint256 shares,\n        address to,\n        uint256 usedAssets,\n        uint256 looseAssets\n    ) internal {\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n        _updateAccumulator(to);\n        _mint(to, shares);\n\n        emit Deposit(msg.sender, to, assets, shares);\n\n        _rebalance(0, usedAssets, looseAssets);\n    }\n\n    /// @notice Internal function for `redeem` and `withdraw`\n    /// @dev This function takes `usedAssets` and `looseAssets` as parameters to avoid repeated external calls\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address to,\n        address from,\n        uint256 usedAssets,\n        uint256 looseAssets\n    ) internal {\n        if (msg.sender != from) {\n            uint256 currentAllowance = allowance(from, msg.sender);\n            require(currentAllowance >= shares, \"ERC20: transfer amount exceeds allowance\");\n            if (currentAllowance != type(uint256).max) {\n                unchecked {\n                    _approve(from, msg.sender, currentAllowance - shares);\n                }\n            }\n        }\n\n        _updateAccumulator(from);\n        _rebalance(assets, usedAssets, looseAssets);\n\n        _claim(from);\n\n        _burn(from, shares);\n\n        emit Withdraw(from, to, assets, shares);\n        asset.safeTransfer(to, assets);\n    }\n\n    // ======================== Governance Functions ===============================\n\n    /// @notice Changes the reference to the `oracle` contract\n    /// @dev This is a permissionless function anyone can call to make sure that the oracle\n    /// contract of the `VaultManager` is the same as the oracle contract of this contract\n    function setOracle() external {\n        oracle = vaultManager.oracle();\n    }\n\n    /// @notice Changes the treasury contract\n    /// @dev Like the function above, this permissionless function just adjusts the treasury to\n    /// the address of the treasury contract from the `vaultManager` in case it has been modified\n    function setTreasury() external {\n        treasury = vaultManager.treasury();\n    }\n\n    /// @notice Changes the dust parameter by querying the `vaultManager`\n    function setDust() external {\n        vaultManagerDust = vaultManager.dust();\n    }\n\n    /// @notice Sets parameters encoded as uint64\n    /// @param param Value for the parameter\n    /// @param what Parameter to change\n    /// @dev This function performs the required checks when updating a parameter\n    function setUint64(uint64 param, bytes32 what) external onlyGovernorOrGuardian {\n        if (what == \"lowerCF\") {\n            require(0 < param && param <= targetCF, \"18\");\n            lowerCF = param;\n        } else if (what == \"targetCF\") {\n            require(lowerCF <= param && param <= upperCF, \"18\");\n            targetCF = param;\n        } else if (what == \"upperCF\") {\n            require(targetCF <= param && param <= vaultManager.collateralFactor(), \"18\");\n            upperCF = param;\n        } else {\n            revert(\"43\");\n        }\n        emit FiledUint64(param, what);\n    }\n\n    /// @notice Allows to recover any ERC20 token, including the asset managed by the reactor\n    /// @param tokenAddress Address of the token to recover\n    /// @param to Address of the contract to send collateral to\n    /// @param amountToRecover Amount of collateral to transfer\n    /// @dev Can be used to handle partial liquidation and debt repayment in case it is needed: in this\n    /// case governance can withdraw assets, swap in stablecoins to repay debt\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyGovernor {\n        require(tokenAddress != address(stablecoin), \"51\");\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n}\n\ncontract Reactor is BaseReactor {\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        IVaultManager _vaultManager,\n        uint64 _lowerCF,\n        uint64 _targetCF,\n        uint64 _upperCF\n    ) external {\n        _initialize(_name, _symbol, _vaultManager, _lowerCF, _targetCF, _upperCF);\n    }\n}\n"
    },
    "contracts/reactor/EulerReactor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IEulerMarket.sol\";\n\nimport \"./BaseReactor.sol\";\n\n/// @title EulerReactor\n/// @notice Reactor to mint agEUR and deposit them on Euler Finance (https://www.euler.finance/)\n/// @author Angle Core Team\ncontract EulerReactor is BaseReactor {\n    IEulerEToken public euler;\n\n    /// @notice Initializes the `BaseReactor` contract and\n    /// the underlying `VaultManager`\n    /// @param _name Name of the ERC4626 token\n    /// @param _symbol Symbol of the ERC4626 token\n    /// @param _vaultManager Underlying `VaultManager` used to borrow stablecoin\n    /// @param _lowerCF Lower Collateral Factor accepted without rebalancing\n    /// @param _targetCF Target Collateral Factor\n    /// @param _upperCF Upper Collateral Factor accepted without rebalancing\n    function initialize(\n        IEulerEToken _euler,\n        string memory _name,\n        string memory _symbol,\n        IVaultManager _vaultManager,\n        uint64 _lowerCF,\n        uint64 _targetCF,\n        uint64 _upperCF\n    ) external {\n        euler = _euler;\n        _initialize(_name, _symbol, _vaultManager, _lowerCF, _targetCF, _upperCF);\n    }\n\n    /// @notice Virtual function to invest stablecoins\n    /// @param amount Amount of new stablecoins managed\n    /// @return amountInvested Amount invested in the strategy\n    /// @dev Calling this function should eventually trigger something regarding strategies depending\n    /// on a threshold\n    function _push(uint256 amount) internal virtual override returns (uint256 amountInvested) {\n        euler.deposit(0, amount);\n        return amount;\n    }\n\n    /// @notice Virtual function to withdraw stablecoins\n    /// @param amount Amount needed at the end of the call\n    /// @return amountAvailable Amount available in the contracts, it's like a new `looseAssets` value\n    /// @dev Eventually actually triggers smthg depending on a threshold\n    /// @dev Calling this function should eventually trigger something regarding strategies depending\n    /// on a threshold\n    function _pull(uint256 amount) internal virtual override returns (uint256 amountAvailable) {\n        uint256 looseStablecoins = stablecoin.balanceOf(address(this));\n        if (amount <= looseStablecoins) return looseStablecoins;\n        euler.withdraw(0, looseStablecoins - amount);\n    }\n}\n"
    },
    "contracts/interfaces/IEulerMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Forked from https://github.com/euler-xyz/euler-interfaces\npragma solidity >=0.8.12;\n\n/// @notice Main storage contract for the Euler system\ninterface IEuler {\n    /// @notice Lookup the current implementation contract for a module\n    /// @param moduleId Fixed constant that refers to a module type (ie MODULEID__ETOKEN)\n    /// @return An internal address specifies the module's implementation code\n    function moduleIdToImplementation(uint256 moduleId) external view returns (address);\n\n    /// @notice Lookup a proxy that can be used to interact with a module (only valid for single-proxy modules)\n    /// @param moduleId Fixed constant that refers to a module type (ie MODULEID__MARKETS)\n    /// @return An address that should be cast to the appropriate module interface, ie IEulerMarkets(moduleIdToProxy(2))\n    function moduleIdToProxy(uint256 moduleId) external view returns (address);\n\n    /// @notice Euler-related configuration for an asset\n    struct AssetConfig {\n        address eTokenAddress;\n        bool borrowIsolated;\n        uint32 collateralFactor;\n        uint32 borrowFactor;\n        uint24 twapWindow;\n    }\n}\n\n/// @notice Activating and querying markets, and maintaining entered markets lists\ninterface IEulerMarkets {\n    /// @notice Create an Euler pool and associated EToken and DToken addresses.\n    /// @param underlying The address of an ERC20-compliant token. There must be an initialised uniswap3 pool for the underlying/reference asset pair.\n    /// @return The created EToken, or the existing EToken if already activated.\n    function activateMarket(address underlying) external returns (address);\n\n    /// @notice Create a pToken and activate it on Euler. pTokens are protected wrappers around assets that prevent borrowing.\n    /// @param underlying The address of an ERC20-compliant token. There must already be an activated market on Euler for this underlying, and it must have a non-zero collateral factor.\n    /// @return The created pToken, or an existing one if already activated.\n    function activatePToken(address underlying) external returns (address);\n\n    /// @notice Given an underlying, lookup the associated EToken\n    /// @param underlying Token address\n    /// @return EToken address, or address(0) if not activated\n    function underlyingToEToken(address underlying) external view returns (address);\n\n    /// @notice Given an underlying, lookup the associated DToken\n    /// @param underlying Token address\n    /// @return DToken address, or address(0) if not activated\n    function underlyingToDToken(address underlying) external view returns (address);\n\n    /// @notice Given an underlying, lookup the associated PToken\n    /// @param underlying Token address\n    /// @return PToken address, or address(0) if it doesn't exist\n    function underlyingToPToken(address underlying) external view returns (address);\n\n    /// @notice Looks up the Euler-related configuration for a token, and resolves all default-value placeholders to their currently configured values.\n    /// @param underlying Token address\n    /// @return Configuration struct\n    function underlyingToAssetConfig(address underlying) external view returns (IEuler.AssetConfig memory);\n\n    /// @notice Looks up the Euler-related configuration for a token, and returns it unresolved (with default-value placeholders)\n    /// @param underlying Token address\n    /// @return config Configuration struct\n    function underlyingToAssetConfigUnresolved(address underlying)\n        external\n        view\n        returns (IEuler.AssetConfig memory config);\n\n    /// @notice Given an EToken address, looks up the associated underlying\n    /// @param eToken EToken address\n    /// @return underlying Token address\n    function eTokenToUnderlying(address eToken) external view returns (address underlying);\n\n    /// @notice Given an EToken address, looks up the associated DToken\n    /// @param eToken EToken address\n    /// @return dTokenAddr DToken address\n    function eTokenToDToken(address eToken) external view returns (address dTokenAddr);\n\n    /// @notice Looks up an asset's currently configured interest rate model\n    /// @param underlying Token address\n    /// @return Module ID that represents the interest rate model (IRM)\n    function interestRateModel(address underlying) external view returns (uint256);\n\n    /// @notice Retrieves the current interest rate for an asset\n    /// @param underlying Token address\n    /// @return The interest rate in yield-per-second, scaled by 10**27\n    function interestRate(address underlying) external view returns (int96);\n\n    /// @notice Retrieves the current interest rate accumulator for an asset\n    /// @param underlying Token address\n    /// @return An opaque accumulator that increases as interest is accrued\n    function interestAccumulator(address underlying) external view returns (uint256);\n\n    /// @notice Retrieves the reserve fee in effect for an asset\n    /// @param underlying Token address\n    /// @return Amount of interest that is redirected to the reserves, as a fraction scaled by RESERVE_FEE_SCALE (4e9)\n    function reserveFee(address underlying) external view returns (uint32);\n\n    /// @notice Retrieves the pricing config for an asset\n    /// @param underlying Token address\n    /// @return pricingType (1=pegged, 2=uniswap3, 3=forwarded)\n    /// @return pricingParameters If uniswap3 pricingType then this represents the uniswap pool fee used, otherwise unused\n    /// @return pricingForwarded If forwarded pricingType then this is the address prices are forwarded to, otherwise address(0)\n    function getPricingConfig(address underlying)\n        external\n        view\n        returns (\n            uint16 pricingType,\n            uint32 pricingParameters,\n            address pricingForwarded\n        );\n\n    /// @notice Retrieves the list of entered markets for an account (assets enabled for collateral or borrowing)\n    /// @param account User account\n    /// @return List of underlying token addresses\n    function getEnteredMarkets(address account) external view returns (address[] memory);\n\n    /// @notice Add an asset to the entered market list, or do nothing if already entered\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param newMarket Underlying token address\n    function enterMarket(uint256 subAccountId, address newMarket) external;\n\n    /// @notice Remove an asset from the entered market list, or do nothing if not already present\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param oldMarket Underlying token address\n    function exitMarket(uint256 subAccountId, address oldMarket) external;\n}\n\n/// @notice Definition of callback method that deferLiquidityCheck will invoke on your contract\ninterface IDeferredLiquidityCheck {\n    function onDeferredLiquidityCheck(bytes memory data) external;\n}\n\n/// @notice Batch executions, liquidity check deferrals, and interfaces to fetch prices and account liquidity\ninterface IEulerExec {\n    /// @notice Liquidity status for an account, either in aggregate or for a particular asset\n    struct LiquidityStatus {\n        uint256 collateralValue;\n        uint256 liabilityValue;\n        uint256 numBorrows;\n        bool borrowIsolated;\n    }\n\n    /// @notice Aggregate struct for reporting detailed (per-asset) liquidity for an account\n    struct AssetLiquidity {\n        address underlying;\n        LiquidityStatus status;\n    }\n\n    /// @notice Single item in a batch request\n    struct EulerBatchItem {\n        bool allowError;\n        address proxyAddr;\n        bytes data;\n    }\n\n    /// @notice Single item in a batch response\n    struct EulerBatchItemResponse {\n        bool success;\n        bytes result;\n    }\n\n    /// @notice Compute aggregate liquidity for an account\n    /// @param account User address\n    /// @return status Aggregate liquidity (sum of all entered assets)\n    function liquidity(address account) external returns (LiquidityStatus memory status);\n\n    /// @notice Compute detailed liquidity for an account, broken down by asset\n    /// @param account User address\n    /// @return assets List of user's entered assets and each asset's corresponding liquidity\n    function detailedLiquidity(address account) external returns (AssetLiquidity[] memory assets);\n\n    /// @notice Retrieve Euler's view of an asset's price\n    /// @param underlying Token address\n    /// @return twap Time-weighted average price\n    /// @return twapPeriod TWAP duration, either the twapWindow value in AssetConfig, or less if that duration not available\n    function getPrice(address underlying) external returns (uint256 twap, uint256 twapPeriod);\n\n    /// @notice Retrieve Euler's view of an asset's price, as well as the current marginal price on uniswap\n    /// @param underlying Token address\n    /// @return twap Time-weighted average price\n    /// @return twapPeriod TWAP duration, either the twapWindow value in AssetConfig, or less if that duration not available\n    /// @return currPrice The current marginal price on uniswap3 (informational: not used anywhere in the Euler protocol)\n    function getPriceFull(address underlying)\n        external\n        returns (\n            uint256 twap,\n            uint256 twapPeriod,\n            uint256 currPrice\n        );\n\n    /// @notice Defer liquidity checking for an account, to perform rebalancing, flash loans, etc. msg.sender must implement IDeferredLiquidityCheck\n    /// @param account The account to defer liquidity for. Usually address(this), although not always\n    /// @param data Passed through to the onDeferredLiquidityCheck() callback, so contracts don't need to store transient data in storage\n    function deferLiquidityCheck(address account, bytes memory data) external;\n\n    /// @notice Execute several operations in a single transaction\n    /// @param items List of operations to execute\n    /// @param deferLiquidityChecks List of user accounts to defer liquidity checks for\n    /// @return List of operation results\n    function batchDispatch(EulerBatchItem[] calldata items, address[] calldata deferLiquidityChecks)\n        external\n        returns (EulerBatchItemResponse[] memory);\n\n    /// @notice Results of a batchDispatch, but with extra information\n    struct EulerBatchExtra {\n        EulerBatchItemResponse[] responses;\n        uint256 gasUsed;\n        AssetLiquidity[][] liquidities;\n    }\n\n    /// @notice Call batchDispatch, but return extra information. Only intended to be used with callStatic.\n    /// @param items List of operations to execute\n    /// @param deferLiquidityChecks List of user accounts to defer liquidity checks for\n    /// @param queryLiquidity List of user accounts to return detailed liquidity information for\n    /// @return output Structure with extra information\n    function batchDispatchExtra(\n        EulerBatchItem[] calldata items,\n        address[] calldata deferLiquidityChecks,\n        address[] calldata queryLiquidity\n    ) external returns (EulerBatchExtra memory output);\n\n    /// @notice Enable average liquidity tracking for your account. Operations will cost more gas, but you may get additional benefits when performing liquidations\n    /// @param subAccountId subAccountId 0 for primary, 1-255 for a sub-account.\n    /// @param delegate An address of another account that you would allow to use the benefits of your account's average liquidity (use the null address if you don't care about this). The other address must also reciprocally delegate to your account.\n    /// @param onlyDelegate Set this flag to skip tracking average liquidity and only set the delegate.\n    function trackAverageLiquidity(\n        uint256 subAccountId,\n        address delegate,\n        bool onlyDelegate\n    ) external;\n\n    /// @notice Disable average liquidity tracking for your account and remove delegate\n    /// @param subAccountId subAccountId 0 for primary, 1-255 for a sub-account\n    function unTrackAverageLiquidity(uint256 subAccountId) external;\n\n    /// @notice Retrieve the average liquidity for an account\n    /// @param account User account (xor in subAccountId, if applicable)\n    /// @return The average liquidity, in terms of the reference asset, and post risk-adjustment\n    function getAverageLiquidity(address account) external returns (uint256);\n\n    /// @notice Retrieve the average liquidity for an account or a delegate account, if set\n    /// @param account User account (xor in subAccountId, if applicable)\n    /// @return The average liquidity, in terms of the reference asset, and post risk-adjustment\n    function getAverageLiquidityWithDelegate(address account) external returns (uint256);\n\n    /// @notice Retrieve the account which delegates average liquidity for an account, if set\n    /// @param account User account (xor in subAccountId, if applicable)\n    /// @return The average liquidity delegate account\n    function getAverageLiquidityDelegateAccount(address account) external view returns (address);\n\n    /// @notice Transfer underlying tokens from sender's wallet into the pToken wrapper. Allowance should be set for the euler address.\n    /// @param underlying Token address\n    /// @param amount The amount to wrap in underlying units\n    function pTokenWrap(address underlying, uint256 amount) external;\n\n    /// @notice Transfer underlying tokens from the pToken wrapper to the sender's wallet.\n    /// @param underlying Token address\n    /// @param amount The amount to unwrap in underlying units\n    function pTokenUnWrap(address underlying, uint256 amount) external;\n}\n\n/// @notice Tokenised representation of assets\ninterface IEulerEToken {\n    /// @notice Pool name, ie \"Euler Pool: DAI\"\n    function name() external view returns (string memory);\n\n    /// @notice Pool symbol, ie \"eDAI\"\n    function symbol() external view returns (string memory);\n\n    /// @notice Decimals, always normalised to 18.\n    function decimals() external pure returns (uint8);\n\n    /// @notice Sum of all balances, in internal book-keeping units (non-increasing)\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Sum of all balances, in underlying units (increases as interest is earned)\n    function totalSupplyUnderlying() external view returns (uint256);\n\n    /// @notice Balance of a particular account, in internal book-keeping units (non-increasing)\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Balance of a particular account, in underlying units (increases as interest is earned)\n    function balanceOfUnderlying(address account) external view returns (uint256);\n\n    /// @notice Balance of the reserves, in internal book-keeping units (non-increasing)\n    function reserveBalance() external view returns (uint256);\n\n    /// @notice Balance of the reserves, in underlying units (increases as interest is earned)\n    function reserveBalanceUnderlying() external view returns (uint256);\n\n    /// @notice Updates interest accumulator and totalBorrows, credits reserves, re-targets interest rate, and logs asset status\n    function touch() external;\n\n    /// @notice Transfer underlying tokens from sender to the Euler pool, and increase account's eTokens\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param amount In underlying units (use max uint256 for full underlying token balance)\n    function deposit(uint256 subAccountId, uint256 amount) external;\n\n    /// @notice Transfer underlying tokens from Euler pool to sender, and decrease account's eTokens\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param amount In underlying units (use max uint256 for full pool balance)\n    function withdraw(uint256 subAccountId, uint256 amount) external;\n}\n"
    },
    "contracts/mock/MockStableMaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IStableMaster.sol\";\nimport \"../interfaces/IAgToken.sol\";\n\ncontract MockStableMaster is IStableMaster {\n    mapping(address => uint256) public poolManagerMap;\n\n    constructor() {}\n\n    function updateStocksUsers(uint256 amount, address poolManager) external override {\n        poolManagerMap[poolManager] += amount;\n    }\n\n    function burnSelf(\n        IAgToken agToken,\n        uint256 amount,\n        address burner\n    ) external {\n        agToken.burnSelf(amount, burner);\n    }\n\n    function burnFrom(\n        IAgToken agToken,\n        uint256 amount,\n        address burner,\n        address sender\n    ) external {\n        agToken.burnFrom(amount, burner, sender);\n    }\n\n    function mint(\n        IAgToken agToken,\n        address account,\n        uint256 amount\n    ) external {\n        agToken.mint(account, amount);\n    }\n}\n"
    },
    "contracts/oracle/BaseOracleChainlinkMulti.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\n/// @title BaseOracleChainlinkMulti\n/// @author Angle Core Team\n/// @notice Base Contract to be overriden by all contracts of the protocol\n/// @dev This base contract concerns an oracle that uses Chainlink with multiple pools to read from\n/// @dev All gas-efficient implementation of the `OracleChainlinkMulti` contract should inherit from this\nabstract contract BaseOracleChainlinkMulti is IOracle {\n    // ========================= Parameters and References =========================\n\n    /// @inheritdoc IOracle\n    ITreasury public override treasury;\n    /// @notice Represent the maximum amount of time (in seconds) between each Chainlink update\n    /// before the price feed is considered stale\n    uint32 public stalePeriod;\n\n    // =================================== Event ===================================\n\n    event StalePeriodUpdated(uint32 _stalePeriod);\n\n    /// @notice Constructor for an oracle using Chainlink with multiple pools to read from\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the VaultManager which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) {\n        stalePeriod = _stalePeriod;\n        treasury = ITreasury(_treasury);\n    }\n\n    // ============================= Reading Oracles ===============================\n\n    /// @inheritdoc IOracle\n    function read() external view virtual override returns (uint256 quoteAmount);\n\n    /// @notice Reads a Chainlink feed using a quote amount and converts the quote amount to\n    /// the out-currency\n    /// @param quoteAmount The amount for which to compute the price expressed with base decimal\n    /// @param feed Chainlink feed to query\n    /// @param multiplied Whether the ratio outputted by Chainlink should be multiplied or divided\n    /// to the `quoteAmount`\n    /// @param decimals Number of decimals of the corresponding Chainlink pair\n    /// @return The `quoteAmount` converted in out-currency\n    function _readChainlinkFeed(\n        uint256 quoteAmount,\n        AggregatorV3Interface feed,\n        uint8 multiplied,\n        uint256 decimals\n    ) internal view returns (uint256) {\n        (uint80 roundId, int256 ratio, , uint256 updatedAt, uint80 answeredInRound) = feed.latestRoundData();\n        require(ratio > 0 && roundId <= answeredInRound && block.timestamp - updatedAt <= stalePeriod, \"37\");\n        uint256 castedRatio = uint256(ratio);\n        // Checking whether we should multiply or divide by the ratio computed\n        if (multiplied == 1) return (quoteAmount * castedRatio) / (10**decimals);\n        else return (quoteAmount * (10**decimals)) / castedRatio;\n    }\n\n    // ======================= Governance Related Functions ========================\n\n    /// @notice Changes the stale period\n    /// @param _stalePeriod New stale period (in seconds)\n    function changeStalePeriod(uint32 _stalePeriod) external {\n        require(treasury.isGovernorOrGuardian(msg.sender), \"2\");\n        stalePeriod = _stalePeriod;\n        emit StalePeriodUpdated(_stalePeriod);\n    }\n\n    /// @inheritdoc IOracle\n    function setTreasury(address _treasury) external override {\n        require(treasury.isVaultManager(msg.sender) || treasury.isGovernor(msg.sender), \"3\");\n        treasury = ITreasury(_treasury);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/oracle/OracleChainlinkMultiTemplate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"./BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleChainlinkMultiTemplate\n/// @author Angle Core Team\n/// @notice Oracle contract, one contract is deployed per collateral/stablecoin pair\n/// @dev This contract concerns an oracle that uses Chainlink with multiple pools to read from\n/// @dev This is a template and a more gas-efficient implementation of the `OracleChainlinkMulti` contract\ncontract OracleChainlinkMultiTemplate is BaseOracleChainlinkMulti {\n    // ===================== To be modified before deployment ======================\n    uint256 public constant OUTBASE = 10**18;\n    bytes32 public constant DESCRIPTION = \"ETH/EUR Oracle\";\n\n    // =============================================================================\n\n    /// @notice Constructor for an oracle using Chainlink with multiple pools to read from\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the VaultManager which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    // ============================= Reading Oracles ===============================\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        // ===================== To be modified before deployment ==================\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            AggregatorV3Interface(address(0)),\n            AggregatorV3Interface(address(0))\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [0, 0];\n        uint8[2] memory chainlinkDecimals = [0, 0];\n        // =========================================================================\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/OracleChainlinkMulti.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"./BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleChainlinkMulti\n/// @author Angle Core Team\n/// @notice Oracle contract, one contract is deployed per collateral/stablecoin pair\n/// @dev This contract concerns an oracle that uses Chainlink with multiple pools to read from\n/// @dev Typically we expect to use this contract to read like the ETH/USD and then USD/EUR feed\ncontract OracleChainlinkMulti is BaseOracleChainlinkMulti {\n    // ========================= Parameters and References =========================\n\n    /// @notice Chainlink pools, the order of the pools has to be the order in which they are read for the computation\n    /// of the price\n    AggregatorV3Interface[] public circuitChainlink;\n    /// @notice Whether each rate for the pairs in `circuitChainlink` should be multiplied or divided\n    uint8[] public circuitChainIsMultiplied;\n    /// @notice Decimals for each Chainlink pairs\n    uint8[] public chainlinkDecimals;\n    /// @notice Unit of the stablecoin\n    uint256 public immutable outBase;\n    /// @notice Description of the assets concerned by the oracle and the price outputted\n    bytes32 public immutable description;\n\n    /// @notice Constructor for an oracle using Chainlink with multiple pools to read from\n    /// @param _circuitChainlink Chainlink pool addresses (in order)\n    /// @param _circuitChainIsMultiplied Whether we should multiply or divide by this rate\n    /// @param _outBase Unit of the stablecoin (or the out asset) associated to the oracle\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the VaultManager which reads from this feed\n    /// @param _description Description of the assets concerned by the oracle\n    /// @dev For instance, if this oracle is supposed to give the price of ETH in EUR, and if the agEUR\n    /// stablecoin associated to EUR has 18 decimals, then `outBase` should be 10**18\n    constructor(\n        address[] memory _circuitChainlink,\n        uint8[] memory _circuitChainIsMultiplied,\n        uint256 _outBase,\n        uint32 _stalePeriod,\n        address _treasury,\n        bytes32 _description\n    ) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {\n        outBase = _outBase;\n        description = _description;\n        uint256 circuitLength = _circuitChainlink.length;\n        require(circuitLength > 0 && circuitLength == _circuitChainIsMultiplied.length, \"25\");\n        for (uint256 i = 0; i < circuitLength; i++) {\n            AggregatorV3Interface _pool = AggregatorV3Interface(_circuitChainlink[i]);\n            circuitChainlink.push(_pool);\n            chainlinkDecimals.push(_pool.decimals());\n        }\n        circuitChainIsMultiplied = _circuitChainIsMultiplied;\n    }\n\n    // ============================= Reading Oracles ===============================\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = outBase;\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/OracleWSTETHEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../BaseOracleChainlinkMulti.sol\";\nimport \"../../interfaces/IStETH.sol\";\n\n/// @title OracleWSTETHEURChainlink\n/// @author Angle Core Team\n/// @notice Gives the price of wSTETH in Euro in base 18\ncontract OracleWSTETHEURChainlink is BaseOracleChainlinkMulti {\n    bytes32 public constant DESCRIPTION = \"wSTETH/EUR Oracle\";\n    IStETH public constant STETH = IStETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = STETH.getPooledEthByShares(1 ether);\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Chainlink stETH/USD address\n            AggregatorV3Interface(0xCfE54B5cD566aB89272946F602D76Ea879CAb4a8),\n            // Chainlink EUR/USD address\n            AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IStETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title IStETH\n/// @author Angle Core Team\n/// @notice Interface for the `StETH` contract\n/// @dev This interface only contains functions of the `StETH` which are called by other contracts\n/// of this module\ninterface IStETH {\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\n}\n"
    },
    "contracts/oracle/implementations/OracleETHEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleETHEURChainlink\n/// @author Angle Core Team\n/// @notice Gives the price of ETH in Euro in base 18\ncontract OracleETHEURChainlink is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    bytes32 public constant DESCRIPTION = \"ETH/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle ETH/USD\n            AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/oracle/implementations/OracleBTCEURChainlink.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../BaseOracleChainlinkMulti.sol\";\n\n/// @title OracleBTCEURChainlink\n/// @author Angle Core Team\n/// @notice Gives the price of BTC in Euro in base 18\ncontract OracleBTCEURChainlink is BaseOracleChainlinkMulti {\n    uint256 public constant OUTBASE = 10**18;\n    bytes32 public constant DESCRIPTION = \"BTC/EUR Oracle\";\n\n    /// @notice Constructor of the contract\n    /// @param _stalePeriod Minimum feed update frequency for the oracle to not revert\n    /// @param _treasury Treasury associated to the `VaultManager` which reads from this feed\n    constructor(uint32 _stalePeriod, address _treasury) BaseOracleChainlinkMulti(_stalePeriod, _treasury) {}\n\n    /// @inheritdoc IOracle\n    function read() external view override returns (uint256 quoteAmount) {\n        quoteAmount = OUTBASE;\n        AggregatorV3Interface[2] memory circuitChainlink = [\n            // Oracle BTC/USD\n            AggregatorV3Interface(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c),\n            // Oracle EUR/USD\n            AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1)\n        ];\n        uint8[2] memory circuitChainIsMultiplied = [1, 0];\n        uint8[2] memory chainlinkDecimals = [8, 8];\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            quoteAmount = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i]\n            );\n        }\n    }\n}\n"
    },
    "contracts/mock/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IOracle.sol\";\n\ncontract MockOracle is IOracle {\n    event Update(uint256 _peg);\n\n    ITreasury public treasury;\n\n    uint256 public base = 1 ether;\n    uint256 public inBase;\n    uint256 public precision = 1 ether;\n    uint256 public rate;\n    bool public outdated;\n\n    /// @notice Initiate with a fixe change rate\n    constructor(\n        uint256 rate_,\n        uint256 _inDecimals,\n        ITreasury _treasury\n    ) {\n        rate = rate_;\n        inBase = 10**_inDecimals;\n        treasury = _treasury;\n    }\n\n    /// @notice Mock read\n    function read() external view override returns (uint256) {\n        return rate;\n    }\n\n    /// @notice change oracle rate\n    function update(uint256 newRate) external {\n        rate = newRate;\n    }\n\n    function changeInBase(uint256 newInBase) external {\n        inBase = newInBase;\n    }\n\n    function setTreasury(address _treasury) external override {\n        treasury = ITreasury(_treasury);\n    }\n}\n"
    },
    "contracts/vaultManager/VaultManagerERC721.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./VaultManagerStorage.sol\";\n\n/// @title VaultManagerERC721\n/// @author Angle Core Team\n/// @dev Base ERC721 Implementation of VaultManager\nabstract contract VaultManagerERC721 is IERC721MetadataUpgradeable, VaultManagerStorage {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// @inheritdoc IERC721MetadataUpgradeable\n    string public name;\n    /// @inheritdoc IERC721MetadataUpgradeable\n    string public symbol;\n\n    // ============================== Modifiers ====================================\n\n    /// @notice Checks if the person interacting with the vault with `vaultID` is approved\n    /// @param caller Address of the person seeking to interact with the vault\n    /// @param vaultID ID of the concerned vault\n    modifier onlyApprovedOrOwner(address caller, uint256 vaultID) {\n        require(_isApprovedOrOwner(caller, vaultID), \"16\");\n        _;\n    }\n\n    // =============================== ERC721 Logic ================================\n\n    /// @notice Returns all the vaults owned or controlled (under the form of approval) by an address\n    /// @param spender Address for which vault ownerships should be checked\n    /// @return List of `vaultID` controlled by this address\n    /// @dev This function is never to be called on-chain since it iterates over all addresses and is here\n    /// to reduce dependency on an external graph to link an ID to its owner\n    function getControlledVaults(address spender) external view returns (uint256[] memory, uint256) {\n        uint256 arraySize = _vaultIDCount;\n        uint256[] memory vaultsControlled = new uint256[](arraySize);\n        address owner;\n        uint256 count;\n        for (uint256 i = 1; i <= arraySize; i++) {\n            owner = _owners[i];\n            if (spender == owner || _getApproved(i) == spender || _operatorApprovals[owner][spender]) {\n                vaultsControlled[count] = i;\n                count += 1;\n            }\n        }\n        return (vaultsControlled, count);\n    }\n\n    /// @notice Checks whether a given address is approved for a vault or owns this vault\n    /// @param spender Address for which vault ownership should be checked\n    /// @param vaultID ID of the vault to check\n    /// @return Whether the `spender` address owns or is approved for `vaultID`\n    function isApprovedOrOwner(address spender, uint256 vaultID) external view returns (bool) {\n        return _isApprovedOrOwner(spender, vaultID);\n    }\n\n    /// @inheritdoc IERC721MetadataUpgradeable\n    function tokenURI(uint256 vaultID) external view returns (string memory) {\n        require(_exists(vaultID), \"26\");\n        // There is no vault with `vaultID` equal to 0, so the following variable is\n        // always greater than zero\n        uint256 temp = vaultID;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (vaultID != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(vaultID % 10)));\n            vaultID /= 10;\n        }\n        return bytes(_baseURI).length > 0 ? string(abi.encodePacked(_baseURI, string(buffer))) : \"\";\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"0\");\n        return _balances[owner];\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function ownerOf(uint256 vaultID) external view returns (address) {\n        return _ownerOf(vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function approve(address to, uint256 vaultID) external {\n        address owner = _ownerOf(vaultID);\n        require(to != owner, \"27\");\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"16\");\n\n        _approve(to, vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function getApproved(uint256 vaultID) external view returns (address) {\n        require(_exists(vaultID), \"26\");\n        return _getApproved(vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function setApprovalForAll(address operator, bool approved) external {\n        require(operator != msg.sender, \"28\");\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function transferFrom(\n        address from,\n        address to,\n        uint256 vaultID\n    ) external onlyApprovedOrOwner(msg.sender, vaultID) {\n        _transfer(from, to, vaultID);\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 vaultID\n    ) external {\n        safeTransferFrom(from, to, vaultID, \"\");\n    }\n\n    /// @inheritdoc IERC721Upgradeable\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 vaultID,\n        bytes memory _data\n    ) public onlyApprovedOrOwner(msg.sender, vaultID) {\n        _safeTransfer(from, to, vaultID, _data);\n    }\n\n    // =============================== ERC165 logic ================================\n\n    /// @inheritdoc IERC165Upgradeable\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IVaultManager).interfaceId ||\n            interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    // ============== Internal Functions for the ERC721 Logic ======================\n\n    /// @notice Internal version of the `ownerOf` function\n    function _ownerOf(uint256 vaultID) internal view returns (address owner) {\n        owner = _owners[vaultID];\n        require(owner != address(0), \"26\");\n    }\n\n    /// @notice Internal version of the `getApproved` function\n    function _getApproved(uint256 vaultID) internal view returns (address) {\n        return _vaultApprovals[vaultID];\n    }\n\n    /// @notice Internal version of the `safeTransferFrom` function (with the data parameter)\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 vaultID,\n        bytes memory _data\n    ) internal {\n        _transfer(from, to, vaultID);\n        require(_checkOnERC721Received(from, to, vaultID, _data), \"29\");\n    }\n\n    /// @notice Checks whether a vault exists\n    /// @param vaultID ID of the vault to check\n    /// @return Whether `vaultID` has been created\n    function _exists(uint256 vaultID) internal view returns (bool) {\n        return _owners[vaultID] != address(0);\n    }\n\n    /// @notice Internal version of the `isApprovedOrOwner` function\n    function _isApprovedOrOwner(address spender, uint256 vaultID) internal view returns (bool) {\n        // The following checks if the vault exists\n        address owner = _ownerOf(vaultID);\n        return (spender == owner || _getApproved(vaultID) == spender || _operatorApprovals[owner][spender]);\n    }\n\n    /// @notice Internal version of the `createVault` function\n    /// Mints `vaultID` and transfers it to `to`\n    /// @dev This method is equivalent to the `_safeMint` method used in OpenZeppelin ERC721 contract\n    /// @dev Emits a {Transfer} event\n    function _mint(address to) internal returns (uint256 vaultID) {\n        require(!whitelistingActivated || (isWhitelisted[to] && isWhitelisted[msg.sender]), \"20\");\n        unchecked {\n            _vaultIDCount += 1;\n            _balances[to] += 1;\n        }\n        vaultID = _vaultIDCount;\n        _owners[vaultID] = to;\n        emit Transfer(address(0), to, vaultID);\n        require(_checkOnERC721Received(address(0), to, vaultID, \"\"), \"29\");\n    }\n\n    /// @notice Destroys `vaultID`\n    /// @dev `vaultID` must exist\n    /// @dev Emits a {Transfer} event\n    function _burn(uint256 vaultID) internal {\n        address owner = _ownerOf(vaultID);\n\n        // Clear approvals\n        _approve(address(0), vaultID);\n        // The following line cannot underflow as the owner's balance is necessarily\n        // greater than 1\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[vaultID];\n        delete vaultData[vaultID];\n\n        emit Transfer(owner, address(0), vaultID);\n    }\n\n    /// @notice Transfers `vaultID` from `from` to `to` as opposed to {transferFrom},\n    /// this imposes no restrictions on msg.sender\n    /// @dev `to` cannot be the zero address and `perpetualID` must be owned by `from`\n    /// @dev Emits a {Transfer} event\n    /// @dev A whitelist check is performed if necessary on the `to` address\n    function _transfer(\n        address from,\n        address to,\n        uint256 vaultID\n    ) internal {\n        require(_ownerOf(vaultID) == from, \"30\");\n        require(to != address(0), \"31\");\n        require(!whitelistingActivated || isWhitelisted[to], \"20\");\n        // Clear approvals from the previous owner\n        _approve(address(0), vaultID);\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[vaultID] = to;\n\n        emit Transfer(from, to, vaultID);\n    }\n\n    /// @notice Approves `to` to operate on `vaultID`\n    function _approve(address to, uint256 vaultID) internal {\n        _vaultApprovals[vaultID] = to;\n        emit Approval(_ownerOf(vaultID), to, vaultID);\n    }\n\n    /// @notice Internal function to invoke {IERC721Receiver-onERC721Received} on a target address\n    /// The call is not executed if the target address is not a contract\n    /// @param from Address representing the previous owner of the given token ID\n    /// @param to Target address that will receive the tokens\n    /// @param vaultID ID of the token to be transferred\n    /// @param _data Bytes optional data to send along with the call\n    /// @return Bool whether the call correctly returned the expected value\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 vaultID,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(msg.sender, from, vaultID, _data) returns (\n                bytes4 retval\n            ) {\n                return retval == IERC721ReceiverUpgradeable(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"24\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n}\n"
    },
    "contracts/vaultManager/VaultManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./VaultManagerERC721.sol\";\n\n/// @title VaultManager\n/// @author Angle Core Team\n/// @notice This contract allows people to deposit collateral and open up loans of a given AgToken. It handles all the loan\n/// logic (fees and interest rate) as well as the liquidation logic\n/// @dev This implementation only supports non-rebasing ERC20 tokens as collateral\n/// @dev This contract is encoded as a NFT contract\ncontract VaultManager is VaultManagerERC721, IVaultManagerFunctions {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// @inheritdoc IVaultManagerFunctions\n    function initialize(\n        ITreasury _treasury,\n        IERC20 _collateral,\n        IOracle _oracle,\n        VaultParameters calldata params,\n        string memory _symbol\n    ) external initializer {\n        require(_oracle.treasury() == _treasury, \"33\");\n        treasury = _treasury;\n        collateral = _collateral;\n        _collatBase = 10**(IERC20Metadata(address(collateral)).decimals());\n        stablecoin = IAgToken(_treasury.stablecoin());\n        oracle = _oracle;\n\n        name = string.concat(\"Angle Protocol \", _symbol, \" Vault\");\n        symbol = string.concat(_symbol, \"-vault\");\n\n        interestAccumulator = BASE_INTEREST;\n        lastInterestAccumulatorUpdated = block.timestamp;\n\n        // Checking if the parameters have been correctly initialized\n        require(\n            params.collateralFactor <= params.liquidationSurcharge &&\n                BASE_PARAMS <= params.targetHealthFactor &&\n                params.liquidationSurcharge <= BASE_PARAMS &&\n                params.borrowFee <= BASE_PARAMS &&\n                params.maxLiquidationDiscount < BASE_PARAMS &&\n                0 < params.baseBoost,\n            \"15\"\n        );\n        debtCeiling = params.debtCeiling;\n        collateralFactor = params.collateralFactor;\n        targetHealthFactor = params.targetHealthFactor;\n        borrowFee = params.borrowFee;\n        interestRate = params.interestRate;\n        liquidationSurcharge = params.liquidationSurcharge;\n        maxLiquidationDiscount = params.maxLiquidationDiscount;\n        whitelistingActivated = params.whitelistingActivated;\n        yLiquidationBoost = [params.baseBoost];\n        paused = true;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(uint256 dust_, uint256 dustCollateral_) VaultManagerStorage(dust_, dustCollateral_) {}\n\n    // ============================== Modifiers ====================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or not\n    modifier onlyGovernor() {\n        require(treasury.isGovernor(msg.sender), \"1\");\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        require(treasury.isGovernorOrGuardian(msg.sender), \"2\");\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` is the treasury contract\n    modifier onlyTreasury() {\n        require(msg.sender == address(treasury), \"14\");\n        _;\n    }\n\n    /// @notice Checks whether the contract is paused\n    modifier whenNotPaused() {\n        require(!paused, \"42\");\n        _;\n    }\n\n    // =========================== Vault Functions =================================\n\n    // ========================= External Access Functions =========================\n\n    /// @inheritdoc IVaultManagerFunctions\n    function createVault(address toVault) external whenNotPaused returns (uint256) {\n        return _mint(toVault);\n    }\n\n    /// @inheritdoc IVaultManagerFunctions\n    function angle(\n        ActionType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to\n    ) external payable returns (PaymentData memory) {\n        return angle(actions, datas, from, to, address(0), new bytes(0));\n    }\n\n    /// @inheritdoc IVaultManagerFunctions\n    function angle(\n        ActionType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to,\n        address who,\n        bytes memory repayData\n    ) public payable whenNotPaused nonReentrant returns (PaymentData memory paymentData) {\n        uint256 newInterestRateAccumulator;\n        uint256 oracleValue;\n        uint256 collateralAmount;\n        uint256 stablecoinAmount;\n        uint256 vaultID;\n        for (uint256 i = 0; i < actions.length; i++) {\n            ActionType action = actions[i];\n            if (action == ActionType.createVault) {\n                _mint(abi.decode(datas[i], (address)));\n            } else if (action == ActionType.closeVault) {\n                (stablecoinAmount, collateralAmount, oracleValue, newInterestRateAccumulator) = _closeVault(\n                    abi.decode(datas[i], (uint256)),\n                    oracleValue,\n                    newInterestRateAccumulator\n                );\n                paymentData.collateralAmountToGive += collateralAmount;\n                paymentData.stablecoinAmountToReceive += stablecoinAmount;\n            } else if (action == ActionType.addCollateral) {\n                (vaultID, collateralAmount) = abi.decode(datas[i], (uint256, uint256));\n                _addCollateral(vaultID, collateralAmount);\n                paymentData.collateralAmountToReceive += collateralAmount;\n            } else if (action == ActionType.removeCollateral) {\n                (vaultID, collateralAmount) = abi.decode(datas[i], (uint256, uint256));\n                (oracleValue, newInterestRateAccumulator) = _removeCollateral(\n                    vaultID,\n                    collateralAmount,\n                    oracleValue,\n                    newInterestRateAccumulator\n                );\n                paymentData.collateralAmountToGive += collateralAmount;\n            } else if (action == ActionType.repayDebt) {\n                (vaultID, stablecoinAmount) = abi.decode(datas[i], (uint256, uint256));\n                (stablecoinAmount, newInterestRateAccumulator) = _repayDebt(\n                    vaultID,\n                    stablecoinAmount,\n                    newInterestRateAccumulator\n                );\n                paymentData.stablecoinAmountToReceive += stablecoinAmount;\n            } else if (action == ActionType.borrow) {\n                (vaultID, stablecoinAmount) = abi.decode(datas[i], (uint256, uint256));\n                (stablecoinAmount, oracleValue, newInterestRateAccumulator) = _borrow(\n                    vaultID,\n                    stablecoinAmount,\n                    oracleValue,\n                    newInterestRateAccumulator\n                );\n                paymentData.stablecoinAmountToGive += stablecoinAmount;\n            } else if (action == ActionType.getDebtIn) {\n                address vaultManager;\n                uint256 dstVaultID;\n                (vaultID, vaultManager, dstVaultID, stablecoinAmount) = abi.decode(\n                    datas[i],\n                    (uint256, address, uint256, uint256)\n                );\n                (oracleValue, newInterestRateAccumulator) = _getDebtIn(\n                    vaultID,\n                    IVaultManager(vaultManager),\n                    dstVaultID,\n                    stablecoinAmount,\n                    oracleValue,\n                    newInterestRateAccumulator\n                );\n            } else if (action == ActionType.permit) {\n                address owner;\n                bytes32 r;\n                bytes32 s;\n                // Watch out naming conventions for permit are not respected to save some space and reduce the stack size\n                // `vaultID` is used in place of the `deadline` parameter\n                // Same for `collateralAmount` used in place of `value`\n                // `stablecoinAmount` is used in place of the `v`\n                (owner, collateralAmount, vaultID, stablecoinAmount, r, s) = abi.decode(\n                    datas[i],\n                    (address, uint256, uint256, uint256, bytes32, bytes32)\n                );\n                IERC20PermitUpgradeable(address(collateral)).permit(\n                    owner,\n                    address(this),\n                    collateralAmount,\n                    vaultID,\n                    uint8(stablecoinAmount),\n                    r,\n                    s\n                );\n            }\n        }\n\n        // Processing the different cases for the repayment, there are 4 of them:\n        // - (1) Stablecoins to receive + collateral to send\n        // - (2) Stablecoins to receive + collateral to receive\n        // - (3) Stablecoins to send + collateral to send\n        // - (4) Stablecoins to send + collateral to receive\n        if (paymentData.stablecoinAmountToReceive >= paymentData.stablecoinAmountToGive) {\n            uint256 stablecoinPayment = paymentData.stablecoinAmountToReceive - paymentData.stablecoinAmountToGive;\n            if (paymentData.collateralAmountToGive >= paymentData.collateralAmountToReceive) {\n                // In the case where all amounts are null, the function will enter here and nothing will be done\n                // for the repayment\n                _handleRepay(\n                    // Collateral payment is the difference between what to give and what to receive\n                    paymentData.collateralAmountToGive - paymentData.collateralAmountToReceive,\n                    stablecoinPayment,\n                    from,\n                    to,\n                    who,\n                    repayData\n                );\n            } else {\n                if (stablecoinPayment > 0) stablecoin.burnFrom(stablecoinPayment, from, msg.sender);\n                // In this case the collateral amount is necessarily non null\n                collateral.safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    paymentData.collateralAmountToReceive - paymentData.collateralAmountToGive\n                );\n            }\n        } else {\n            uint256 stablecoinPayment = paymentData.stablecoinAmountToGive - paymentData.stablecoinAmountToReceive;\n            // `stablecoinPayment` is strictly positive in this case\n            stablecoin.mint(to, stablecoinPayment);\n            if (paymentData.collateralAmountToGive > paymentData.collateralAmountToReceive) {\n                collateral.safeTransfer(to, paymentData.collateralAmountToGive - paymentData.collateralAmountToReceive);\n            } else {\n                uint256 collateralPayment = paymentData.collateralAmountToReceive - paymentData.collateralAmountToGive;\n                if (repayData.length > 0 && collateralPayment > 0) {\n                    IRepayCallee(who).repayCallCollateral(msg.sender, stablecoinPayment, collateralPayment, repayData);\n                } else if (collateralPayment > 0)\n                    collateral.safeTransferFrom(msg.sender, address(this), collateralPayment);\n            }\n        }\n    }\n\n    /// @inheritdoc IVaultManagerFunctions\n    function getDebtOut(\n        uint256 vaultID,\n        uint256 stablecoinAmount,\n        uint256 senderBorrowFee\n    ) external whenNotPaused {\n        require(treasury.isVaultManager(msg.sender), \"3\");\n        // Checking the delta of borrow fees to eliminate the risk of exploits here\n        if (senderBorrowFee > borrowFee) {\n            uint256 borrowFeePaid = ((senderBorrowFee - borrowFee) * stablecoinAmount) / BASE_PARAMS;\n            stablecoinAmount -= borrowFeePaid;\n            surplus += borrowFeePaid;\n        }\n        _repayDebt(vaultID, stablecoinAmount, 0);\n    }\n\n    // ============================= View Functions ================================\n\n    /// @inheritdoc IVaultManagerFunctions\n    function getVaultDebt(uint256 vaultID) external view returns (uint256) {\n        return (vaultData[vaultID].normalizedDebt * _calculateCurrentInterestRateAccumulator()) / BASE_INTEREST;\n    }\n\n    /// @notice Gets the total debt across all vaults\n    /// @return Total debt across all vaults, taking into account the interest accumulated\n    /// over time\n    function getTotalDebt() external view returns (uint256) {\n        return (totalNormalizedDebt * _calculateCurrentInterestRateAccumulator()) / BASE_INTEREST;\n    }\n\n    /// @notice Checks whether a given vault is liquidable and if yes gives information regarding its liquidation\n    /// @param vaultID ID of the vault to check\n    /// @param liquidator Address of the liquidator which will be performing the liquidation\n    /// @return liqOpp Description of the opportunity of liquidation\n    /// @dev This function will revert if it's called on a vault that does not exist\n    function checkLiquidation(uint256 vaultID, address liquidator)\n        external\n        view\n        returns (LiquidationOpportunity memory liqOpp)\n    {\n        liqOpp = _checkLiquidation(\n            vaultData[vaultID],\n            liquidator,\n            oracle.read(),\n            _calculateCurrentInterestRateAccumulator()\n        );\n    }\n\n    // =================== Internal Utility View Functions =========================\n\n    /// @notice Verifies whether a given vault is solvent (i.e. should be liquidated or not)\n    /// @param vault Data of the vault to check\n    /// @param oracleValue Oracle value at the time of the call (it is in the base of the stablecoin, that is for agTokens 10**18)\n    /// @param newInterestRateAccumulator Value of the `interestRateAccumulator` at the time of the call\n    /// @return healthFactor Health factor of the vault: if it's inferior to 1 (`BASE_PARAMS` in fact) this means that the vault can be liquidated\n    /// @return currentDebt Current value of the debt of the vault (taking into account interest)\n    /// @return collateralAmountInStable Collateral in the vault expressed in stablecoin value\n    /// @return oracleValue Current value of the oracle\n    /// @return newInterestRateAccumulator Current value of the `interestRateAccumulator`\n    /// @dev If the oracle value or the interest rate accumulator has not been called at the time of the\n    /// call, this function computes it\n    function _isSolvent(\n        Vault memory vault,\n        uint256 oracleValue,\n        uint256 newInterestRateAccumulator\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (oracleValue == 0) oracleValue = oracle.read();\n        if (newInterestRateAccumulator == 0) newInterestRateAccumulator = _calculateCurrentInterestRateAccumulator();\n        uint256 currentDebt = (vault.normalizedDebt * newInterestRateAccumulator) / BASE_INTEREST;\n        uint256 collateralAmountInStable = (vault.collateralAmount * oracleValue) / _collatBase;\n        uint256 healthFactor;\n        if (currentDebt == 0) healthFactor = type(uint256).max;\n        else healthFactor = (collateralAmountInStable * collateralFactor) / currentDebt;\n        return (healthFactor, currentDebt, collateralAmountInStable, oracleValue, newInterestRateAccumulator);\n    }\n\n    /// @notice Calculates the current value of the `interestRateAccumulator` without updating the value\n    /// in storage\n    /// @dev This function avoids expensive exponentiation and the calculation is performed using a binomial approximation\n    /// (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n    /// @dev The approximation slightly undercharges borrowers with the advantage of a great gas cost reduction\n    /// @dev This function was mostly inspired from Aave implementation\n    function _calculateCurrentInterestRateAccumulator() internal view returns (uint256) {\n        uint256 exp = block.timestamp - lastInterestAccumulatorUpdated;\n        uint256 ratePerSecond = interestRate;\n        if (exp == 0 || ratePerSecond == 0) return interestAccumulator;\n        uint256 expMinusOne = exp - 1;\n        uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\n        uint256 basePowerTwo = (ratePerSecond * ratePerSecond + HALF_BASE_INTEREST) / BASE_INTEREST;\n        uint256 basePowerThree = (basePowerTwo * ratePerSecond + HALF_BASE_INTEREST) / BASE_INTEREST;\n        uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\n        uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\n        return (interestAccumulator * (BASE_INTEREST + ratePerSecond * exp + secondTerm + thirdTerm)) / BASE_INTEREST;\n    }\n\n    // =============== Internal Utility State-Modifying Functions ==================\n\n    /// @notice Closes a vault without handling the repayment of the concerned address\n    /// @param vaultID ID of the vault to close\n    /// @param oracleValueStart Oracle value at the start of the call: if it's 0 it's going to be computed\n    /// in the `_isSolvent` function\n    /// @param newInterestRateAccumulatorStart Interest rate accumulator value at the start of the call: if it's 0\n    /// it's going to be computed in the `isSolvent` function\n    /// @return Current debt of the vault to be repaid\n    /// @return Value of the collateral in the vault to reimburse\n    /// @return Current oracle value\n    /// @return Current interest rate accumulator value\n    /// @dev The returned values are here to facilitate composability between calls\n    function _closeVault(\n        uint256 vaultID,\n        uint256 oracleValueStart,\n        uint256 newInterestRateAccumulatorStart\n    )\n        internal\n        onlyApprovedOrOwner(msg.sender, vaultID)\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Vault memory vault = vaultData[vaultID];\n        // Optimize for gas here\n        (\n            uint256 healthFactor,\n            uint256 currentDebt,\n            ,\n            uint256 oracleValue,\n            uint256 newInterestRateAccumulator\n        ) = _isSolvent(vault, oracleValueStart, newInterestRateAccumulatorStart);\n        require(healthFactor > BASE_PARAMS, \"21\");\n        _burn(vaultID);\n        return (currentDebt, vault.collateralAmount, oracleValue, newInterestRateAccumulator);\n    }\n\n    /// @notice Increases the collateral balance of a vault\n    /// @param vaultID ID of the vault to increase the collateral balance of\n    /// @param collateralAmount Amount by which increasing the collateral balance of\n    function _addCollateral(uint256 vaultID, uint256 collateralAmount) internal {\n        vaultData[vaultID].collateralAmount += collateralAmount;\n        emit CollateralAmountUpdated(vaultID, collateralAmount, 1);\n    }\n\n    /// @notice Decreases the collateral balance from a vault (without proceeding to collateral transfers)\n    /// @param vaultID ID of the vault to decrease the collateral balance of\n    /// @param collateralAmount Amount of collateral to reduce the balance of\n    /// @param oracleValueStart Oracle value at the start of the call (given here to avoid double computations)\n    /// @param interestRateAccumulatorStart Value of the interest rate accumulator (potentially zero if it has not been\n    /// computed yet)\n    /// @return Computed value of the oracle\n    /// @return Computed value of the interest rate accumulator\n    function _removeCollateral(\n        uint256 vaultID,\n        uint256 collateralAmount,\n        uint256 oracleValueStart,\n        uint256 interestRateAccumulatorStart\n    ) internal onlyApprovedOrOwner(msg.sender, vaultID) returns (uint256, uint256) {\n        vaultData[vaultID].collateralAmount -= collateralAmount;\n        (uint256 healthFactor, , , uint256 oracleValue, uint256 newInterestRateAccumulator) = _isSolvent(\n            vaultData[vaultID],\n            oracleValueStart,\n            interestRateAccumulatorStart\n        );\n        require(healthFactor > BASE_PARAMS, \"21\");\n        emit CollateralAmountUpdated(vaultID, collateralAmount, 0);\n        return (oracleValue, newInterestRateAccumulator);\n    }\n\n    /// @notice Increases the debt balance of a vault and takes into account borrowing fees\n    /// @param vaultID ID of the vault to increase borrow balance of\n    /// @param stablecoinAmount Amount of stablecoins to borrow\n    /// @param oracleValueStart Oracle value at the start of the call (given here to avoid double computations)\n    /// @param newInterestRateAccumulatorStart Value of the interest rate accumulator (potentially zero if it has not been\n    /// computed yet)\n    /// @return toMint Amount of stablecoins to mint\n    /// @return oracleValue Computed value of the oracle\n    /// @return interestRateAccumulator Computed value of the interest rate accumulator\n    function _borrow(\n        uint256 vaultID,\n        uint256 stablecoinAmount,\n        uint256 oracleValueStart,\n        uint256 newInterestRateAccumulatorStart\n    )\n        internal\n        onlyApprovedOrOwner(msg.sender, vaultID)\n        returns (\n            uint256 toMint,\n            uint256 oracleValue,\n            uint256 interestRateAccumulator\n        )\n    {\n        (stablecoinAmount, oracleValue, interestRateAccumulator) = _increaseDebt(\n            vaultID,\n            stablecoinAmount,\n            oracleValueStart,\n            newInterestRateAccumulatorStart\n        );\n        uint256 borrowFeePaid = (borrowFee * stablecoinAmount) / BASE_PARAMS;\n        surplus += borrowFeePaid;\n        toMint = stablecoinAmount - borrowFeePaid;\n    }\n\n    /// @notice Internal version of the `getDebtIn` function\n    /// @return Computed value of the oracle\n    /// @return Computed value of the interest rate accumulator\n    function _getDebtIn(\n        uint256 srcVaultID,\n        IVaultManager vaultManager,\n        uint256 dstVaultID,\n        uint256 stablecoinAmount,\n        uint256 oracleValue,\n        uint256 newInterestRateAccumulator\n    ) internal onlyApprovedOrOwner(msg.sender, srcVaultID) returns (uint256, uint256) {\n        // The `stablecoinAmount` needs to be rounded down in the `_increaseDebt` function to reduce the room for exploits\n        (stablecoinAmount, oracleValue, newInterestRateAccumulator) = _increaseDebt(\n            srcVaultID,\n            stablecoinAmount,\n            oracleValue,\n            newInterestRateAccumulator\n        );\n        if (address(vaultManager) == address(this)) {\n            _repayDebt(dstVaultID, stablecoinAmount, newInterestRateAccumulator);\n        } else {\n            require(treasury.isVaultManager(address(vaultManager)), \"22\");\n            vaultManager.getDebtOut(dstVaultID, stablecoinAmount, borrowFee);\n        }\n        return (oracleValue, newInterestRateAccumulator);\n    }\n\n    /// @notice Increases the debt of a given vault and verifies that this vault is still solvent\n    /// @param vaultID ID of the vault to increase the debt of\n    /// @param stablecoinAmount Amount of stablecoin to increase the debt of: this amount is converted in\n    /// normalized debt using the pre-computed (or not) `newInterestRateAccumulator` value\n    /// @param oracleValueStart Oracle value at the start of the call (given here to avoid double computations)\n    /// @param newInterestRateAccumulator Value of the interest rate accumulator (potentially zero if it has not been\n    /// computed yet)\n    /// @return Amount of stablecoins to issue from this debt increase\n    /// @return Computed value of the oracle\n    /// @return Computed value of the interest rate accumulator\n    /// @dev The `stablecoinAmount` outputted need to be rounded down with respect to the change amount\n    function _increaseDebt(\n        uint256 vaultID,\n        uint256 stablecoinAmount,\n        uint256 oracleValueStart,\n        uint256 newInterestRateAccumulator\n    )\n        internal\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (newInterestRateAccumulator == 0) newInterestRateAccumulator = _calculateCurrentInterestRateAccumulator();\n        uint256 changeAmount = (stablecoinAmount * BASE_INTEREST) / newInterestRateAccumulator;\n        if (vaultData[vaultID].normalizedDebt == 0)\n            require(changeAmount * BASE_INTEREST > dust * newInterestRateAccumulator, \"24\");\n        vaultData[vaultID].normalizedDebt += changeAmount;\n        totalNormalizedDebt += changeAmount;\n        require(totalNormalizedDebt * newInterestRateAccumulator <= debtCeiling * BASE_INTEREST, \"45\");\n        (uint256 healthFactor, , , uint256 oracleValue, ) = _isSolvent(\n            vaultData[vaultID],\n            oracleValueStart,\n            newInterestRateAccumulator\n        );\n        require(healthFactor > BASE_PARAMS, \"21\");\n        emit InternalDebtUpdated(vaultID, changeAmount, 1);\n        return ((changeAmount * BASE_INTEREST) / newInterestRateAccumulator, oracleValue, newInterestRateAccumulator);\n    }\n\n    /// @notice Decreases the debt of a given vault and verifies that this vault still has an amount of debt superior\n    /// to a dusty amount or no debt at all\n    /// @param vaultID ID of the vault to decrease the debt of\n    /// @param stablecoinAmount Amount of stablecoin to decrease the debt of: this amount is converted in\n    /// normalized debt using the pre-computed (or not) `newInterestRateAccumulator` value\n    /// To repay the whole debt, one can pass `type(uint256).max`\n    /// @param newInterestRateAccumulator Value of the interest rate accumulator (potentially zero if it has not been\n    /// computed yet)\n    /// @return Amount of stablecoins to be burnt to correctly repay the debt\n    /// @return Computed value of the interest rate accumulator\n    /// @dev If `stablecoinAmount` is `type(uint256).max`, this function will repay all the debt of the vault\n    function _repayDebt(\n        uint256 vaultID,\n        uint256 stablecoinAmount,\n        uint256 newInterestRateAccumulator\n    ) internal returns (uint256, uint256) {\n        if (newInterestRateAccumulator == 0) newInterestRateAccumulator = _calculateCurrentInterestRateAccumulator();\n        uint256 newVaultNormalizedDebt = vaultData[vaultID].normalizedDebt;\n        // To save one variable declaration, `changeAmount` is first expressed in stablecoin amount before being converted\n        // to a normalized amount. Here we first store the maximum amount that can be repaid given the current debt\n        uint256 changeAmount = (newVaultNormalizedDebt * newInterestRateAccumulator) / BASE_INTEREST;\n        // In some situations (e.g. liquidations), the `stablecoinAmount` is rounded above and we want to make\n        // sure to avoid underflows in all situations\n        if (stablecoinAmount >= changeAmount) {\n            stablecoinAmount = changeAmount;\n            changeAmount = newVaultNormalizedDebt;\n        } else {\n            changeAmount = (stablecoinAmount * BASE_INTEREST) / newInterestRateAccumulator;\n        }\n        newVaultNormalizedDebt -= changeAmount;\n        totalNormalizedDebt -= changeAmount;\n        require(\n            newVaultNormalizedDebt == 0 || newVaultNormalizedDebt * newInterestRateAccumulator > dust * BASE_INTEREST,\n            \"24\"\n        );\n        vaultData[vaultID].normalizedDebt = newVaultNormalizedDebt;\n        emit InternalDebtUpdated(vaultID, changeAmount, 0);\n        return (stablecoinAmount, newInterestRateAccumulator);\n    }\n\n    /// @notice Handles the simultaneous repayment of stablecoins with a transfer of collateral\n    /// @param collateralAmountToGive Amount of collateral the contract should give\n    /// @param stableAmountToRepay Amount of stablecoins the contract should burn from the call\n    /// @param from Address from which stablecoins should be burnt: it should be the `msg.sender` or at least\n    /// approved by it\n    /// @param to Address to which stablecoins should be sent\n    /// @param who Address which should be notified if needed of the transfer\n    /// @param data Data to pass to the `who` contract for it to successfully give the correct amount of stablecoins\n    /// to the `from` address\n    /// @dev This function allows for capital-efficient liquidations and repayments of loans\n    function _handleRepay(\n        uint256 collateralAmountToGive,\n        uint256 stableAmountToRepay,\n        address from,\n        address to,\n        address who,\n        bytes memory data\n    ) internal {\n        if (collateralAmountToGive > 0) collateral.safeTransfer(to, collateralAmountToGive);\n        if (data.length > 0 && stableAmountToRepay > 0) {\n            IRepayCallee(who).repayCallStablecoin(from, stableAmountToRepay, collateralAmountToGive, data);\n            stablecoin.burnFrom(stableAmountToRepay, from, msg.sender);\n        } else if (stableAmountToRepay > 0) stablecoin.burnFrom(stableAmountToRepay, from, msg.sender);\n    }\n\n    // =================== Treasury Relationship Functions =========================\n\n    /// @inheritdoc IVaultManagerFunctions\n    function accrueInterestToTreasury() external onlyTreasury returns (uint256 surplusValue, uint256 badDebtValue) {\n        _accrue();\n        surplusValue = surplus;\n        badDebtValue = badDebt;\n        if (surplusValue >= badDebtValue) {\n            surplusValue -= badDebtValue;\n            badDebtValue = 0;\n            stablecoin.mint(address(treasury), surplusValue);\n        } else {\n            badDebtValue -= surplusValue;\n            surplusValue = 0;\n        }\n        surplus = 0;\n        badDebt = 0;\n        emit AccruedToTreasury(surplusValue, badDebtValue);\n    }\n\n    /// @notice Accrues interest accumulated across all vaults to the surplus\n    /// @dev This function updates the `interestAccumulator`\n    /// @dev It should also be called when updating the value of the per second interest rate\n    function _accrue() internal {\n        uint256 newInterestRateAccumulator = _calculateCurrentInterestRateAccumulator();\n        uint256 interestAccrued = (totalNormalizedDebt * (newInterestRateAccumulator - interestAccumulator)) /\n            BASE_INTEREST;\n        surplus += interestAccrued;\n        interestAccumulator = newInterestRateAccumulator;\n        lastInterestAccumulatorUpdated = block.timestamp;\n        emit InterestRateAccumulatorUpdated(newInterestRateAccumulator, block.timestamp);\n    }\n\n    // ============================ Liquidations ===================================\n\n    /// @notice Liquidates an ensemble of vaults specified by their IDs\n    /// @param vaultIDs List of the vaults to liquidate\n    /// @param amounts Amount of stablecoin to bring for the liquidation of each vault\n    /// @param from Address from which the stablecoins for the liquidation should be taken: this address should be the `msg.sender`\n    /// or have received an approval\n    /// @param to Address to which discounted collateral should be sent\n    /// @dev This function will not revert if it's called on a vault that cannot be liquidated\n    function liquidate(\n        uint256[] memory vaultIDs,\n        uint256[] memory amounts,\n        address from,\n        address to\n    ) external returns (LiquidatorData memory) {\n        return liquidate(vaultIDs, amounts, from, to, address(0), new bytes(0));\n    }\n\n    /// @notice Liquidates an ensemble of vaults specified by their IDs\n    /// @param vaultIDs List of the vaults to liquidate\n    /// @param amounts Amount of stablecoin to bring for the liquidation of each vault\n    /// @param from Address from which the stablecoins for the liquidation should be taken: this address should be the `msg.sender`\n    /// or have received an approval\n    /// @param to Address to which discounted collateral should be sent\n    /// @param who Address of the contract to handle repayment of stablecoins from received collateral\n    /// @param data Data to pass to the repayment contract in case of\n    /// @dev This function will revert if it's called on a vault that cannot be liquidated or that does not exist\n    function liquidate(\n        uint256[] memory vaultIDs,\n        uint256[] memory amounts,\n        address from,\n        address to,\n        address who,\n        bytes memory data\n    ) public whenNotPaused nonReentrant returns (LiquidatorData memory liqData) {\n        // Stores all the data about an ongoing liquidation of multiple vaults\n        require(vaultIDs.length == amounts.length, \"25\");\n        liqData.oracleValue = oracle.read();\n        liqData.newInterestRateAccumulator = _calculateCurrentInterestRateAccumulator();\n        for (uint256 i = 0; i < vaultIDs.length; i++) {\n            Vault memory vault = vaultData[vaultIDs[i]];\n            // Computing if liquidation can take place for a vault\n            LiquidationOpportunity memory liqOpp = _checkLiquidation(\n                vault,\n                msg.sender,\n                liqData.oracleValue,\n                liqData.newInterestRateAccumulator\n            );\n\n            // Makes sure not to leave a dusty amount in the vault by either not liquidating too much\n            // or everything\n            if (\n                (liqOpp.thresholdRepayAmount > 0 && amounts[i] > liqOpp.thresholdRepayAmount) ||\n                amounts[i] > liqOpp.maxStablecoinAmountToRepay\n            ) amounts[i] = liqOpp.maxStablecoinAmountToRepay;\n\n            // liqOpp.discount stores in fact `1-discount`\n            uint256 collateralReleased = (amounts[i] * BASE_PARAMS * _collatBase) /\n                (liqOpp.discount * liqData.oracleValue);\n            // Because we're rounding up in some divisions, `collateralReleased` can be greater than the `collateralAmount` of the vault\n            // In this case, `stablecoinAmountToReceive` is still rounded up\n            if (vault.collateralAmount <= collateralReleased) {\n                collateralReleased = vault.collateralAmount;\n                // Reinitializing the `vaultID`: we're not burning the vault in this case for integration purposes\n                delete vaultData[vaultIDs[i]];\n                liqData.badDebtFromLiquidation +=\n                    liqOpp.currentDebt -\n                    (amounts[i] * liquidationSurcharge) /\n                    BASE_PARAMS;\n                // There may be an edge case in which: `amounts[i] = (currentDebt * BASE_PARAMS) / surcharge + 1`\n                // In this case, as long as `surcharge < BASE_PARAMS`, there cannot be any underflow in the operation\n                // above\n            } else {\n                vaultData[vaultIDs[i]].collateralAmount -= collateralReleased;\n                // In the case where the full debt is being repaid, `amounts[i]` must be rounded above\n                _repayDebt(\n                    vaultIDs[i],\n                    (amounts[i] * liquidationSurcharge) / BASE_PARAMS,\n                    liqData.newInterestRateAccumulator\n                );\n            }\n            liqData.collateralAmountToGive += collateralReleased;\n            liqData.stablecoinAmountToReceive += amounts[i];\n        }\n        // Normalization of good and bad debt is already handled in the `_accrue` function\n        surplus += (liqData.stablecoinAmountToReceive * (BASE_PARAMS - liquidationSurcharge)) / BASE_PARAMS;\n        badDebt += liqData.badDebtFromLiquidation;\n        _handleRepay(liqData.collateralAmountToGive, liqData.stablecoinAmountToReceive, from, to, who, data);\n    }\n\n    /// @notice Internal version of the `checkLiquidation` function\n    /// @dev This function takes two additional parameters as when entering this function `oracleValue`\n    /// and `newInterestRateAccumulator` should have always been computed\n    function _checkLiquidation(\n        Vault memory vault,\n        address liquidator,\n        uint256 oracleValue,\n        uint256 newInterestRateAccumulator\n    ) internal view returns (LiquidationOpportunity memory liqOpp) {\n        // Checking if the vault can be liquidated\n        (uint256 healthFactor, uint256 currentDebt, uint256 collateralAmountInStable, , ) = _isSolvent(\n            vault,\n            oracleValue,\n            newInterestRateAccumulator\n        );\n        // Health factor of a vault that does not exist is `type(uint256).max`\n        require(healthFactor < BASE_PARAMS, \"44\");\n\n        uint256 liquidationDiscount = (_computeLiquidationBoost(liquidator) * (BASE_PARAMS - healthFactor)) /\n            BASE_PARAMS;\n        // In fact `liquidationDiscount` is stored here as 1 minus discount to save some computation costs\n        // This value is necessarily > 0 as `maxLiquidationDiscount < BASE_PARAMS`\n        liquidationDiscount = liquidationDiscount >= maxLiquidationDiscount\n            ? BASE_PARAMS - maxLiquidationDiscount\n            : BASE_PARAMS - liquidationDiscount;\n        // Same for the surcharge here: it's in fact 1 - the fee taken by the protocol\n        uint256 surcharge = liquidationSurcharge;\n        // Checking if we're in a situation where the health factor is an increasing or a decreasing function of the\n        // amount repaid\n        uint256 maxAmountToRepay;\n        uint256 thresholdRepayAmount;\n        // In the first case, the health factor is an increasing function of the stablecoin amount to repay,\n        // this means that the liquidator can bring the vault to the target health ratio\n        if (healthFactor * liquidationDiscount * surcharge >= collateralFactor * BASE_PARAMS**2) {\n            // This is the max amount to repay that will bring the person to the target health factor\n            // Denom is always positive when a vault gets liquidated in this case and when the health factor\n            // is an increasing function of the amount of stablecoins repaid\n            // And given that most parameters are in base 9, the numerator can very hardly overflow here\n            maxAmountToRepay =\n                ((targetHealthFactor * currentDebt - collateralAmountInStable * collateralFactor) *\n                    BASE_PARAMS *\n                    liquidationDiscount) /\n                (surcharge * targetHealthFactor * liquidationDiscount - (BASE_PARAMS**2) * collateralFactor);\n            // The quantity below tends to be rounded in the above direction, which means that governance should\n            // set the `targetHealthFactor` accordingly\n            // Need to check for the dust: liquidating should not leave a dusty amount in the vault\n            if (currentDebt <= (maxAmountToRepay * surcharge) / BASE_PARAMS + dust) {\n                // If liquidating to the target threshold would leave a dusty amount: the liquidator can repay all\n                // We're rounding up the max amount to repay to make sure all the debt ends up being paid\n                // and we're computing again the real value of the debt to avoid propagation of rounding errors\n                maxAmountToRepay =\n                    (vault.normalizedDebt * newInterestRateAccumulator * BASE_PARAMS) /\n                    (surcharge * BASE_INTEREST) +\n                    1;\n                // In this case the threshold amount is such that it leaves just enough dust\n                // This line cannot underflow as long as the  `dust` parameter is constant: it is always checked that\n                // the debt is greater than the  `dust`. If the  `dust` was to increase due to an implementation upgrade\n                // we would need to add some extra checks to avoid underflows\n                // Here the `thresholdRepayAmount` is also rounded down: which means that if a liquidator repays this amount\n                // then there would be more than `dust` left in the vault\n                thresholdRepayAmount = ((currentDebt - dust) * BASE_PARAMS) / surcharge;\n            }\n        } else {\n            // In all cases the liquidator can repay stablecoins such that they'll end up getting exactly the collateral\n            // in the liquidated vault\n            // Rounding up to make sure all gets liquidated in this case: the liquidator will never get more than the collateral\n            // amount in the vault however: we're performing the computation of the `collateralAmountInStable` again to avoid\n            // propagation of rounding errors\n            maxAmountToRepay =\n                (vault.collateralAmount * liquidationDiscount * oracleValue) /\n                (BASE_PARAMS * _collatBase) +\n                1;\n            // It should however make sure not to leave a dusty amount of collateral (in stablecoin value) in the vault\n            if (collateralAmountInStable > _dustCollateral)\n                // There's no issue with this amount being rounded down\n                thresholdRepayAmount =\n                    ((collateralAmountInStable - _dustCollateral) * liquidationDiscount) /\n                    BASE_PARAMS;\n                // If there is from the beginning a dusty amount of collateral, liquidator should repay everything that's left\n            else thresholdRepayAmount = maxAmountToRepay;\n        }\n        liqOpp.maxStablecoinAmountToRepay = maxAmountToRepay;\n        liqOpp.maxCollateralAmountGiven =\n            (maxAmountToRepay * BASE_PARAMS * _collatBase) /\n            (oracleValue * liquidationDiscount);\n        liqOpp.thresholdRepayAmount = thresholdRepayAmount;\n        liqOpp.discount = liquidationDiscount;\n        liqOpp.currentDebt = currentDebt;\n    }\n\n    /// @notice Computes the liquidation boost of a given address, that is the slope of the discount function\n    /// @param liquidator Address for which boost should be computed\n    /// @return The slope of the discount function\n    function _computeLiquidationBoost(address liquidator) internal view returns (uint256) {\n        if (address(veBoostProxy) == address(0)) {\n            return yLiquidationBoost[0];\n        } else {\n            uint256 adjustedBalance = veBoostProxy.adjusted_balance_of(liquidator);\n            if (adjustedBalance >= xLiquidationBoost[1]) return yLiquidationBoost[1];\n            else if (adjustedBalance <= xLiquidationBoost[0]) return yLiquidationBoost[0];\n            else\n                return\n                    yLiquidationBoost[0] +\n                    ((yLiquidationBoost[1] - yLiquidationBoost[0]) * (adjustedBalance - xLiquidationBoost[0])) /\n                    (xLiquidationBoost[1] - xLiquidationBoost[0]);\n        }\n    }\n\n    // ============================== Setters ======================================\n\n    /// @notice Sets parameters encoded as uint64\n    /// @param param Value for the parameter\n    /// @param what Parameter to change\n    /// @dev This function performs the required checks when updating a parameter\n    /// @dev When setting parameters governance should make sure that when `HF < CF/((1-surcharge)(1-discount))`\n    /// and hence when liquidating a vault is going to decrease its health factor, `discount = max discount`.\n    /// Otherwise, it may be profitable for the liquidator to liquidate in multiple times: as it will decrease\n    /// the HF and therefore increase the discount between each time\n    function setUint64(uint64 param, bytes32 what) external onlyGovernorOrGuardian {\n        if (what == \"collateralFactor\") {\n            require(param <= liquidationSurcharge, \"9\");\n            collateralFactor = param;\n        } else if (what == \"targetHealthFactor\") {\n            require(param >= BASE_PARAMS, \"17\");\n            targetHealthFactor = param;\n        } else if (what == \"borrowFee\") {\n            require(param <= BASE_PARAMS, \"9\");\n            borrowFee = param;\n        } else if (what == \"interestRate\") {\n            _accrue();\n            interestRate = param;\n        } else if (what == \"liquidationSurcharge\") {\n            require(collateralFactor <= param && param <= BASE_PARAMS, \"18\");\n            liquidationSurcharge = param;\n        } else if (what == \"maxLiquidationDiscount\") {\n            require(param < BASE_PARAMS, \"9\");\n            maxLiquidationDiscount = param;\n        } else {\n            revert(\"43\");\n        }\n        emit FiledUint64(param, what);\n    }\n\n    /// @notice Sets `debtCeiling`\n    /// @param _debtCeiling New value for `debtCeiling`\n    function setDebtCeiling(uint256 _debtCeiling) external onlyGovernorOrGuardian {\n        debtCeiling = _debtCeiling;\n        emit DebtCeilingUpdated(_debtCeiling);\n    }\n\n    /// @notice Sets the parameters for the liquidation booster which encodes the slope of the discount\n    /// @param _veBoostProxy Address which queries veANGLE balances and adjusted balances from delegation\n    /// @param xBoost Threshold values of veANGLE adjusted balances\n    /// @param yBoost Values of the liquidation boost at the threshold values of x\n    /// @dev There are 2 modes:\n    /// When boost is enabled, `xBoost` and `yBoost` should have a length of 2, but if they have a\n    /// higher length contract will still work as expected. Contract will also work as expected if their\n    /// length differ\n    /// When boost is disabled, `_veBoostProxy` needs to be zero address and `yBoost[0]` is the base boost\n    function setLiquidationBoostParameters(\n        address _veBoostProxy,\n        uint256[] memory xBoost,\n        uint256[] memory yBoost\n    ) external onlyGovernorOrGuardian {\n        require(\n            (xBoost.length == yBoost.length) &&\n                (yBoost[0] > 0) &&\n                ((_veBoostProxy == address(0)) || (xBoost[1] > xBoost[0] && yBoost[1] >= yBoost[0])),\n            \"15\"\n        );\n        veBoostProxy = IVeBoostProxy(_veBoostProxy);\n        xLiquidationBoost = xBoost;\n        yLiquidationBoost = yBoost;\n        emit LiquidationBoostParametersUpdated(_veBoostProxy, xBoost, yBoost);\n    }\n\n    /// @notice Toggles permission for owning vaults by any account\n    function toggleWhitelisting() external onlyGovernor {\n        bool flag = !whitelistingActivated;\n        whitelistingActivated = flag;\n        emit ToggledWhitelisting(flag);\n    }\n\n    /// @notice Changes the reference to the oracle contract used to get the price of the oracle\n    /// @param _oracle Reference to the oracle contract\n    function setOracle(address _oracle) external onlyGovernor {\n        require(IOracle(_oracle).treasury() == treasury, \"33\");\n        oracle = IOracle(_oracle);\n        emit OracleUpdated(_oracle);\n    }\n\n    /// @inheritdoc IVaultManagerFunctions\n    function setTreasury(address _treasury) external onlyTreasury {\n        treasury = ITreasury(_treasury);\n        // This function makes sure to propagate the change to the associated contract\n        // even though a single oracle contract could be used in different places\n        oracle.setTreasury(_treasury);\n    }\n\n    /// @notice Changes the whitelisting of an address\n    /// @param target Address to toggle\n    function toggleWhitelist(address target) external onlyGovernor {\n        isWhitelisted[target] = !isWhitelisted[target];\n    }\n\n    /// @notice Pauses external permissionless functions of the contract\n    function togglePause() external onlyGovernorOrGuardian {\n        paused = !paused;\n    }\n\n    /// @notice Changes the ERC721 metadata URI\n    function setBaseURI(string memory baseURI_) external onlyGovernorOrGuardian {\n        _baseURI = baseURI_;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}